<it provided the above code but I think the models can be better, provide a more
detailed prompt for improving the models and push the LLMs to their absolute
limits. Below is the code it gave:>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soft Vinyl Diorama - Enhanced Collection</title>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: radial-gradient(circle at center, #2a2a35 0%, #1a1a25 100%);
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        inset: 0;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(107, 91, 122, 0.2);
        border-top-color: #8b9bb4;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .glass {
        background: rgba(30, 30, 40, 0.7);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: 1px solid rgba(60, 60, 80, 0.5);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .animal-btn {
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        position: relative;
        overflow: hidden;
        background: rgba(40, 40, 55, 0.6);
        color: #b0b8c8;
      }
      .animal-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(80, 80, 100, 0.3),
          rgba(40, 40, 55, 0)
        );
        opacity: 0;
        transition: opacity 0.3s;
      }
      .animal-btn:hover {
        transform: translateY(-2px);
        background: rgba(60, 60, 80, 0.85);
        color: #e0e4ec;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }
      .animal-btn.active {
        background: #4a5068;
        color: #ffffff;
        font-weight: 700;
        box-shadow: 0 4px 12px rgba(139, 155, 180, 0.25);
        transform: scale(1.02);
      }
      .animal-btn.active::after {
        opacity: 1;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .pop-in {
        animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .tool-btn {
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.7);
      }
      .tool-btn:hover {
        background: rgba(255, 255, 255, 0.95);
        transform: scale(1.05);
      }

      .color-swatch {
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .color-swatch:hover {
        transform: scale(1.15);
      }
      .color-swatch.active {
        ring: 2px solid #6b7c93;
        transform: scale(1.1);
        box-shadow: 0 0 0 2px #6b7c93;
      }

      /* Scrollbar styling for button container */
      .btn-scroll::-webkit-scrollbar {
        height: 4px;
      }
      .btn-scroll::-webkit-scrollbar-track {
        background: transparent;
      }
      .btn-scroll::-webkit-scrollbar-thumb {
        background: rgba(139, 155, 180, 0.3);
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div
      id="loading"
      class="fixed inset-0 z-[1000] flex flex-col items-center justify-center bg-[#f0f8ff] transition-opacity duration-700"
    >
      <div class="loader"></div>
      <div class="mt-6 text-center">
        <div class="tracking-[0.2em] text-[#6b7c93] text-lg font-medium">
          VINYL SERENITY
        </div>
        <div class="mt-2 text-[#98a6b8] text-sm">Molding plastic...</div>
      </div>
    </div>

    <!-- Error Overlay -->
    <div
      id="error-overlay"
      class="fixed inset-0 z-[2000] hidden flex-col items-center justify-center bg-red-50/95 p-6"
    >
      <div class="max-w-md text-center">
        <div class="text-5xl mb-4">‚ö†Ô∏è</div>
        <h1 class="text-xl font-bold text-red-800 mb-2">Rendering Error</h1>
        <p class="text-red-600 mb-6 text-sm" id="error-message">
          WebGL Context Lost
        </p>
        <button
          onclick="location.reload()"
          class="px-6 py-2 bg-white text-red-800 rounded-full shadow-md hover:shadow-lg transition text-sm font-medium border border-red-100"
        >
          Reload Viewer
        </button>
      </div>
    </div>

    <!-- Header -->
    <div
      class="pointer-events-none fixed top-6 left-1/2 -translate-x-1/2 z-[120]"
    >
      <div
        class="text-[#8b9bb4] text-xs font-bold tracking-[0.3em] uppercase opacity-80"
      >
        Soft Vinyl Collection
      </div>
    </div>

    <!-- Animal Badge -->
    <div class="fixed top-12 left-1/2 -translate-x-1/2 z-[120]">
      <div
        id="animal-badge"
        class="glass rounded-full px-6 py-2 text-[#5a6b85] text-sm font-semibold transition-all duration-300 flex items-center gap-2"
      >
        <span id="animal-emoji" class="text-lg">üê∞</span>
        <span id="animal-name">Bunny</span>
      </div>
    </div>

    <!-- Tool Buttons (Top Right) -->
    <div class="fixed top-6 right-6 z-[120] flex gap-2">
      <button
        id="btn-screenshot"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Screenshot"
      >
        üì∑
      </button>
      <button
        id="btn-fullscreen"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Fullscreen"
      >
        ‚õ∂
      </button>
      <button
        id="btn-sound"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Sound"
      >
        üîá
      </button>
    </div>

    <!-- Color Palette (Top Left) -->
    <div class="fixed top-6 left-6 z-[120]">
      <div class="glass rounded-2xl p-3">
        <div
          class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
        >
          Color
        </div>
        <div id="color-palette" class="flex gap-2">
          <div
            class="color-swatch active w-6 h-6 rounded-full bg-white border border-gray-200"
            data-color="default"
            title="Default"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-pink-200"
            data-color="pink"
            title="Pink"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-blue-200"
            data-color="blue"
            title="Blue"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-yellow-200"
            data-color="yellow"
            title="Yellow"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-green-200"
            data-color="green"
            title="Green"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-purple-200"
            data-color="purple"
            title="Purple"
          ></div>
        </div>
      </div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- Controls -->
    <div
      class="fixed bottom-6 left-1/2 -translate-x-1/2 z-[120] w-[95%] max-w-3xl"
    >
      <div class="glass rounded-2xl p-2 sm:p-3">
        <div
          class="flex overflow-x-auto btn-scroll gap-2 pb-1 justify-start sm:justify-center"
        >
          <button
            class="animal-btn active px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="bunny"
          >
            üê∞ Bunny
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="bear"
          >
            üêª Bear
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="penguin"
          >
            üêß Penguin
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="fox"
          >
            ü¶ä Fox
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="elephant"
          >
            üêò Elephant
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="cat"
          >
            üê± Cat
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="owl"
          >
            ü¶â Owl
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="panda"
          >
            üêº Panda
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="duck"
          >
            ü¶Ü Duck
          </button>
          <button
            class="animal-btn px-3 py-2 rounded-xl text-xs text-[#6b7c93] font-medium whitespace-nowrap flex-shrink-0"
            data-type="frog"
          >
            üê∏ Frog
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ==========================================
      // ERROR HANDLING
      // ==========================================
      function showError(msg) {
        document.getElementById("loading").style.display = "none";
        const el = document.getElementById("error-overlay");
        el.classList.remove("hidden");
        el.classList.add("flex");
        document.getElementById("error-message").innerText = msg;
      }

      try {
        // ==========================================
        // ANIMAL CONFIGURATION SYSTEM
        // ==========================================
        const ANIMAL_CONFIG = {
          bunny: {
            name: "Bunny",
            emoji: "üê∞",
            primaryColor: 0xffffff,
            secondaryColor: 0xffb7c5,
            accentColor: 0x1a1a1a,
          },
          bear: {
            name: "Bear",
            emoji: "üêª",
            primaryColor: 0x8d7b68,
            secondaryColor: 0xe0cda7,
            accentColor: 0x1a1a1a,
          },
          penguin: {
            name: "Penguin",
            emoji: "üêß",
            primaryColor: 0x1a1a1a,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c42,
          },
          fox: {
            name: "Fox",
            emoji: "ü¶ä",
            primaryColor: 0xff8c42,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          elephant: {
            name: "Elephant",
            emoji: "üêò",
            primaryColor: 0x9ca3af,
            secondaryColor: 0xffffff,
            accentColor: 0x6b7280,
          },
          cat: {
            name: "Cat",
            emoji: "üê±",
            primaryColor: 0xffa500,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          owl: {
            name: "Owl",
            emoji: "ü¶â",
            primaryColor: 0x8b4513,
            secondaryColor: 0xdeb887,
            accentColor: 0xffa500,
          },
          panda: {
            name: "Panda",
            emoji: "üêº",
            primaryColor: 0xffffff,
            secondaryColor: 0x1a1a1a,
            accentColor: 0x1a1a1a,
          },
          duck: {
            name: "Duck",
            emoji: "ü¶Ü",
            primaryColor: 0xf5deb3,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c00,
          },
          frog: {
            name: "Frog",
            emoji: "üê∏",
            primaryColor: 0x32cd32,
            secondaryColor: 0x98fb98,
            accentColor: 0xff6347,
          },
        };

        // Color palettes for customization
        const COLOR_PALETTES = {
          default: null,
          pink: { primary: 0xffb6c1, secondary: 0xffc0cb },
          blue: { primary: 0xadd8e6, secondary: 0xe0ffff },
          yellow: { primary: 0xfffacd, secondary: 0xffffe0 },
          green: { primary: 0x98fb98, secondary: 0xf0fff0 },
          purple: { primary: 0xdda0dd, secondary: 0xe6e6fa },
        };

        // ==========================================
        // SCENE SETUP
        // ==========================================
        const container = document.getElementById("canvas-container");
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e2028);
        scene.fog = new THREE.Fog(0x1e2028, 10, 30);

        const camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.set(5, 3, 5);

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        container.appendChild(renderer.domElement);

        // ==========================================
        // LIGHTING - PHASE 4 ENHANCED PREMIUM SETUP
        // ==========================================
        // Warm ambient for soft vinyl appearance
        const ambientLight = new THREE.AmbientLight(0xfff8f0, 0.7);
        scene.add(ambientLight);

        // Key light - warm, main illumination with HIGH QUALITY shadows
        const keyLight = new THREE.DirectionalLight(0xffeedd, 2.4);
        keyLight.position.set(5, 10, 4);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 4096; // 4K shadow for crisp edges
        keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.bias = -0.00005; // Reduced bias for less peter-panning
        keyLight.shadow.normalBias = 0.02; // Helps with self-shadowing
        keyLight.shadow.radius = 4; // Softer shadows
        keyLight.shadow.camera.near = 0.5;
        keyLight.shadow.camera.far = 25;
        keyLight.shadow.camera.left = -8;
        keyLight.shadow.camera.right = 8;
        keyLight.shadow.camera.top = 8;
        keyLight.shadow.camera.bottom = -8;
        scene.add(keyLight);

        // Cool fill light - adds dimension
        const fillLight = new THREE.DirectionalLight(0xc8e0ff, 1.5);
        fillLight.position.set(-5, 4, -2);
        scene.add(fillLight);

        // ENHANCED RIM LIGHT - Colored for dramatic effect
        const rimLight = new THREE.DirectionalLight(0xffc8ff, 1.5);
        rimLight.position.set(0, 4, -8);
        scene.add(rimLight);

        // Secondary rim (opposite side) for balanced silhouette
        const rimLight2 = new THREE.DirectionalLight(0xc8ffff, 0.8);
        rimLight2.position.set(3, 2, -6);
        scene.add(rimLight2);

        // Bottom fill for softer under-shadows (ground bounce)
        const bottomFill = new THREE.DirectionalLight(0xfff5ee, 0.5);
        bottomFill.position.set(0, -3, 2);
        scene.add(bottomFill);

        // Subtle side accent light
        const accentLight = new THREE.DirectionalLight(0xffe8d0, 0.7);
        accentLight.position.set(-4, 2, 5);
        scene.add(accentLight);

        // ==========================================
        // POST-PROCESSING - ENHANCED BLOOM
        // ==========================================
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.3, // Increased bloom strength for premium glow
          0.35, // Tighter radius
          0.85 // Higher threshold for selective glow
        );
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;
        controls.minDistance = 3;
        controls.maxDistance = 10;
        controls.maxPolarAngle = Math.PI / 1.9;

        // ==========================================
        // MATERIAL FACTORY - PHASE 4 PREMIUM VINYL
        // ==========================================
        function createVinylMaterial(color, options = {}) {
          // Calculate sheen color based on primary color for subtle iridescence
          const baseColor = new THREE.Color(color);
          const sheenColor = baseColor.clone().offsetHSL(0.05, 0.1, 0.2);

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.2,
            metalness: options.metalness ?? 0.0,
            clearcoat: options.clearcoat ?? 0.6,
            clearcoatRoughness: options.clearcoatRoughness ?? 0.06,
            reflectivity: options.reflectivity ?? 0.7,
            // Enhanced sheen for soft vinyl subsurface
            sheen: options.sheen ?? 0.35,
            sheenRoughness: options.sheenRoughness ?? 0.35,
            sheenColor: options.sheenColor ?? sheenColor,
            // Stronger iridescence for premium look
            iridescence: options.iridescence ?? 0.2,
            iridescenceIOR: options.iridescenceIOR ?? 1.4,
            // Environment map intensity for reflections
            envMapIntensity: options.envMapIntensity ?? 0.8,
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Matte material variant for softer areas
        function createMatteMaterial(color, options = {}) {
          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.6,
            metalness: 0.0,
            clearcoat: 0.1,
            sheen: 0.5,
            sheenRoughness: 0.8,
            sheenColor: new THREE.Color(color).offsetHSL(0, -0.1, 0.3),
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Cached materials
        const materialCache = new Map();
        function getMaterial(color, options = {}) {
          const key = `${color}-${JSON.stringify(options)}`;
          if (!materialCache.has(key)) {
            materialCache.set(key, createVinylMaterial(color, options));
          }
          return materialCache.get(key);
        }

        // Special materials - ENHANCED for premium look
        const SPECIAL_MATERIALS = {
          // Ultra-glossy deep pupil with subtle blue undertone
          eyeBlack: new THREE.MeshPhysicalMaterial({
            color: 0x050510,
            roughness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            metalness: 0.05,
            reflectivity: 1.0,
            ior: 1.5,
          }),
          // Creamy white sclera with subtle translucency
          eyeWhite: new THREE.MeshPhysicalMaterial({
            color: 0xfffef8,
            roughness: 0.08,
            clearcoat: 0.9,
            clearcoatRoughness: 0.05,
            sheen: 0.2,
            sheenColor: new THREE.Color(0xfff0f0),
            transmission: 0.02,
            thickness: 0.1,
          }),
          // Bright specular highlight with subtle bloom potential
          specular: new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.95,
          }),
          // Deep black slit pupil
          pupilSlit: new THREE.MeshBasicMaterial({ color: 0x000005 }),
          // New: Iris material for colored eye details
          iris: function (color) {
            return new THREE.MeshPhysicalMaterial({
              color: color,
              roughness: 0.1,
              clearcoat: 0.8,
              metalness: 0.0,
              sheen: 0.4,
              sheenColor: new THREE.Color(color).offsetHSL(0.1, 0, 0.2),
            });
          },
        };

        // ==========================================
        // GEOMETRY HELPERS
        // ==========================================

        // Teardrop/Paddle shape for ears
        function createTeardropGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 16
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * (1 - t) - height / 2;
            const radius =
              radiusBottom + (radiusTop - radiusBottom) * Math.pow(1 - t, 0.5);
            points.push(new THREE.Vector2(radius, y));
          }
          points.push(new THREE.Vector2(0, -height / 2));
          return new THREE.LatheGeometry(points, 16);
        }

        // Pear shape for body
        function createPearGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 32
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * t - height / 2;
            // Pear curve - wider at bottom
            const radius =
              radiusTop + (radiusBottom - radiusTop) * Math.pow(t, 0.6);
            points.push(new THREE.Vector2(radius * Math.sin(Math.PI * t), y));
          }
          return new THREE.LatheGeometry(points, 24);
        }

        // Curved trunk with segments
        function createTrunkGeometry(
          baseRadius,
          tipRadius,
          segments,
          curveStrength = 0.3
        ) {
          const group = new THREE.Group();
          for (let i = 0; i < segments; i++) {
            const t = i / (segments - 1);
            const radius = baseRadius + (tipRadius - baseRadius) * t;
            const segment = new THREE.Mesh(
              new THREE.SphereGeometry(radius, 12, 12),
              null // Material applied later
            );
            // S-curve positioning
            const curve = Math.sin(t * Math.PI) * curveStrength;
            segment.position.y = -i * (baseRadius * 1.2);
            segment.position.z = curve + t * 0.2;
            group.add(segment);
          }
          return group;
        }

        // Eye with optional slit pupil - PREMIUM ENHANCED VERSION
        function createEye(scale = 1, slitPupil = false, options = {}) {
          const group = new THREE.Group();
          const baseScale = scale * 1.25; // 25% larger eyes overall

          // Optional eyelid ridge (for mammals)
          if (options.eyelid) {
            const lidGeom = new THREE.TorusGeometry(
              0.075 * baseScale,
              0.012 * baseScale,
              8,
              16,
              Math.PI
            );
            const lid = new THREE.Mesh(
              lidGeom,
              options.lidMaterial || getMaterial(0x1a1a1a)
            );
            lid.rotation.x = Math.PI / 2;
            lid.rotation.z = Math.PI;
            lid.position.set(0, 0.03 * baseScale, 0.02 * baseScale);
            group.add(lid);
          }

          // Ambient occlusion shadow ring around eye (subtle depth)
          const aoRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.078 * baseScale,
              0.008 * baseScale,
              8,
              24
            ),
            new THREE.MeshBasicMaterial({
              color: 0x2a2020,
              transparent: true,
              opacity: 0.15,
            })
          );
          aoRing.position.z = -0.002;
          group.add(aoRing);

          // Sclera (white) - slightly larger with depth
          const scleraGeom = new THREE.SphereGeometry(
            0.075 * baseScale,
            24,
            24
          );
          const sclera = new THREE.Mesh(scleraGeom, SPECIAL_MATERIALS.eyeWhite);
          group.add(sclera);

          // Iris ring (colored ring around pupil for depth)
          const irisColor = options.irisColor || 0x3a2510; // Deep brown default
          const irisRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.038 * baseScale,
              0.015 * baseScale,
              12,
              24
            ),
            SPECIAL_MATERIALS.iris(irisColor)
          );
          irisRing.position.z = 0.04 * baseScale;
          group.add(irisRing);

          // Inner iris gradient (darker inner ring)
          const innerIris = new THREE.Mesh(
            new THREE.RingGeometry(0.025 * baseScale, 0.045 * baseScale, 24),
            new THREE.MeshPhysicalMaterial({
              color: new THREE.Color(irisColor).offsetHSL(0, 0, -0.3),
              roughness: 0.15,
              clearcoat: 0.6,
              side: THREE.DoubleSide,
            })
          );
          innerIris.position.z = 0.042 * baseScale;
          group.add(innerIris);

          if (slitPupil) {
            // Cat-style slit pupil with subtle glow edge
            const pupilGeom = new THREE.CylinderGeometry(
              0.012 * baseScale,
              0.012 * baseScale,
              0.095 * baseScale,
              8
            );
            const pupil = new THREE.Mesh(
              pupilGeom,
              SPECIAL_MATERIALS.pupilSlit
            );
            pupil.rotation.x = Math.PI / 2;
            pupil.position.z = 0.055 * baseScale;
            group.add(pupil);

            // Subtle glow around slit for ethereal look
            const slitGlow = new THREE.Mesh(
              new THREE.CylinderGeometry(
                0.018 * baseScale,
                0.018 * baseScale,
                0.09 * baseScale,
                8
              ),
              new THREE.MeshBasicMaterial({
                color: irisColor,
                transparent: true,
                opacity: 0.25,
              })
            );
            slitGlow.rotation.x = Math.PI / 2;
            slitGlow.position.z = 0.054 * baseScale;
            group.add(slitGlow);
          } else {
            // Round pupil - larger for cuter look with depth
            const pupilGeom = new THREE.SphereGeometry(
              0.048 * baseScale,
              20,
              20
            );
            const pupil = new THREE.Mesh(pupilGeom, SPECIAL_MATERIALS.eyeBlack);
            pupil.position.z = 0.045 * baseScale;
            group.add(pupil);
          }

          // Primary highlight (larger, more prominent, positioned at 10 o'clock)
          const highlightGeom = new THREE.SphereGeometry(
            0.022 * baseScale,
            10,
            10
          );
          const highlight = new THREE.Mesh(
            highlightGeom,
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(
            0.018 * baseScale,
            0.028 * baseScale,
            0.068 * baseScale
          );
          group.add(highlight);

          // Secondary highlight (smaller, at 4 o'clock for depth)
          const highlight2Geom = new THREE.SphereGeometry(
            0.012 * baseScale,
            8,
            8
          );
          const highlight2 = new THREE.Mesh(
            highlight2Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(
            -0.012 * baseScale,
            -0.018 * baseScale,
            0.066 * baseScale
          );
          group.add(highlight2);

          // Tertiary micro-highlight (adds sparkle)
          const highlight3Geom = new THREE.SphereGeometry(
            0.006 * baseScale,
            6,
            6
          );
          const highlight3 = new THREE.Mesh(
            highlight3Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight3.position.set(
            0.03 * baseScale,
            0.008 * baseScale,
            0.067 * baseScale
          );
          group.add(highlight3);

          // Subtle lower eye shadow (adds dimension)
          const lowerShadow = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.065 * baseScale,
              0.006 * baseScale,
              8,
              16,
              Math.PI * 0.6
            ),
            new THREE.MeshBasicMaterial({
              color: 0x1a1015,
              transparent: true,
              opacity: 0.08,
            })
          );
          lowerShadow.rotation.x = Math.PI / 2;
          lowerShadow.rotation.z = Math.PI * 0.7;
          lowerShadow.position.set(0, -0.02 * baseScale, 0.03 * baseScale);
          group.add(lowerShadow);

          return group;
        }

        // Owl-style concentric eye - PREMIUM ENHANCED
        function createOwlEye(scale = 1) {
          const group = new THREE.Group();

          // Deep ambient shadow around eye socket
          const eyeSocket = new THREE.Mesh(
            new THREE.CircleGeometry(0.14 * scale, 32),
            new THREE.MeshBasicMaterial({
              color: 0x2a1a10,
              transparent: true,
              opacity: 0.2,
            })
          );
          eyeSocket.position.z = -0.005;
          group.add(eyeSocket);

          // Outer ring (facial disc) - thicker and more prominent
          const outerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.125 * scale, 0.025 * scale, 12, 32),
            getMaterial(0xdeb887, { roughness: 0.4 })
          );
          group.add(outerRing);

          // Secondary inner ring for depth
          const innerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.105 * scale, 0.01 * scale, 8, 24),
            getMaterial(0xc9a87a, { roughness: 0.5 })
          );
          innerRing.position.z = 0.003;
          group.add(innerRing);

          // Orange iris base - more vibrant
          const eyeBg = new THREE.Mesh(
            new THREE.CircleGeometry(0.1 * scale, 32),
            new THREE.MeshPhysicalMaterial({
              color: 0xff9500,
              roughness: 0.1,
              clearcoat: 0.7,
              sheen: 0.3,
              sheenColor: new THREE.Color(0xffcc00),
            })
          );
          eyeBg.position.z = 0.01;
          group.add(eyeBg);

          // Iris ring pattern (owls have radiating patterns)
          const irisPattern = new THREE.Mesh(
            new THREE.RingGeometry(0.055 * scale, 0.095 * scale, 24, 3),
            new THREE.MeshPhysicalMaterial({
              color: 0xcc6600,
              roughness: 0.2,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.6,
            })
          );
          irisPattern.position.z = 0.012;
          group.add(irisPattern);

          // Inner iris glow ring
          const innerGlow = new THREE.Mesh(
            new THREE.RingGeometry(0.05 * scale, 0.065 * scale, 24),
            new THREE.MeshPhysicalMaterial({
              color: 0xffaa00,
              roughness: 0.05,
              emissive: 0x331100,
              emissiveIntensity: 0.1,
              side: THREE.DoubleSide,
            })
          );
          innerGlow.position.z = 0.015;
          group.add(innerGlow);

          // Large deep pupil
          const pupil = new THREE.Mesh(
            new THREE.CircleGeometry(0.05 * scale, 24),
            SPECIAL_MATERIALS.eyeBlack
          );
          pupil.position.z = 0.018;
          group.add(pupil);

          // Primary highlight - larger for owl
          const highlight = new THREE.Mesh(
            new THREE.CircleGeometry(0.025 * scale, 12),
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(0.028 * scale, 0.028 * scale, 0.025);
          group.add(highlight);

          // Secondary highlight
          const highlight2 = new THREE.Mesh(
            new THREE.CircleGeometry(0.012 * scale, 8),
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(-0.015 * scale, -0.02 * scale, 0.024);
          group.add(highlight2);

          // Micro sparkle
          const sparkle = new THREE.Mesh(
            new THREE.CircleGeometry(0.006 * scale, 6),
            SPECIAL_MATERIALS.specular
          );
          sparkle.position.set(0.04 * scale, 0.01 * scale, 0.024);
          group.add(sparkle);

          return group;
        }

        // Paw with pad indentations
        function createPaw(radius, material, padMaterial) {
          const group = new THREE.Group();

          // Main paw
          const paw = new THREE.Mesh(
            new THREE.SphereGeometry(radius, 16, 16),
            material
          );
          paw.scale.set(1, 0.6, 1.2);
          group.add(paw);

          // Main pad
          const mainPad = new THREE.Mesh(
            new THREE.SphereGeometry(radius * 0.5, 12, 12),
            padMaterial
          );
          mainPad.position.set(0, -radius * 0.2, radius * 0.3);
          mainPad.scale.set(1.2, 0.5, 1);
          group.add(mainPad);

          // Toe pads
          for (let i = -1; i <= 1; i++) {
            const toePad = new THREE.Mesh(
              new THREE.SphereGeometry(radius * 0.2, 8, 8),
              padMaterial
            );
            toePad.position.set(i * radius * 0.4, -radius * 0.2, radius * 0.7);
            group.add(toePad);
          }

          return group;
        }

        // ==========================================
        // PARTICLE SYSTEM FOR TRANSITIONS
        // ==========================================
        class ParticleBurst {
          constructor(scene) {
            this.scene = scene;
            this.particles = [];
            this.geometry = new THREE.SphereGeometry(0.03, 8, 8);
            this.materials = [
              new THREE.MeshBasicMaterial({ color: 0xffb7c5 }),
              new THREE.MeshBasicMaterial({ color: 0xadd8e6 }),
              new THREE.MeshBasicMaterial({ color: 0xfffacd }),
              new THREE.MeshBasicMaterial({ color: 0x98fb98 }),
              new THREE.MeshBasicMaterial({ color: 0xdda0dd }),
            ];
          }

          burst(position, count = 20) {
            for (let i = 0; i < count; i++) {
              const material =
                this.materials[
                  Math.floor(Math.random() * this.materials.length)
                ];
              const particle = new THREE.Mesh(this.geometry, material);
              particle.position.copy(position);
              particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                Math.random() * 0.1 + 0.05,
                (Math.random() - 0.5) * 0.15
              );
              particle.userData.life = 1.0;
              this.scene.add(particle);
              this.particles.push(particle);
            }
          }

          update(delta) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const p = this.particles[i];
              p.position.add(p.userData.velocity);
              p.userData.velocity.y -= 0.005; // gravity
              p.userData.life -= delta * 2;
              p.scale.setScalar(p.userData.life);

              if (p.userData.life <= 0) {
                this.scene.remove(p);
                this.particles.splice(i, 1);
              }
            }
          }
        }

        const particleBurst = new ParticleBurst(scene);

        // ==========================================
        // ANIMAL MODEL FACTORY
        // ==========================================
        function createAnimalModel(type, colorOverride = null) {
          const config = ANIMAL_CONFIG[type];
          const animal = new THREE.Group();
          animal.userData.type = type;
          animal.userData.animationData = {};

          // Apply color override
          let primaryColor = config.primaryColor;
          let secondaryColor = config.secondaryColor;
          if (colorOverride && COLOR_PALETTES[colorOverride]) {
            primaryColor = COLOR_PALETTES[colorOverride].primary;
            secondaryColor = COLOR_PALETTES[colorOverride].secondary;
          }

          const primaryMat = getMaterial(primaryColor);
          const secondaryMat = getMaterial(secondaryColor);
          const accentMat = getMaterial(config.accentColor);

          // ============ BUNNY - ENHANCED ============
          if (type === "bunny") {
            // Pear-shaped body (larger hindquarters) - slightly rounder
            const bodyGeom = new THREE.SphereGeometry(0.42, 32, 32);
            const body = new THREE.Mesh(bodyGeom, primaryMat);
            body.scale.set(0.88, 1.12, 1.02);
            body.position.y = 0.45;
            body.castShadow = true;
            animal.add(body);

            // Hindquarters bump - more pronounced
            const hindquarters = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 24, 24),
              primaryMat
            );
            hindquarters.position.set(0, 0.28, -0.18);
            hindquarters.castShadow = true;
            animal.add(hindquarters);

            // Smooth body transition
            const bodyTransition = new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 16, 16),
              primaryMat
            );
            bodyTransition.position.set(0, 0.75, 0);
            animal.add(bodyTransition);

            // Head (slightly oval, wider at cheeks)
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 1.08;
            head.castShadow = true;
            animal.add(head);

            // Enhanced cheeks with subtle blush
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 20, 20),
                primaryMat
              );
              cheek.position.set(side * 0.3, 0.94, 0.16);
              animal.add(cheek);

              // Blush spots
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.35,
                  roughness: 0.6,
                })
              );
              blush.position.set(side * 0.34, 0.92, 0.28);
              blush.rotation.y = side * 0.3;
              animal.add(blush);
            });

            // Subtle eyebrow ridges
            [-1, 1].forEach((side) => {
              const brow = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.02, 0.08, 6, 8),
                primaryMat
              );
              brow.position.set(side * 0.16, 1.2, 0.32);
              brow.rotation.z = side * -0.3;
              brow.rotation.x = 0.2;
              animal.add(brow);
            });

            // Enhanced paddle-shaped ears (thicker, more teardrop)
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              const earOuter = new THREE.Group();

              // Main ear body - thicker elliptical paddle
              const earGeom = new THREE.CapsuleGeometry(0.12, 0.75, 12, 20);
              const ear = new THREE.Mesh(earGeom, primaryMat);
              ear.scale.set(1.15, 1, 0.45);
              earOuter.add(ear);

              // Ear edge rim for thickness
              const earRim = new THREE.Mesh(
                new THREE.TorusGeometry(0.085, 0.025, 8, 24, Math.PI * 1.6),
                primaryMat
              );
              earRim.position.set(0, 0.1, 0);
              earRim.rotation.x = Math.PI / 2;
              earRim.rotation.z = Math.PI * 0.7;
              earOuter.add(earRim);

              // Inner ear - softer pink
              const innerGeom = new THREE.CapsuleGeometry(0.07, 0.58, 10, 16);
              const inner = new THREE.Mesh(innerGeom, secondaryMat);
              inner.scale.set(1.1, 1, 0.32);
              inner.position.z = 0.025;
              earOuter.add(inner);

              // Ear tip (more rounded)
              const tip = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 16, 16),
                primaryMat
              );
              tip.scale.set(1.15, 0.85, 0.45);
              tip.position.y = 0.42;
              earOuter.add(tip);

              earOuter.position.set(side * 0.2, 1.55, -0.02);
              earOuter.rotation.z = side * -0.18;
              earOuter.rotation.x = -0.08;
              earGroup.add(earOuter);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Eyes with custom iris color
            [-1, 1].forEach((side) => {
              const eye = createEye(0.9, false, { irisColor: 0x4a3020 });
              eye.position.set(side * 0.19, 1.12, 0.34);
              animal.add(eye);
            });

            // Enhanced Y-shaped nose with nostrils
            const nose = new THREE.Group();
            const noseTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 20, 20),
              getMaterial(0xffb6c1)
            );
            noseTop.scale.set(1.35, 0.72, 1);
            nose.add(noseTop);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.014, 10, 10),
                getMaterial(0xc87090)
              );
              nostril.position.set(side * 0.02, -0.006, 0.025);
              nose.add(nostril);
            });

            // Nose line going down (philtrum)
            const noseLine = new THREE.Mesh(
              new THREE.CylinderGeometry(0.009, 0.014, 0.055, 10),
              getMaterial(0xffb6c1)
            );
            noseLine.position.y = -0.038;
            nose.add(noseLine);

            nose.position.set(0, 1.02, 0.4);
            animal.userData.animationData.nose = nose;
            animal.add(nose);

            // Whiskers (3 per side) - slightly curved
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.001, 0.25, 6),
                  getMaterial(0xffffff)
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.28;
                whisker.rotation.x = (i - 1) * 0.12;
                whisker.position.set(side * 0.2, 1.0 + (i - 1) * 0.028, 0.34);
                animal.add(whisker);
              }
            });

            // Enhanced fluffy tail with color variation
            const tailGroup = new THREE.Group();
            // Core
            const tailCore = new THREE.Mesh(
              new THREE.SphereGeometry(0.11, 20, 20),
              primaryMat
            );
            tailGroup.add(tailCore);

            // Fluffy outer layers with slight color variation
            for (let i = 0; i < 12; i++) {
              const puffSize = 0.055 + Math.random() * 0.025;
              const puff = new THREE.Mesh(
                new THREE.SphereGeometry(puffSize, 12, 12),
                i % 3 === 0 ? secondaryMat : primaryMat
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.065 + Math.random() * 0.02;
              puff.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle * 0.6) * 0.05 + (Math.random() - 0.5) * 0.02,
                Math.sin(angle) * radius
              );
              tailGroup.add(puff);
            }
            tailGroup.position.set(0, 0.5, -0.4);
            animal.add(tailGroup);

            // Legs - back legs larger than front
            // Front legs with paw detail
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.075, 0.16, 10, 14),
                primaryMat
              );
              frontLeg.position.set(side * 0.22, 0.16, 0.22);
              animal.add(frontLeg);

              // Front paw
              const frontPaw = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 12, 12),
                primaryMat
              );
              frontPaw.scale.set(1, 0.6, 1.3);
              frontPaw.position.set(side * 0.22, 0.04, 0.28);
              animal.add(frontPaw);
            });

            // Back legs (much larger) with better definition
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 16, 16),
                primaryMat
              );
              thigh.scale.set(0.9, 1.1, 1);
              thigh.position.set(side * 0.24, 0.25, -0.12);
              animal.add(thigh);

              const backLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.22, 10, 14),
                primaryMat
              );
              backLeg.position.set(side * 0.24, 0.14, -0.08);
              backLeg.rotation.x = 0.35;
              animal.add(backLeg);

              // Back foot - elongated bunny foot
              const backFoot = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.085, 0.2, 10, 14),
                primaryMat
              );
              backFoot.rotation.x = Math.PI / 2;
              backFoot.position.set(side * 0.24, 0.05, 0.08);
              animal.add(backFoot);

              // Foot pad hint
              const footPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 10, 10),
                secondaryMat
              );
              footPad.scale.set(1.2, 0.5, 1.5);
              footPad.position.set(side * 0.24, 0.02, 0.12);
              animal.add(footPad);
            });
          }

          // ============ BEAR - ENHANCED ============
          else if (type === "bear") {
            // Barrel-shaped torso (1.5x wider than tall)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.58, 32, 32),
              primaryMat
            );
            body.scale.set(1.32, 1.0, 1.15);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Enhanced shoulder hump - more prominent (30% larger)
            const hump = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 20, 20),
              primaryMat
            );
            hump.scale.set(1.2, 0.9, 1);
            hump.position.set(0, 0.92, -0.12);
            animal.add(hump);

            // Secondary hump for smooth transition
            const hump2 = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 16, 16),
              primaryMat
            );
            hump2.position.set(0, 1.02, -0.05);
            animal.add(hump2);

            // Belly patch - rounder
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.0, 1.15, 0.52);
            belly.position.set(0, 0.48, 0.28);
            animal.add(belly);

            // Wide, round head with pronounced forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 1.22;
            head.castShadow = true;
            animal.add(head);

            // Cheek puffs for rounder face
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                primaryMat
              );
              cheek.position.set(side * 0.32, 1.12, 0.22);
              animal.add(cheek);
            });

            // Forehead bulge - more subtle
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 18, 18),
              primaryMat
            );
            forehead.position.set(0, 1.48, 0.12);
            animal.add(forehead);

            // Smooth blended muzzle (no box geometry)
            const muzzleBase = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            muzzleBase.scale.set(1.1, 0.85, 0.9);
            muzzleBase.position.set(0, 1.1, 0.42);
            animal.add(muzzleBase);

            const muzzleFront = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 18, 18),
              secondaryMat
            );
            muzzleFront.scale.set(1.0, 0.78, 0.85);
            muzzleFront.position.set(0, 1.1, 0.52);
            animal.add(muzzleFront);

            // Muzzle bridge for smooth transition
            const muzzleBridge = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.08, 0.12, 10, 12),
              secondaryMat
            );
            muzzleBridge.rotation.x = Math.PI / 2;
            muzzleBridge.scale.set(1.2, 1, 0.8);
            muzzleBridge.position.set(0, 1.12, 0.38);
            animal.add(muzzleBridge);

            // Enhanced nose with nostrils
            const nose = new THREE.Group();
            const noseMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.09, 14, 14),
              accentMat
            );
            noseMain.scale.set(1.35, 0.88, 1.0);
            nose.add(noseMain);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.04, -0.01, 0.04);
              nose.add(nostril);
            });
            nose.position.set(0, 1.16, 0.58);
            animal.add(nose);

            // Enhanced ears at 10 and 2 o'clock with depth
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();
              const angle = (side * Math.PI) / 4.2;
              const earRadius = 0.48;

              // Main ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 18, 18),
                primaryMat
              );
              earGroup.add(ear);

              // Ear inner recess (darker)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                secondaryMat
              );
              innerEar.position.z = 0.08;
              earGroup.add(innerEar);

              // Ear cavity shadow
              const earCavity = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 12),
                new THREE.MeshBasicMaterial({
                  color: 0x3a2a20,
                  transparent: true,
                  opacity: 0.3,
                })
              );
              earCavity.position.z = 0.085;
              earGroup.add(earCavity);
              // FIXED: Simple ear position at 10 and 2 o'clock
              earGroup.position.set(side * 0.32, 1.52, 0.05);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Eyes - slightly lower and forward
            [-1, 1].forEach((side) => {
              const eye = createEye(0.7, false, { irisColor: 0x2a1810 });
              eye.position.set(side * 0.22, 1.26, 0.4);
              animal.add(eye);
            });

            // Thick plantigrade legs with enhanced paw pads and curved claws
            const legPositions = [
              { x: -0.38, z: 0.22, front: true },
              { x: 0.38, z: 0.22, front: true },
              { x: -0.32, z: -0.28, front: false },
              { x: 0.32, z: -0.28, front: false },
            ];

            legPositions.forEach((pos) => {
              // Thicker legs with slight curve
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.4, 18),
                primaryMat
              );
              leg.position.set(pos.x, 0.2, pos.z);
              animal.add(leg);

              // Knee/joint bulge
              const knee = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 12, 12),
                primaryMat
              );
              knee.position.set(pos.x, 0.32, pos.z);
              animal.add(knee);

              // Enhanced paw
              const paw = createPaw(0.15, primaryMat, secondaryMat);
              paw.position.set(pos.x, 0.02, pos.z + 0.06);
              animal.add(paw);

              // 5 Curved claws per paw
              for (let c = -2; c <= 2; c++) {
                const clawGroup = new THREE.Group();
                const claw = new THREE.Mesh(
                  new THREE.ConeGeometry(0.02, 0.07, 10),
                  accentMat
                );
                claw.position.y = 0.035;
                clawGroup.add(claw);

                // Claw curve
                clawGroup.rotation.x = -Math.PI / 2 - 0.35;
                clawGroup.rotation.z = c * 0.08;
                clawGroup.position.set(pos.x + c * 0.038, 0.01, pos.z + 0.2);
                animal.add(clawGroup);
              }
            });

            // Head for animation
            animal.userData.animationData.head = head;
          }

          // ============ PENGUIN - CARTOON REDESIGN ============
          else if (type === "penguin") {
            // Rounded egg-shaped body (black outer shell)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.52, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.95);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // LARGE WHITE CIRCULAR BELLY (Center of body - like reference!)
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.44, 32, 32),
              secondaryMat
            );
            // distinct circular shape centered on body
            belly.scale.set(0.95, 1.0, 0.5);
            belly.position.set(0, 0.55, 0.22);
            animal.add(belly);

            // White chest connector (smooth blend to face)
            const chestTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 24, 24),
              secondaryMat
            );
            chestTop.scale.set(0.9, 0.7, 0.4);
            chestTop.position.set(0, 0.88, 0.24);
            animal.add(chestTop);

            // Round head attached to body (black)
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            head.position.y = 1.1;
            animal.add(head);

            // HEART-SHAPED WHITE FACE PATCH (key feature from reference!)
            // Create heart shape using two overlapping circles and a triangle bottom
            const faceGroup = new THREE.Group();

            // Left circle of heart
            const heartLeft = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartLeft.scale.set(1, 1, 0.4);
            heartLeft.position.set(-0.1, 0.08, 0);
            faceGroup.add(heartLeft);

            // Right circle of heart
            const heartRight = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartRight.scale.set(1, 1, 0.4);
            heartRight.position.set(0.1, 0.08, 0);
            faceGroup.add(heartRight);

            // Center fill for heart
            const heartCenter = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              secondaryMat
            );
            heartCenter.scale.set(1.4, 1, 0.4);
            heartCenter.position.set(0, 0.02, 0);
            faceGroup.add(heartCenter);

            // Bottom point of heart (chin area)
            const heartBottom = new THREE.Mesh(
              new THREE.ConeGeometry(0.16, 0.22, 16),
              secondaryMat
            );
            heartBottom.scale.set(1, 1, 0.4);
            heartBottom.rotation.x = Math.PI;
            heartBottom.position.set(0, -0.1, 0);
            faceGroup.add(heartBottom);

            faceGroup.position.set(0, 1.08, 0.28);
            animal.add(faceGroup);

            // LARGE CARTOON EYES (like reference image)
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Large black pupil (cartoon style - fills most of eye)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.075, 18, 18),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.04;
              eyeGroup.add(pupil);

              // Large white highlight (cartoon shine)
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.035, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025 * side, 0.03, 0.08);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.02 * side, -0.02, 0.08);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.12, 1.15, 0.32);
              animal.add(eyeGroup);
            });

            // PINK BLUSH MARKS (like reference image!)
            [-1, 1].forEach((side) => {
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.05, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.6,
                  roughness: 0.8,
                })
              );
              blush.position.set(side * 0.18, 1.02, 0.35);
              animal.add(blush);
            });

            // CUTE ROUNDED ORANGE BEAK (like reference)
            const beakGroup = new THREE.Group();

            // Main beak body - rounded capsule shape
            const beakMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0xf5a623)
            );
            beakMain.scale.set(1.3, 0.8, 1.0);
            beakGroup.add(beakMain);

            // Slight bump on top for cute look
            const beakTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xf5a623)
            );
            beakTop.position.set(0, 0.02, -0.02);
            beakGroup.add(beakTop);

            beakGroup.position.set(0, 0.98, 0.4);
            animal.add(beakGroup);

            // Small flipper wings (like reference - held out slightly)
            [-1, 1].forEach((side) => {
              const flipperGroup = new THREE.Group();

              // Main flipper shape
              const flipper = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.28, 12, 18),
                primaryMat
              );
              flipper.scale.set(1.1, 1, 0.4);
              flipperGroup.add(flipper);

              // Flipper tip
              const flipperTip = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 12, 12),
                primaryMat
              );
              flipperTip.scale.set(1, 0.8, 0.4);
              flipperTip.position.y = -0.16;
              flipperGroup.add(flipperTip);

              flipperGroup.position.set(side * 0.48, 0.55, 0.05);
              flipperGroup.rotation.z = side * 0.45;
              animal.add(flipperGroup);
            });

            // Cute orange webbed feet
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Main foot oval
              const footBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                getMaterial(0xf5a623)
              );
              footBase.scale.set(1.3, 0.3, 1.6);
              footGroup.add(footBase);

              // Three rounded toes
              for (let i = -1; i <= 1; i++) {
                const toe = new THREE.Mesh(
                  new THREE.SphereGeometry(0.035, 10, 10),
                  getMaterial(0xf5a623)
                );
                toe.scale.set(1, 0.5, 1.5);
                toe.position.set(i * 0.05, 0, 0.1);
                footGroup.add(toe);
              }

              footGroup.position.set(side * 0.18, 0.02, 0.12);
              animal.add(footGroup);
            });

            // Animation reference
            animal.userData.animationData.body = animal;
          }

          // ============ FOX - ENHANCED ============
          else if (type === "fox") {
            // Slender, agile body
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.3, 0.52, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.88);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Enhanced chest fluff - more prominent
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.92, 1.15, 0.65);
            chest.position.set(0, 0.58, 0.2);
            animal.add(chest);

            // Additional chest fluff layers
            const chestFluff = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 14, 14),
              secondaryMat
            );
            chestFluff.position.set(0, 0.72, 0.18);
            animal.add(chestFluff);

            // Diamond/triangular head - slightly larger
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.34, 32, 32),
              primaryMat
            );
            head.scale.set(1.02, 0.92, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // White cheek patches (fox marking)
            [-1, 1].forEach((side) => {
              const cheekPatch = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              cheekPatch.scale.set(1.2, 0.9, 0.5);
              cheekPatch.position.set(side * 0.18, 0.95, 0.22);
              animal.add(cheekPatch);
            });

            // Enhanced long pointed snout with gradient
            const snoutBase = new THREE.Mesh(
              new THREE.ConeGeometry(0.14, 0.25, 18),
              primaryMat
            );
            snoutBase.rotation.x = Math.PI / 2;
            snoutBase.position.set(0, 0.94, 0.32);
            animal.add(snoutBase);

            const snoutTip = new THREE.Mesh(
              new THREE.ConeGeometry(0.1, 0.2, 16),
              secondaryMat
            );
            snoutTip.rotation.x = Math.PI / 2;
            snoutTip.position.set(0, 0.92, 0.45);
            animal.add(snoutTip);

            // Nose with nostrils
            const noseGroup = new THREE.Group();
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.045, 14, 14),
              accentMat
            );
            noseGroup.add(nose);

            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.02, -0.01, 0.02);
              noseGroup.add(nostril);
            });
            noseGroup.position.set(0, 0.92, 0.58);
            animal.add(noseGroup);

            // Facial tear lines (dark markings from eye to snout)
            [-1, 1].forEach((side) => {
              const tearLine = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.012, 0.15, 6, 10),
                getMaterial(0x2a1810)
              );
              tearLine.rotation.x = 0.8;
              tearLine.rotation.z = side * 0.25;
              tearLine.position.set(side * 0.1, 0.98, 0.32);
              animal.add(tearLine);
            });

            // Enhanced triangular ears with fur tufts
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.13, 0.42, 5),
                primaryMat
              );
              ear.position.y = 0.16;
              earGroup.add(ear);

              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.32, 5),
                secondaryMat
              );
              innerEar.position.set(0, 0.13, 0.035);
              earGroup.add(innerEar);

              // Black ear tips
              const earTip = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, 0.1, 5),
                accentMat
              );
              earTip.position.y = 0.35;
              earGroup.add(earTip);

              earGroup.position.set(side * 0.2, 1.28, -0.02);
              earGroup.rotation.z = side * -0.15;
              animal.add(earGroup);
            });

            // Slit pupil eyes for fox
            [-1, 1].forEach((side) => {
              const eye = createEye(0.82, true, { irisColor: 0xc4a040 });
              eye.position.set(side * 0.15, 1.06, 0.3);
              animal.add(eye);
            });

            // Enhanced bushy tail (12 segments + fur overlays)
            const tailGroup = new THREE.Group();

            const tailSegments = 12;
            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseSize = 0.15 - t * 0.07;
              const isWhiteTip = t >= 0.72;

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseSize, 14, 12),
                isWhiteTip ? secondaryMat : primaryMat
              );

              const curve = Math.sin(t * Math.PI * 0.6) * 0.38;
              segment.position.y = i * 0.085;
              segment.position.z = -0.12 - curve;
              segment.position.x = Math.sin(t * Math.PI * 0.3) * 0.055;
              tailGroup.add(segment);

              if (i % 2 === 0 && i < tailSegments - 2) {
                for (let f = 0; f < 5; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(
                      baseSize * 0.55 + Math.random() * 0.02,
                      8,
                      8
                    ),
                    isWhiteTip ? secondaryMat : primaryMat
                  );
                  const angle = (f / 5) * Math.PI * 2 + Math.random() * 0.3;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseSize * 0.72,
                    segment.position.y + (Math.random() - 0.5) * 0.035,
                    segment.position.z + Math.sin(angle) * baseSize * 0.52
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.4, -0.2);
            tailGroup.rotation.x = -0.28;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Thin black "sock" legs with better definition
            const legPositions = [
              { x: -0.16, z: 0.16 },
              { x: 0.16, z: 0.16 },
              { x: -0.13, z: -0.2 },
              { x: 0.13, z: -0.2 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.32, 10, 14),
                accentMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              // Dainty paw with toe details
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                accentMat
              );
              paw.scale.set(1, 0.58, 1.35);
              paw.position.set(pos.x, 0.03, pos.z + 0.04);
              animal.add(paw);
            });
          }

          // ============ ELEPHANT ============
          else if (type === "elephant") {
            // Massive barrel body with saggy belly
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.6, 32, 32),
              primaryMat
            );
            body.scale.set(1.1, 0.9, 1.3);
            body.position.y = 0.65;
            body.castShadow = true;
            animal.add(body);

            // Saggy belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              primaryMat
            );
            belly.position.set(0, 0.4, 0);
            animal.add(belly);

            // Domed head with forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.45, 32, 32),
              primaryMat
            );
            head.scale.set(1.0, 1.1, 1.0);
            head.position.set(0, 1.25, 0.25);
            animal.add(head);

            // Domed forehead
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 16, 16),
              primaryMat
            );
            forehead.position.set(0, 1.55, 0.2);
            animal.add(forehead);

            // LARGE fan-shaped ears (60% of body height) - FIXED visibility
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              // Main ear shape - using flattened sphere for 3D visibility
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.45,
                  24,
                  16,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.6
                ),
                primaryMat
              );
              ear.scale.set(1, 1.2, 0.15); // Wide, tall, thin
              ear.rotation.y = side * 0.2;
              earGroup.add(ear);

              // Inner ear (pinkish)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.35,
                  20,
                  12,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.5
                ),
                getMaterial(0xd4a5a5) // Pink inner ear
              );
              innerEar.scale.set(0.9, 1, 0.1);
              innerEar.position.set(side * -0.02, -0.05, 0.05);
              innerEar.rotation.y = side * 0.2;
              earGroup.add(innerEar);

              earGroup.position.set(side * 0.55, 1.25, 0.1);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Smooth trunk using TubeGeometry with natural S-curve
            const trunkGroup = new THREE.Group();

            // Define trunk path as smooth S-curve
            const trunkPath = new THREE.CatmullRomCurve3([
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(0, -0.15, 0.08),
              new THREE.Vector3(0, -0.35, 0.18),
              new THREE.Vector3(0, -0.55, 0.25),
              new THREE.Vector3(0, -0.75, 0.2),
              new THREE.Vector3(0, -0.9, 0.1),
            ]);

            // Create tapered tube geometry
            const radiusSegments = 8;
            const tubularSegments = 24;
            const trunkRadii = [];
            for (let i = 0; i <= tubularSegments; i++) {
              const t = i / tubularSegments;
              trunkRadii.push(0.12 - t * 0.08); // Taper from 0.12 to 0.04
            }

            // Note: THREE.TubeGeometry doesn't support variable radius,
            // so we use multiple scaled torus/cylinder sections for smooth look
            const trunkSegments = 16;
            for (let i = 0; i < trunkSegments; i++) {
              const t = i / (trunkSegments - 1);
              const radius = 0.11 - t * 0.07;
              const point = trunkPath.getPointAt(t);

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 16, 12),
                primaryMat
              );
              segment.scale.set(1, 0.8, 1); // Slightly flatten for organic look
              segment.position.copy(point);
              trunkGroup.add(segment);
            }

            // Trunk tip with nostril openings
            const tipPoint = trunkPath.getPointAt(1);
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.TorusGeometry(0.02, 0.008, 8, 12),
                getMaterial(0x5a6a7a) // Darker for depth
              );
              nostril.position.set(
                side * 0.025,
                tipPoint.y - 0.02,
                tipPoint.z + 0.03
              );
              nostril.rotation.y = Math.PI / 2;
              trunkGroup.add(nostril);
            });

            trunkGroup.position.set(0, 1.15, 0.55);
            animal.userData.animationData.trunk = trunkGroup;
            animal.add(trunkGroup);

            // Curved tusks (outward and upward)
            [-1, 1].forEach((side) => {
              const tuskGroup = new THREE.Group();

              for (let i = 0; i < 5; i++) {
                const t = i / 4;
                const tuskSeg = new THREE.Mesh(
                  new THREE.SphereGeometry(0.04 - t * 0.02, 8, 8),
                  secondaryMat
                );
                tuskSeg.position.x = side * t * 0.1;
                tuskSeg.position.y = -t * 0.1 + t * t * 0.15; // Curve up
                tuskSeg.position.z = t * 0.08;
                tuskGroup.add(tuskSeg);
              }

              tuskGroup.position.set(side * 0.15, 1.0, 0.6);
              animal.add(tuskGroup);
            });

            // Enhanced visible eyes with eyelid ridges
            [-1, 1].forEach((side) => {
              // Eyelid ridge/brow for definition
              const browRidge = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.1, 8, 12),
                primaryMat
              );
              browRidge.position.set(side * 0.28, 1.42, 0.48);
              browRidge.rotation.z = side * 0.3;
              animal.add(browRidge);

              // Eye socket depression
              const eyeSocket = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 12, 12),
                getMaterial(0x5a6a7a)
              );
              eyeSocket.scale.set(1.2, 1, 0.6);
              eyeSocket.position.set(side * 0.28, 1.35, 0.48);
              animal.add(eyeSocket);

              // Larger, more visible eye
              const eye = createEye(0.75, false, { irisColor: 0x3a2a20 });
              eye.position.set(side * 0.28, 1.35, 0.52);
              animal.add(eye);
            });

            // Column-like legs with toenails
            const legPositions = [
              { x: -0.35, z: 0.35 },
              { x: 0.35, z: 0.35 },
              { x: -0.3, z: -0.35 },
              { x: 0.3, z: -0.35 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.16, 0.5, 16),
                primaryMat
              );
              leg.position.set(pos.x, 0.25, pos.z);
              animal.add(leg);

              // Foot
              const foot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.16, 0.18, 0.08, 16),
                primaryMat
              );
              foot.position.set(pos.x, 0.04, pos.z);
              animal.add(foot);

              // Toenails
              for (let i = -1; i <= 1; i++) {
                const nail = new THREE.Mesh(
                  new THREE.SphereGeometry(0.03, 8, 8),
                  secondaryMat
                );
                nail.position.set(pos.x + i * 0.06, 0.02, pos.z + 0.15);
                animal.add(nail);
              }
            });

            // Thin tail with tuft
            const tailGroup = new THREE.Group();

            const tailBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.03, 0.4, 8),
              primaryMat
            );
            tailBase.position.y = -0.15;
            tailGroup.add(tailBase);

            const tuft = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 12, 12),
              primaryMat
            );
            tuft.scale.set(0.8, 1.5, 0.8);
            tuft.position.y = -0.4;
            tailGroup.add(tuft);

            tailGroup.position.set(0, 0.5, -0.65);
            tailGroup.rotation.x = 0.3;
            animal.add(tailGroup);
          }

          // ============ CAT - ENHANCED ============
          else if (type === "cat") {
            // Sleek body - slightly more elegant
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.32, 0.48, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.92);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Fluffy chest
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.95, 1.1, 0.65);
            chest.position.set(0, 0.58, 0.17);
            animal.add(chest);

            // Head with better cheekbone structure
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.08, 1.0, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // Cheekbones for cat-like face
            [-1, 1].forEach((side) => {
              const cheekbone = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                primaryMat
              );
              cheekbone.scale.set(1.2, 0.8, 0.6);
              cheekbone.position.set(side * 0.2, 0.95, 0.18);
              animal.add(cheekbone);
            });

            // Enhanced muzzle with whisker pads
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.13, 18, 18),
              secondaryMat
            );
            muzzle.scale.set(1, 0.72, 0.82);
            muzzle.position.set(0, 0.93, 0.27);
            animal.add(muzzle);

            // Whisker pads (puffy areas on either side of nose)
            [-1, 1].forEach((side) => {
              const whiskerPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                secondaryMat
              );
              whiskerPad.scale.set(1.2, 0.9, 1);
              whiskerPad.position.set(side * 0.07, 0.91, 0.32);
              animal.add(whiskerPad);
            });

            // Pink nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 14, 14),
              getMaterial(0xffb6c1)
            );
            nose.scale.set(1.1, 0.85, 1);
            nose.position.set(0, 0.96, 0.35);
            animal.add(nose);

            // Enhanced whiskers (curved)
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.002, 0.22, 6),
                  secondaryMat
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.22;
                whisker.rotation.x = (i - 1) * 0.08;
                whisker.position.set(side * 0.18, 0.93 + (i - 1) * 0.032, 0.28);
                animal.add(whisker);
              }
            });

            // Enhanced pointed ears with fur tufts
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              // Main ear
              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.11, 0.24, 5),
                primaryMat
              );
              ear.position.set(side * 0.2, 1.32, 0);
              ear.rotation.z = side * -0.18;
              earGroup.add(ear);

              // Inner pink ear
              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.065, 0.17, 5),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.2, 1.3, 0.035);
              innerEar.rotation.z = side * -0.18;
              earGroup.add(innerEar);

              // Fur tuft at ear tip
              const earTuft = new THREE.Mesh(
                new THREE.ConeGeometry(0.025, 0.06, 4),
                primaryMat
              );
              earTuft.position.set(side * 0.2, 1.45, 0);
              earTuft.rotation.z = side * -0.2;
              earGroup.add(earTuft);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Enhanced slit pupil eyes with green/amber iris
            [-1, 1].forEach((side) => {
              const eye = createEye(0.92, true, { irisColor: 0x7cb342 });
              eye.position.set(side * 0.14, 1.06, 0.27);
              animal.add(eye);
            });

            // Enhanced long curved tail (12 segments + fur)
            const tailGroup = new THREE.Group();
            const tailSegments = 14;

            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseRadius = 0.058 - t * 0.028;
              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseRadius, 12, 10),
                primaryMat
              );
              segment.position.y = i * 0.072;
              segment.position.z = -Math.sin(t * Math.PI) * 0.2;
              segment.position.x = Math.sin(t * Math.PI * 0.55) * 0.13;
              tailGroup.add(segment);

              if (i % 3 === 0 && i < tailSegments - 1) {
                for (let f = 0; f < 3; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(baseRadius * 0.52, 6, 6),
                    primaryMat
                  );
                  const angle = (f / 3) * Math.PI * 2;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseRadius * 0.82,
                    segment.position.y,
                    segment.position.z + Math.sin(angle) * baseRadius * 0.62
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.5, -0.24);
            tailGroup.rotation.x = -0.58;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Enhanced legs with paw pads
            const legPositions = [
              { x: -0.16, z: 0.14 },
              { x: 0.16, z: 0.14 },
              { x: -0.13, z: -0.16 },
              { x: 0.13, z: -0.16 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.27, 10, 14),
                primaryMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              const paw = createPaw(0.065, primaryMat, getMaterial(0xffb6c1));
              paw.position.set(pos.x, 0.02, pos.z + 0.025);
              animal.add(paw);
            });
          }

          // ============ OWL ============
          else if (type === "owl") {
            // Round body (1:1 with head)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.position.y = 0.5;
            body.castShadow = true;
            animal.add(body);

            // Belly feathers (layered discs)
            for (let i = 0; i < 4; i++) {
              const featherRow = new THREE.Mesh(
                new THREE.TorusGeometry(0.25 - i * 0.04, 0.03, 8, 24),
                secondaryMat
              );
              featherRow.rotation.x = Math.PI / 2;
              featherRow.position.set(0, 0.6 - i * 0.1, 0.2);
              animal.add(featherRow);
            }

            // Large round head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 32, 32),
              primaryMat
            );
            head.position.y = 1.05;
            animal.userData.animationData.head = head;
            animal.add(head);

            // Facial disc
            const facialDisc = new THREE.Mesh(
              new THREE.CircleGeometry(0.35, 32),
              secondaryMat
            );
            facialDisc.position.set(0, 1.05, 0.2);
            animal.add(facialDisc);

            // HUGE forward-facing eyes - FIXED position forward
            [-1, 1].forEach((side) => {
              const eye = createOwlEye(1.5);
              eye.position.set(side * 0.14, 1.1, 0.38);
              animal.add(eye);
            });

            // Small hooked beak
            const beak = new THREE.Mesh(
              new THREE.ConeGeometry(0.05, 0.1, 8),
              getMaterial(0x8b7355)
            );
            beak.rotation.x = Math.PI / 2 + 0.3;
            beak.position.set(0, 0.98, 0.32);
            animal.add(beak);

            // Ear tufts - ENLARGED for visibility
            [-1, 1].forEach((side) => {
              const tuft = new THREE.Group();

              // More feathers, larger sizes
              for (let i = 0; i < 4; i++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.04, 0.2 - i * 0.03, 6),
                  primaryMat
                );
                feather.position.set(i * side * 0.025, i * 0.05, 0);
                tuft.add(feather);
              }

              tuft.position.set(side * 0.28, 1.42, -0.02);
              tuft.rotation.z = side * -0.35;
              animal.add(tuft);
            });

            // Enhanced wings with feather details
            [-1, 1].forEach((side) => {
              const wingGroup = new THREE.Group();

              // Main wing body
              const wingBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                primaryMat
              );
              wingBase.scale.set(0.4, 0.8, 0.6);
              wingGroup.add(wingBase);

              // Feather layers (3 rows)
              for (let row = 0; row < 3; row++) {
                const featherRow = new THREE.Mesh(
                  new THREE.TorusGeometry(
                    0.12 - row * 0.025,
                    0.02,
                    6,
                    12,
                    Math.PI * 0.8
                  ),
                  getMaterial(row === 0 ? 0x654321 : config.primaryColor)
                );
                featherRow.rotation.set(0, (side * Math.PI) / 2, Math.PI);
                featherRow.position.set(side * 0.02, -0.1 - row * 0.08, 0.05);
                wingGroup.add(featherRow);
              }

              // Primary flight feathers at tip (5 feathers)
              for (let f = 0; f < 5; f++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.015, 0.12, 4),
                  getMaterial(f === 0 ? 0x4a3728 : config.primaryColor)
                );
                feather.rotation.z = side * (0.3 + f * 0.15);
                feather.rotation.x = 0.2;
                feather.position.set(
                  side * (0.05 + f * 0.02),
                  -0.35 + f * 0.03,
                  0.1 - f * 0.02
                );
                wingGroup.add(feather);
              }

              wingGroup.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wingGroup);
            });

            // Feet/talons
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Three forward talons
              for (let i = -1; i <= 1; i++) {
                const talon = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.025, 0.1, 6, 8),
                  getMaterial(0x8b7355)
                );
                talon.position.set(i * 0.04, 0, 0.05);
                talon.rotation.x = 0.3;
                footGroup.add(talon);
              }

              // One back talon
              const backTalon = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.025, 0.08, 6, 8),
                getMaterial(0x8b7355)
              );
              backTalon.position.set(0, 0, -0.05);
              backTalon.rotation.x = -0.3;
              footGroup.add(backTalon);

              footGroup.position.set(side * 0.12, 0.1, 0.05);
              animal.add(footGroup);
            });
          }

          // ============ PANDA - CARTOON REDESIGN ============
          else if (type === "panda") {
            // Rounded white body (upright standing pose)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.9);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Large round white head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 32, 32),
              primaryMat
            );
            head.position.y = 1.18;
            animal.add(head);

            // BLACK EARS WITH PINK INNER EAR (like reference!)
            [-1, 1].forEach((side) => {
              // Main black ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 18, 18),
                secondaryMat
              );
              ear.position.set(side * 0.32, 1.52, -0.02);
              animal.add(ear);

              // Pink inner ear (key feature from reference!)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 14, 14),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.32, 1.52, 0.06);
              animal.add(innerEar);
            });

            // TILTED BLACK EYE PATCHES (like reference - diagonal orientation)
            [-1, 1].forEach((side) => {
              // Main black eye patch - larger and tilted
              const patch = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 20, 20),
                secondaryMat
              );
              patch.scale.set(1.4, 1.7, 0.4);
              patch.position.set(side * 0.18, 1.2, 0.26);
              // Tilt outer corners upward (panda signature look)
              patch.rotation.z = side * 0.4;
              animal.add(patch);

              // LARGE EXPRESSIVE BLUE EYES (like reference!)
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.15, 0.55);
              eyeGroup.add(sclera);

              // Blue iris (like reference image!)
              const iris = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 18, 18),
                new THREE.MeshPhysicalMaterial({
                  color: 0x4a90d9,
                  roughness: 0.1,
                  clearcoat: 0.5,
                })
              );
              iris.scale.set(1, 1.1, 0.6);
              iris.position.z = 0.03;
              eyeGroup.add(iris);

              // Black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.05;
              eyeGroup.add(pupil);

              // Large white highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.02 * side, 0.02, 0.065);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.015 * side, -0.015, 0.065);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.17, 1.22, 0.36);
              animal.add(eyeGroup);
            });

            // White muzzle area
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              primaryMat
            );
            muzzle.scale.set(1, 0.75, 0.65);
            muzzle.position.set(0, 1.02, 0.35);
            animal.add(muzzle);

            // Small black nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 14, 14),
              secondaryMat
            );
            nose.scale.set(1.3, 0.9, 0.9);
            nose.position.set(0, 1.04, 0.44);
            animal.add(nose);

            // OPEN SMILING MOUTH (like reference with visible tongue!)
            const mouthGroup = new THREE.Group();

            // Mouth opening (dark inside)
            const mouthOpen = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0x2a1a1a)
            );
            mouthOpen.scale.set(1.5, 0.8, 0.5);
            mouthGroup.add(mouthOpen);

            // Pink tongue inside mouth
            const tongue = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xff6b8a)
            );
            tongue.scale.set(1.3, 0.7, 0.8);
            tongue.position.set(0, -0.015, 0.015);
            mouthGroup.add(tongue);

            mouthGroup.position.set(0, 0.93, 0.42);
            animal.add(mouthGroup);

            // BLACK ARMS (like reference - holding down at sides)
            [-1, 1].forEach((side) => {
              const armGroup = new THREE.Group();

              // Upper arm
              const arm = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.28, 10, 14),
                secondaryMat
              );
              armGroup.add(arm);

              // Paw at end
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              paw.position.y = -0.18;
              armGroup.add(paw);

              armGroup.position.set(side * 0.48, 0.48, 0.08);
              armGroup.rotation.z = side * 0.15;
              animal.add(armGroup);
            });

            // BLACK LEGS (like reference - standing upright)
            [-1, 1].forEach((side) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.13, 0.22, 10, 14),
                secondaryMat
              );
              leg.position.set(side * 0.22, 0.18, 0.02);
              animal.add(leg);

              const foot = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 14, 14),
                secondaryMat
              );
              foot.scale.set(1.1, 0.55, 1.35);
              foot.position.set(side * 0.22, 0.06, 0.08);
              animal.add(foot);
            });

            // Small white fluffy tail
            const pandaTail = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            pandaTail.position.set(0, 0.5, -0.42);
            animal.add(pandaTail);

            // Animation references
            animal.userData.animationData.head = head;
            animal.userData.animationData.muzzle = muzzle;
          }

          // ============ DUCK ============
          else if (type === "duck") {
            // Compact oval body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.45;
            body.castShadow = true;
            animal.add(body);

            // Round head with slight crest
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 32, 32),
              primaryMat
            );
            head.position.set(0, 0.95, 0.2);
            animal.userData.animationData.head = head;
            animal.add(head);

            // Crest
            const crest = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            crest.position.set(0, 1.18, 0.1);
            animal.add(crest);

            // Rounded duck bill (replaces angular boxes)
            const beakGroup = new THREE.Group();

            // Upper bill - flattened capsule shape
            const beakUpper = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
              getMaterial(config.accentColor)
            );
            beakUpper.scale.set(1.4, 0.35, 1);
            beakUpper.rotation.x = Math.PI / 2;
            beakUpper.position.set(0, 0.02, 0.12);
            beakGroup.add(beakUpper);

            // Lower bill - slightly smaller
            const beakLower = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.05, 0.12, 8, 12),
              getMaterial(config.accentColor)
            );
            beakLower.scale.set(1.3, 0.3, 0.9);
            beakLower.rotation.x = Math.PI / 2;
            beakLower.position.set(0, -0.02, 0.1);
            beakGroup.add(beakLower);

            // Spatula tip (rounded end)
            const beakTip = new THREE.Mesh(
              new THREE.SphereGeometry(0.055, 12, 12),
              getMaterial(config.accentColor)
            );
            beakTip.scale.set(1.5, 0.4, 1);
            beakTip.position.set(0, 0, 0.2);
            beakGroup.add(beakTip);

            // Nail/tip marking
            const beakNail = new THREE.Mesh(
              new THREE.SphereGeometry(0.02, 8, 8),
              getMaterial(0x1a1a1a)
            );
            beakNail.scale.set(1.2, 0.8, 1);
            beakNail.position.set(0, 0.01, 0.24);
            beakGroup.add(beakNail);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 6, 6),
                getMaterial(0x1a1a1a)
              );
              nostril.position.set(side * 0.03, 0.025, 0.08);
              beakGroup.add(nostril);
            });

            beakGroup.position.set(0, 0.92, 0.32);
            animal.add(beakGroup);

            // FIXED: Larger, more visible eyes on head
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // White sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 16, 16),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Black pupil (large for cartoon look)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.75);
              pupil.position.z = 0.025;
              eyeGroup.add(pupil);

              // White highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.018, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.015 * side, 0.018, 0.05);
              eyeGroup.add(highlight);

              // Position on head - forward facing
              eyeGroup.position.set(side * 0.12, 0.98, 0.42);
              animal.add(eyeGroup);
            });

            // Wings tucked at sides
            [-1, 1].forEach((side) => {
              const wing = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                primaryMat
              );
              wing.scale.set(0.35, 0.6, 0.9);
              wing.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wing);
            });

            // Tail feathers pointing up
            const tailGroup = new THREE.Group();
            for (let i = -1; i <= 1; i++) {
              const feather = new THREE.Mesh(
                new THREE.ConeGeometry(0.04, 0.15, 6),
                primaryMat
              );
              feather.position.set(i * 0.05, 0.05, 0);
              feather.rotation.x = -0.5;
              tailGroup.add(feather);
            }
            tailGroup.position.set(0, 0.45, -0.45);
            animal.add(tailGroup);

            // Enhanced webbed feet with membrane
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Rounded foot base (replaces box)
              const footBase = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.04, 0.06, 8, 8),
                getMaterial(config.accentColor)
              );
              footBase.rotation.x = Math.PI / 2;
              footBase.scale.set(1.4, 0.3, 1);
              footGroup.add(footBase);

              // Three toes with webbing between them
              const toePositions = [-0.045, 0, 0.045];
              toePositions.forEach((xPos, idx) => {
                // Toe
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.018, 0.08, 6, 8),
                  getMaterial(config.accentColor)
                );
                toe.rotation.x = -Math.PI / 2 + 0.1;
                toe.position.set(xPos, 0.005, 0.09);
                footGroup.add(toe);

                // Webbing membrane between toes (triangular shape)
                if (idx < toePositions.length - 1) {
                  const webShape = new THREE.Shape();
                  webShape.moveTo(0, 0);
                  webShape.lineTo(0.04, 0.08);
                  webShape.lineTo(-0.04, 0.08);
                  webShape.lineTo(0, 0);

                  const webGeom = new THREE.ShapeGeometry(webShape);
                  const web = new THREE.Mesh(
                    webGeom,
                    getMaterial(config.accentColor, {
                      transparent: true,
                      opacity: 0.85,
                      side: THREE.DoubleSide,
                    })
                  );
                  web.rotation.x = -Math.PI / 2 + 0.15;
                  web.position.set(xPos + 0.022, 0.002, 0.05);
                  footGroup.add(web);
                }
              });

              footGroup.position.set(side * 0.15, 0.02, 0.12);
              animal.add(footGroup);
            });
          }

          // ============ FROG ============
          else if (type === "frog") {
            // Wide flat body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1.2, 0.7, 1.0);
            body.position.y = 0.35;
            body.castShadow = true;
            animal.add(body);

            // Spots and warts on back (darker green spots)
            const spotPositions = [
              { x: -0.15, y: 0.45, z: -0.1 },
              { x: 0.12, y: 0.48, z: -0.08 },
              { x: 0.0, y: 0.5, z: -0.15 },
              { x: -0.2, y: 0.38, z: 0.05 },
              { x: 0.18, y: 0.4, z: 0.08 },
              { x: -0.08, y: 0.42, z: 0.12 },
              { x: 0.1, y: 0.35, z: -0.2 },
            ];
            spotPositions.forEach((pos) => {
              const spot = new THREE.Mesh(
                new THREE.SphereGeometry(0.04 + Math.random() * 0.02, 8, 8),
                getMaterial(0x228b22) // Darker forest green
              );
              spot.scale.set(1.2, 0.6, 1.2);
              spot.position.set(pos.x, pos.y, pos.z);
              animal.add(spot);
            });

            // Small wart bumps
            for (let i = 0; i < 12; i++) {
              const wart = new THREE.Mesh(
                new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
                getMaterial(0x2e8b2e)
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.3 + Math.random() * 0.1;
              wart.position.set(
                Math.cos(angle) * radius * 0.8,
                0.4 + Math.random() * 0.1,
                Math.sin(angle) * radius * 0.6 - 0.05
              );
              animal.add(wart);
            }

            // Belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.1, 0.6, 0.8);
            belly.position.set(0, 0.3, 0.15);
            animal.add(belly);

            // Wide flat head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.3, 0.8, 1.0);
            head.position.set(0, 0.55, 0.25);
            animal.add(head);

            // HUGE bulging eyes on top - ENHANCED
            [-1, 1].forEach((side) => {
              // Larger eye bulge
              const eyeBulge = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 18, 18),
                primaryMat
              );
              eyeBulge.position.set(side * 0.22, 0.82, 0.22);
              animal.add(eyeBulge);

              // Eye shadow ring
              const eyeShadow = new THREE.Mesh(
                new THREE.TorusGeometry(0.1, 0.015, 8, 20),
                getMaterial(0x228b22)
              );
              eyeShadow.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeShadow);

              // Larger eye group
              const eyeGroup = new THREE.Group();
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 18, 18),
                SPECIAL_MATERIALS.eyeWhite
              );
              eyeGroup.add(sclera);

              // Golden iris ring (frog style)
              const irisRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.05, 0.025, 10, 20),
                getMaterial(0xc4a020)
              );
              irisRing.position.z = 0.06;
              eyeGroup.add(irisRing);

              // Larger black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.position.z = 0.075;
              eyeGroup.add(pupil);

              // Specular highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025, 0.03, 0.1);
              eyeGroup.add(highlight);

              eyeGroup.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeGroup);
            });

            // Wide mouth line
            const mouth = new THREE.Mesh(
              new THREE.TorusGeometry(0.2, 0.015, 8, 24, Math.PI),
              getMaterial(0x228b22)
            );
            mouth.rotation.x = Math.PI;
            mouth.position.set(0, 0.45, 0.42);
            animal.add(mouth);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 8, 8),
                getMaterial(0x228b22)
              );
              nostril.position.set(side * 0.08, 0.6, 0.48);
              animal.add(nostril);
            });

            // Front legs
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
                primaryMat
              );
              frontLeg.position.set(side * 0.35, 0.2, 0.2);
              frontLeg.rotation.z = side * 0.5;
              animal.add(frontLeg);

              // Front foot with webbing
              const footGroup = new THREE.Group();
              for (let i = 0; i < 3; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.015, 0.06, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1) * 0.03, 0, 0.03);
                footGroup.add(toe);
              }
              footGroup.position.set(side * 0.42, 0.1, 0.25);
              animal.add(footGroup);
            });

            // Long folded back legs
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.1, 0.2, 8, 12),
                primaryMat
              );
              thigh.position.set(side * 0.3, 0.3, -0.15);
              thigh.rotation.z = side * -0.8;
              thigh.rotation.x = 0.3;
              animal.add(thigh);

              // Shin (folded back)
              const shin = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.07, 0.2, 8, 12),
                primaryMat
              );
              shin.position.set(side * 0.45, 0.2, -0.05);
              shin.rotation.z = side * 0.5;
              animal.add(shin);

              // Webbed back foot
              const backFootGroup = new THREE.Group();
              for (let i = 0; i < 4; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.02, 0.1, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1.5) * 0.04, 0, 0.05);
                toe.rotation.x = 0.3;
                backFootGroup.add(toe);
              }
              // Webbing
              const webbing = new THREE.Mesh(
                new THREE.CircleGeometry(0.08, 8),
                primaryMat
              );
              webbing.rotation.x = -Math.PI / 2 + 0.3;
              webbing.position.y = -0.02;
              backFootGroup.add(webbing);

              backFootGroup.position.set(side * 0.5, 0.08, 0.1);
              animal.add(backFootGroup);
            });

            // Throat for pulse animation
            const throat = new THREE.Mesh(
              new THREE.SphereGeometry(0.12, 16, 16),
              secondaryMat
            );
            throat.scale.set(1, 0.6, 0.8);
            throat.position.set(0, 0.35, 0.35);
            animal.userData.animationData.throat = throat;
            animal.add(throat);
          }

          return animal;
        }

        // ==========================================
        // TERRAIN & PEDESTAL
        // ==========================================
        const pedestal = new THREE.Group();

        const pedCyl = new THREE.Mesh(
          new THREE.CylinderGeometry(0.6, 0.7, 0.4, 24),
          new THREE.MeshPhysicalMaterial({
            color: 0x3a3a45,
            roughness: 0.6,
            metalness: 0.1,
          })
        );
        pedCyl.position.y = -0.2;
        pedCyl.receiveShadow = true;
        pedestal.add(pedCyl);

        // CONTACT SHADOW - Soft ambient occlusion under animal
        const contactShadowGeo = new THREE.CircleGeometry(0.5, 32);
        const contactShadowMat = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.35,
          depthWrite: false,
        });
        const contactShadow = new THREE.Mesh(
          contactShadowGeo,
          contactShadowMat
        );
        contactShadow.rotation.x = -Math.PI / 2;
        contactShadow.position.y = 0.005; // Just above pedestal
        pedestal.add(contactShadow);

        const islandGeom = new THREE.CylinderGeometry(4, 1.5, 1.5, 8, 3);
        const pos = islandGeom.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          if (pos.getY(i) > 0) {
            pos.setY(i, pos.getY(i) + (Math.random() - 0.5) * 0.2);
          }
        }
        islandGeom.computeVertexNormals();
        const island = new THREE.Mesh(
          islandGeom,
          new THREE.MeshStandardMaterial({ color: 0x2a3a2a, flatShading: true })
        );
        island.position.y = -1.2;
        island.receiveShadow = true;
        scene.add(island);
        scene.add(pedestal);

        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let currentAnimal = null;
        let currentType = "bunny";
        let currentColor = "default";
        let isTransitioning = false;

        function switchAnimal(type, colorOverride = null) {
          if (isTransitioning) return;

          const color = colorOverride || currentColor;
          const config = ANIMAL_CONFIG[type];

          if (!config) return;

          isTransitioning = true;

          // Scale down current animal
          if (currentAnimal) {
            const oldAnimal = currentAnimal;
            const startScale = { value: 1 };

            const animateOut = () => {
              startScale.value -= 0.08;
              if (startScale.value > 0) {
                oldAnimal.scale.setScalar(startScale.value);
                requestAnimationFrame(animateOut);
              } else {
                // Particle burst at center
                particleBurst.burst(new THREE.Vector3(0, 0.8, 0), 25);

                scene.remove(oldAnimal);
                oldAnimal.traverse((child) => {
                  if (child.geometry) child.geometry.dispose();
                });

                // Create and animate in new animal
                createNewAnimal();
              }
            };
            animateOut();
          } else {
            createNewAnimal();
          }

          function createNewAnimal() {
            currentAnimal = createAnimalModel(type, color);
            currentAnimal.scale.setScalar(0);
            scene.add(currentAnimal);

            currentType = type;

            // Animate in with bounce
            let scaleProgress = 0;
            const animateIn = () => {
              scaleProgress += 0.06;
              if (scaleProgress < 1) {
                // Bounce easing
                const t = scaleProgress;
                const bounce = 1 + Math.sin(t * Math.PI) * 0.15 * (1 - t);
                currentAnimal.scale.setScalar(t * bounce);
                requestAnimationFrame(animateIn);
              } else {
                currentAnimal.scale.setScalar(1);
                isTransitioning = false;
              }
            };
            animateIn();
          }

          // Update UI
          document.getElementById("animal-name").textContent = config.name;
          document.getElementById("animal-emoji").textContent = config.emoji;

          const badgeEl = document.getElementById("animal-badge");
          badgeEl.classList.remove("pop-in");
          void badgeEl.offsetWidth;
          badgeEl.classList.add("pop-in");

          document.querySelectorAll(".animal-btn").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.type === type);
          });
        }

        // Color change handler
        function changeColor(colorName) {
          currentColor = colorName;
          document.querySelectorAll(".color-swatch").forEach((swatch) => {
            swatch.classList.toggle(
              "active",
              swatch.dataset.color === colorName
            );
          });

          if (currentAnimal) {
            switchAnimal(currentType, colorName);
          }
        }

        // Init
        switchAnimal("bunny");

        // Event listeners
        document.querySelectorAll(".animal-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const type = e.currentTarget.dataset.type;
            if (type) switchAnimal(type);
          });
        });

        document.querySelectorAll(".color-swatch").forEach((swatch) => {
          swatch.addEventListener("click", (e) => {
            const color = e.currentTarget.dataset.color;
            if (color) changeColor(color);
          });
        });

        // Screenshot
        document
          .getElementById("btn-screenshot")
          .addEventListener("click", () => {
            composer.render();
            const link = document.createElement("a");
            link.download = `vinyl-${currentType}-${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            link.click();
          });

        // Fullscreen
        document
          .getElementById("btn-fullscreen")
          .addEventListener("click", () => {
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else {
              document.documentElement.requestFullscreen();
            }
          });

        // Sound toggle (placeholder)
        let soundEnabled = false;
        document.getElementById("btn-sound").addEventListener("click", (e) => {
          soundEnabled = !soundEnabled;
          e.currentTarget.textContent = soundEnabled ? "üîä" : "üîá";
        });

        // ==========================================
        // ANIMATION SYSTEM
        // ==========================================
        const clock = new THREE.Clock();

        function tick() {
          const t = clock.getElapsedTime();
          const delta = clock.getDelta();

          // Update particles
          particleBurst.update(delta || 0.016);

          // Floating island
          island.position.y = -1.2 + Math.sin(t * 0.8) * 0.05;
          island.rotation.y = Math.sin(t * 0.2) * 0.05;

          // Animal animations
          if (currentAnimal && !isTransitioning) {
            const type = currentAnimal.userData.type;
            const data = currentAnimal.userData.animationData;

            // ===== ENHANCED BREATHING (localized to body) =====
            const breathCycle = Math.sin(t * 1.8);
            const breath = 1 + breathCycle * 0.015;
            currentAnimal.scale.set(1, breath, 1 + breathCycle * 0.008);

            // ===== ENHANCED BLINKING (asymmetric + expressive) =====
            const blinkCycle = 4;
            const blinkPhase = (t % blinkCycle) / blinkCycle;
            // Add occasional slow "sleepy" blink
            const slowBlink = Math.floor(t / 12) % 3 === 0;
            const blinkSpeed = slowBlink ? 0.08 : 0.03;

            let eyeScaleY = 1;
            if (blinkPhase < blinkSpeed) {
              eyeScaleY = 1 - blinkPhase / blinkSpeed; // Close
            } else if (blinkPhase < blinkSpeed * 2) {
              eyeScaleY = (blinkPhase - blinkSpeed) / blinkSpeed; // Open
            }
            // Squash effect during blink (eyes widen slightly horizontally)
            const eyeScaleX = 1 + (1 - eyeScaleY) * 0.15;
            eyeScaleY = Math.max(0.1, eyeScaleY);

            // ===== EYE DART - SMOOTH LOOK, HOLD, RETURN =====
            // Look cycle: 8 seconds total
            // 0-1s: smoothly look to side, 1-2.5s: hold, 2.5-3.5s: return, 3.5-8s: rest
            const lookCycle = 8;
            const lookPhase = t % lookCycle;
            let eyeOffsetX = 0;

            // Determine direction (alternate left/right each cycle)
            const lookDir = Math.floor(t / lookCycle) % 2 === 0 ? 1 : -1;
            const maxOffset = 0.012;

            if (lookPhase < 1.0) {
              // Smooth ease-out to look position
              const progress = lookPhase / 1.0;
              const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
              eyeOffsetX = maxOffset * lookDir * eased;
            } else if (lookPhase < 2.5) {
              // Hold at look position
              eyeOffsetX = maxOffset * lookDir;
            } else if (lookPhase < 3.5) {
              // Smooth ease-in-out return to center
              const progress = (lookPhase - 2.5) / 1.0;
              const eased =
                progress < 0.5
                  ? 2 * progress * progress
                  : 1 - Math.pow(-2 * progress + 2, 2) / 2;
              eyeOffsetX = maxOffset * lookDir * (1 - eased);
            }
            // else: rest at center (eyeOffsetX = 0)

            // Apply enhanced blink and eye dart to ALL eye parts
            currentAnimal.traverse((child) => {
              if (
                child.isMesh &&
                child.material === SPECIAL_MATERIALS.eyeWhite
              ) {
                if (child.userData.origScaleY === undefined) {
                  child.userData.origScaleY = child.scale.y;
                  child.userData.origScaleX = child.scale.x;
                  child.userData.origPosX = child.position.x;
                }
                child.scale.y = child.userData.origScaleY * eyeScaleY;
                child.scale.x = child.userData.origScaleX * eyeScaleX;
                child.position.x = child.userData.origPosX + eyeOffsetX;
              }
              // Move pupils with eye dart
              if (
                child.isMesh &&
                child.material === SPECIAL_MATERIALS.eyeBlack
              ) {
                if (child.userData.origPosX === undefined) {
                  child.userData.origPosX = child.position.x;
                }
                child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
              }
              // Move specular highlights with eye dart too!
              if (
                child.isMesh &&
                child.material === SPECIAL_MATERIALS.specular
              ) {
                if (child.userData.origPosX === undefined) {
                  child.userData.origPosX = child.position.x;
                }
                child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
              }
            });

            // ===== WEIGHT SHIFT (subtle body sway) =====
            const swayPhase = Math.sin(t * 0.7) * 0.008;
            currentAnimal.rotation.z = swayPhase;

            // Type-specific animations
            switch (type) {
              case "bunny":
                // Enhanced ear twitch with independent timing
                if (data.ears) {
                  data.ears.children.forEach((ear, i) => {
                    const earPhase = t * 3 + i * 1.5;
                    ear.rotation.z =
                      (i === 0 ? -1 : 1) * (0.15 + Math.sin(earPhase) * 0.08);
                    // Occasional alert perk
                    if (Math.floor(t / 6) % 3 === i) {
                      ear.rotation.z += (i === 0 ? -1 : 1) * 0.15;
                    }
                  });
                }
                // Faster nose wiggle (bunnies twitch a lot!)
                if (data.nose) {
                  data.nose.rotation.z = Math.sin(t * 10) * 0.12;
                  data.nose.scale.x = 1 + Math.sin(t * 8) * 0.15;
                }
                // Occasional foot thump
                const thumpPhase = t % 7;
                if (thumpPhase > 6.7 && thumpPhase < 6.85) {
                  currentAnimal.position.y = 0.02;
                } else {
                  currentAnimal.position.y = 0;
                }
                break;

              case "bear":
                // Enhanced head sway with occasional look around
                if (data.head) {
                  const lookAround = Math.floor(t / 8) % 2 === 0;
                  const headSwayAmp = lookAround ? 0.08 : 0.03;
                  data.head.rotation.z = Math.sin(t * 1.2) * headSwayAmp;
                  data.head.rotation.y = Math.sin(t * 0.6) * headSwayAmp * 1.5;
                  // Gentle head tilt
                  data.head.rotation.x = Math.sin(t * 0.4) * 0.02;
                }
                // Shoulder roll motion
                currentAnimal.rotation.x = Math.sin(t * 0.8) * 0.015;
                break;

              case "penguin":
                // Enhanced waddle with happy flipper flutter
                const waddleSpeed = 2.5;
                currentAnimal.rotation.z = Math.sin(t * waddleSpeed) * 0.06;
                currentAnimal.position.x = Math.sin(t * waddleSpeed) * 0.025;
                // Occasional excited hop
                const hopPhase = t % 10;
                if (hopPhase > 9.5) {
                  currentAnimal.position.y =
                    Math.sin((hopPhase - 9.5) * Math.PI * 2) * 0.05;
                }
                break;

              case "fox":
                // Enhanced tail physics
                if (data.tail) {
                  data.tail.rotation.z = Math.sin(t * 3) * 0.22;
                  data.tail.rotation.x = -0.25 + Math.sin(t * 1.5) * 0.1;
                  data.tail.children.forEach((seg, i) => {
                    if (seg.isMesh) {
                      const delay = i * 0.15;
                      seg.rotation.z = Math.sin(t * 4 - delay) * 0.12;
                    }
                  });
                }
                // Alert sniff motion (head bob)
                if (data.head) {
                  const sniffCycle = t % 4;
                  if (sniffCycle > 3.5) {
                    data.head.rotation.x =
                      Math.sin((sniffCycle - 3.5) * Math.PI * 8) * 0.03;
                  }
                }
                break;

              case "elephant":
                // Trunk sway with curl
                if (data.trunk) {
                  data.trunk.rotation.z = Math.sin(t * 1.5) * 0.15;
                  data.trunk.rotation.x = Math.sin(t * 0.8) * 0.1;
                  // Wave through trunk segments
                  data.trunk.children.forEach((seg, i) => {
                    if (seg.isMesh) {
                      const delay = i * 0.1;
                      seg.position.x = Math.sin(t * 2 - delay) * 0.015;
                    }
                  });
                }
                break;

              case "cat":
                // Enhanced tail swish with physics
                if (data.tail) {
                  const swishSpeed = 2.5;
                  const swishAmp = 0.28;
                  data.tail.rotation.z = Math.sin(t * swishSpeed) * swishAmp;
                  data.tail.children.forEach((seg, i) => {
                    if (seg.isMesh) {
                      const delay = i * 0.12;
                      seg.rotation.z = Math.sin(t * 3 - delay) * 0.1;
                    }
                  });
                }
                // Enhanced ear swivel (independent movement)
                if (data.ears) {
                  data.ears.children.forEach((ear, i) => {
                    if (i % 2 === 0) {
                      ear.rotation.y = Math.sin(t * 1.8 + i * 0.5) * 0.12;
                      // Occasional alert perk
                      if (Math.floor(t / 5) % 4 === i) {
                        ear.rotation.z = -0.1;
                      }
                    }
                  });
                }
                // Subtle paw knead
                const kneadPhase = t % 3;
                if (kneadPhase < 0.5) {
                  currentAnimal.position.y =
                    Math.sin(kneadPhase * Math.PI * 4) * 0.008;
                }
                break;

              case "owl":
                // Enhanced head rotation with tilt
                if (data.head) {
                  const headRotation = Math.sin(t * 0.5) * 0.35;
                  // Occasional dramatic turn (owls are known for this!)
                  const dramaticTurn =
                    Math.floor(t / 5) % 2 === 0
                      ? Math.sin(((t % 5) * Math.PI) / 5) * 1.8
                      : 0;
                  data.head.rotation.y = headRotation + dramaticTurn * 0.35;
                  // Head tilt (curious look)
                  data.head.rotation.z = Math.sin(t * 0.7) * 0.15;
                }
                // Feather ruffle (body puff)
                const rufflePhase = t % 12;
                if (rufflePhase > 11.5) {
                  currentAnimal.scale.x =
                    1 + Math.sin((rufflePhase - 11.5) * Math.PI * 4) * 0.03;
                }
                break;

              case "panda":
                // Enhanced chewing motion (happy munching!)
                if (data.muzzle) {
                  const munchSpeed = 5;
                  data.muzzle.scale.y =
                    0.7 + Math.abs(Math.sin(t * munchSpeed)) * 0.12;
                }
                if (data.head) {
                  data.head.rotation.x = Math.sin(t * 5) * 0.025;
                  // Gentle side-to-side while eating
                  data.head.rotation.y = Math.sin(t * 0.8) * 0.04;
                }
                // Occasional belly pat (happy panda!)
                const patPhase = t % 8;
                if (patPhase > 7.5) {
                  currentAnimal.scale.z =
                    1 + Math.sin((patPhase - 7.5) * Math.PI * 4) * 0.02;
                }
                break;

              case "duck":
                // Enhanced head rotation with occasional quack
                if (data.head) {
                  data.head.rotation.x = Math.sin(t * 2.2) * 0.06;
                  data.head.rotation.y = Math.sin(t * 1.3) * 0.04;
                  // Quack motion (head up!)
                  const quackPhase = t % 6;
                  if (quackPhase > 5.5 && quackPhase < 5.7) {
                    data.head.rotation.x = -0.15;
                  }
                }
                // Tail waggle
                const tailWag = Math.sin(t * 4) * 0.03;
                currentAnimal.rotation.y = tailWag;
                break;

              case "frog":
                // Enhanced throat pulse
                if (data.throat) {
                  const pulseSpeed = 2.5;
                  const pulse =
                    1 + Math.max(0, Math.sin(t * pulseSpeed)) * 0.35;
                  data.throat.scale.set(1.1 * pulse, 0.6 * pulse, 0.8);
                }
                // Leg twitch (ready to jump!)
                const legTwitch = t % 5;
                if (legTwitch > 4.5 && legTwitch < 4.7) {
                  currentAnimal.scale.y = 0.95;
                } else {
                  currentAnimal.scale.y = 1 + Math.sin(t * 1.8) * 0.015; // Breathing
                }
                // Occasional jump anticipation with crouch
                const jumpPhase = t % 8;
                if (jumpPhase > 7.3 && jumpPhase < 7.5) {
                  currentAnimal.scale.y = 0.92; // Crouch
                } else if (jumpPhase > 7.5) {
                  currentAnimal.position.y = 0.05 + (jumpPhase - 7.5) * 0.12;
                } else {
                  currentAnimal.position.y = 0;
                }
                break;
            }

            // Gentle idle sway for all
            currentAnimal.rotation.z = Math.sin(t * 1.5) * 0.02;
          }

          controls.update();
          composer.render();
          requestAnimationFrame(tick);
        }

        // ==========================================
        // RESIZE HANDLER
        // ==========================================
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading
        setTimeout(() => {
          document.getElementById("loading").style.opacity = "0";
          setTimeout(
            () => (document.getElementById("loading").style.display = "none"),
            700
          );
        }, 800);

        tick();
      } catch (err) {
        console.error(err);
        showError("Failed to initialize 3D scene. " + err.message);
      }
    </script>
  </body>
</html>
