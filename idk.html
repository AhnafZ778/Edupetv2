<it provided the above code but I think the models can be better, provide a more
detailed prompt for improving the models and push the LLMs to their absolute
limits. Below is the code it gave:>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soft Vinyl Diorama - Enhanced Collection</title>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: radial-gradient(circle at center, #2a2a35 0%, #1a1a25 100%);
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        inset: 0;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(107, 91, 122, 0.2);
        border-top-color: #8b9bb4;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .glass {
        background: rgba(30, 30, 40, 0.7);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: 1px solid rgba(60, 60, 80, 0.5);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .animal-btn,
      .room-btn {
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        position: relative;
        overflow: hidden;
        background: rgba(40, 40, 55, 0.6);
        color: #b0b8c8;
      }
      .animal-btn::after,
      .room-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(80, 80, 100, 0.3),
          rgba(40, 40, 55, 0)
        );
        opacity: 0;
        transition: opacity 0.3s;
      }
      .animal-btn:hover,
      .room-btn:hover {
        transform: translateY(-2px);
        background: rgba(60, 60, 80, 0.85);
        color: #e0e4ec;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }
      .animal-btn.active,
      .room-btn.active {
        background: #4a5068;
        color: #ffffff;
        font-weight: 700;
        box-shadow: 0 4px 12px rgba(139, 155, 180, 0.25);
        transform: scale(1.02);
      }
      .style-btn {
        background: rgba(40, 44, 56, 0.8);
        color: #8b9bb4;
        border: 1px solid rgba(139, 155, 180, 0.2);
        transition: all 0.2s ease;
        cursor: pointer;
        font-size: 11px;
        padding: 8px 12px;
        border-radius: 8px;
      }
      .style-btn:hover {
        background: rgba(60, 66, 82, 0.9);
        border-color: rgba(139, 155, 180, 0.4);
      }
      .style-btn.active {
        background: #5a6478;
        color: #ffffff;
        border-color: rgba(139, 155, 180, 0.6);
      }
      .animal-btn.active::after,
      .room-btn.active::after {
        opacity: 1;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .pop-in {
        animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .tool-btn {
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.7);
      }
      .tool-btn:hover {
        background: rgba(255, 255, 255, 0.95);
        transform: scale(1.05);
      }

      .color-swatch {
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .color-swatch:hover {
        transform: scale(1.15);
      }
      .color-swatch.active {
        ring: 2px solid #6b7c93;
        transform: scale(1.1);
        box-shadow: 0 0 0 2px #6b7c93;
      }

      /* Scrollbar styling for button container */
      .btn-scroll::-webkit-scrollbar {
        height: 4px;
      }
      .btn-scroll::-webkit-scrollbar-track {
        background: transparent;
      }
      .btn-scroll::-webkit-scrollbar-thumb {
        background: rgba(139, 155, 180, 0.3);
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div
      id="loading"
      class="fixed inset-0 z-[1000] flex flex-col items-center justify-center bg-[#f0f8ff] transition-opacity duration-700"
    >
      <div class="loader"></div>
      <div class="mt-6 text-center">
        <div class="tracking-[0.2em] text-[#6b7c93] text-lg font-medium">
          VINYL SERENITY
        </div>
        <div class="mt-2 text-[#98a6b8] text-sm">Molding plastic...</div>
      </div>
    </div>

    <!-- Error Overlay -->
    <div
      id="error-overlay"
      class="fixed inset-0 z-[2000] hidden flex-col items-center justify-center bg-red-50/95 p-6"
    >
      <div class="max-w-md text-center">
        <div class="text-5xl mb-4">‚ö†Ô∏è</div>
        <h1 class="text-xl font-bold text-red-800 mb-2">Rendering Error</h1>
        <p class="text-red-600 mb-6 text-sm" id="error-message">
          WebGL Context Lost
        </p>
        <button
          onclick="location.reload()"
          class="px-6 py-2 bg-white text-red-800 rounded-full shadow-md hover:shadow-lg transition text-sm font-medium border border-red-100"
        >
          Reload Viewer
        </button>
      </div>
    </div>

    <!-- Header -->
    <div
      class="pointer-events-none fixed top-6 left-1/2 -translate-x-1/2 z-[120]"
    >
      <div
        class="text-[#8b9bb4] text-xs font-bold tracking-[0.3em] uppercase opacity-80"
      >
        Soft Vinyl Collection
      </div>
    </div>

    <!-- Animal Badge -->
    <div class="fixed top-12 left-1/2 -translate-x-1/2 z-[120]">
      <div
        id="animal-badge"
        class="glass rounded-full px-6 py-2 text-[#5a6b85] text-sm font-semibold transition-all duration-300 flex items-center gap-2"
      >
        <span id="animal-emoji" class="text-lg">üê∞</span>
        <span id="animal-name">Bunny</span>
      </div>
    </div>

    <!-- Tool Buttons (Top Right) -->
    <div class="fixed top-6 right-6 z-[120] flex gap-2">
      <button
        id="btn-screenshot"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Screenshot"
      >
        üì∑
      </button>
      <button
        id="btn-fullscreen"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Fullscreen"
      >
        ‚õ∂
      </button>
      <button
        id="btn-sound"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Sound"
      >
        üîá
      </button>
    </div>

    <!-- Color Palette (Top Left) -->
    <div class="fixed top-6 left-6 z-[120]">
      <div class="glass rounded-2xl p-3">
        <div
          class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
        >
          Color
        </div>
        <div id="color-palette" class="flex gap-2">
          <div
            class="color-swatch active w-6 h-6 rounded-full bg-white border border-gray-200"
            data-color="default"
            title="Default"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-pink-200"
            data-color="pink"
            title="Pink"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-blue-200"
            data-color="blue"
            title="Blue"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-yellow-200"
            data-color="yellow"
            title="Yellow"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-green-200"
            data-color="green"
            title="Green"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-purple-200"
            data-color="purple"
            title="Purple"
          ></div>
        </div>
      </div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- Room Navigation -->
    <div
      class="fixed bottom-6 left-1/2 -translate-x-1/2 z-[120] w-[95%] max-w-2xl"
    >
      <div class="glass rounded-2xl p-3">
        <div
          class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
        >
          Rooms
        </div>
        <div class="flex gap-3 justify-center">
          <button
            class="room-btn active px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="living"
          >
            <span class="text-2xl">üõãÔ∏è</span>
            <span class="text-[#5a6b85]">Living Room</span>
            <span class="text-[10px] text-[#8b9bb4]">üê∞üê±üêª</span>
          </button>
          <button
            class="room-btn px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="bedroom"
          >
            <span class="text-2xl">üõèÔ∏è</span>
            <span class="text-[#5a6b85]">Bedroom</span>
            <span class="text-[10px] text-[#8b9bb4]">ü¶âüêºü¶ä</span>
          </button>
          <button
            class="room-btn px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="garden"
          >
            <span class="text-2xl">üå≥</span>
            <span class="text-[#5a6b85]">Garden</span>
            <span class="text-[10px] text-[#8b9bb4]">üêßü¶Üüê∏üêò</span>
          </button>
        </div>

        <!-- Art Style Selector -->
        <div class="mt-4">
          <div
            class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
          >
            Art Style
          </div>
          <div class="flex gap-2 justify-center flex-wrap" id="style-selector">
            <button class="style-btn active" data-style="vinyl">
              üé® Vinyl
            </button>
            <button class="style-btn" data-style="matte">üß∏ Matte</button>
            <button class="style-btn" data-style="plastic">‚ú® Plastic</button>
            <button class="style-btn" data-style="glossy">üíß Glossy</button>
            <button class="style-btn" data-style="fuzzy">üß∂ Fuzzy</button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ==========================================
      // ERROR HANDLING
      // ==========================================
      function showError(msg) {
        document.getElementById("loading").style.display = "none";
        const el = document.getElementById("error-overlay");
        el.classList.remove("hidden");
        el.classList.add("flex");
        document.getElementById("error-message").innerText = msg;
      }

      try {
        // ==========================================
        // ANIMAL CONFIGURATION SYSTEM
        // ==========================================
        const ANIMAL_CONFIG = {
          bunny: {
            name: "Bunny",
            emoji: "üê∞",
            primaryColor: 0xffffff,
            secondaryColor: 0xffb7c5,
            accentColor: 0x1a1a1a,
          },
          bear: {
            name: "Bear",
            emoji: "üêª",
            primaryColor: 0x8d7b68,
            secondaryColor: 0xe0cda7,
            accentColor: 0x1a1a1a,
          },
          penguin: {
            name: "Penguin",
            emoji: "üêß",
            primaryColor: 0x1a1a1a,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c42,
          },
          fox: {
            name: "Fox",
            emoji: "ü¶ä",
            primaryColor: 0xff8c42,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          elephant: {
            name: "Elephant",
            emoji: "üêò",
            primaryColor: 0x9ca3af,
            secondaryColor: 0xffffff,
            accentColor: 0x6b7280,
          },
          cat: {
            name: "Cat",
            emoji: "üê±",
            primaryColor: 0xffa500,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          owl: {
            name: "Owl",
            emoji: "ü¶â",
            primaryColor: 0x8b4513,
            secondaryColor: 0xdeb887,
            accentColor: 0xffa500,
          },
          panda: {
            name: "Panda",
            emoji: "üêº",
            primaryColor: 0xffffff,
            secondaryColor: 0x1a1a1a,
            accentColor: 0x1a1a1a,
          },
          duck: {
            name: "Duck",
            emoji: "ü¶Ü",
            primaryColor: 0xf5deb3,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c00,
          },
          frog: {
            name: "Frog",
            emoji: "üê∏",
            primaryColor: 0x32cd32,
            secondaryColor: 0x98fb98,
            accentColor: 0xff6347,
          },
        };

        // Color palettes for customization
        const COLOR_PALETTES = {
          default: null,
          pink: { primary: 0xffb6c1, secondary: 0xffc0cb },
          blue: { primary: 0xadd8e6, secondary: 0xe0ffff },
          yellow: { primary: 0xfffacd, secondary: 0xffffe0 },
          green: { primary: 0x98fb98, secondary: 0xf0fff0 },
          purple: { primary: 0xdda0dd, secondary: 0xe6e6fa },
        };

        // ==========================================
        // SCENE SETUP
        // ==========================================
        const container = document.getElementById("canvas-container");
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e2028);
        scene.fog = new THREE.Fog(0x1e2028, 10, 30);

        const camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.set(5, 3, 5);

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        container.appendChild(renderer.domElement);

        // ==========================================
        // LIGHTING - PHASE 4 ENHANCED PREMIUM SETUP
        // ==========================================
        // Warm ambient for soft vinyl appearance
        const ambientLight = new THREE.AmbientLight(0xfff8f0, 0.7);
        scene.add(ambientLight);

        // Key light - warm, main illumination with HIGH QUALITY shadows
        const keyLight = new THREE.DirectionalLight(0xffeedd, 2.4);
        keyLight.position.set(5, 10, 4);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 4096; // 4K shadow for crisp edges
        keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.bias = -0.00005; // Reduced bias for less peter-panning
        keyLight.shadow.normalBias = 0.02; // Helps with self-shadowing
        keyLight.shadow.radius = 4; // Softer shadows
        keyLight.shadow.camera.near = 0.5;
        keyLight.shadow.camera.far = 25;
        keyLight.shadow.camera.left = -8;
        keyLight.shadow.camera.right = 8;
        keyLight.shadow.camera.top = 8;
        keyLight.shadow.camera.bottom = -8;
        scene.add(keyLight);

        // Cool fill light - adds dimension
        const fillLight = new THREE.DirectionalLight(0xc8e0ff, 1.5);
        fillLight.position.set(-5, 4, -2);
        scene.add(fillLight);

        // ENHANCED RIM LIGHT - Colored for dramatic effect
        const rimLight = new THREE.DirectionalLight(0xffc8ff, 1.5);
        rimLight.position.set(0, 4, -8);
        scene.add(rimLight);

        // Secondary rim (opposite side) for balanced silhouette
        const rimLight2 = new THREE.DirectionalLight(0xc8ffff, 0.8);
        rimLight2.position.set(3, 2, -6);
        scene.add(rimLight2);

        // Bottom fill for softer under-shadows (ground bounce)
        const bottomFill = new THREE.DirectionalLight(0xfff5ee, 0.5);
        bottomFill.position.set(0, -3, 2);
        scene.add(bottomFill);

        // Subtle side accent light
        const accentLight = new THREE.DirectionalLight(0xffe8d0, 0.7);
        accentLight.position.set(-4, 2, 5);
        scene.add(accentLight);

        // ==========================================
        // POST-PROCESSING - ENHANCED BLOOM
        // ==========================================
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.3, // Increased bloom strength for premium glow
          0.35, // Tighter radius
          0.85 // Higher threshold for selective glow
        );
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.autoRotate = false; // Disable auto-rotate to stay in room
        controls.minDistance = 4;
        controls.maxDistance = 8;
        // Limit vertical angle (don't look too far up or down)
        controls.minPolarAngle = Math.PI / 4; // 45 degrees from top
        controls.maxPolarAngle = Math.PI / 2.2; // ~80 degrees from top
        // Limit horizontal rotation to stay within room
        controls.minAzimuthAngle = -Math.PI / 3; // -60 degrees
        controls.maxAzimuthAngle = Math.PI / 3; // +60 degrees
        controls.enablePan = false; // Disable panning to prevent leaving room

        // ==========================================
        // MATERIAL FACTORY - PHASE 4 PREMIUM VINYL
        // ==========================================
        function createVinylMaterial(color, options = {}) {
          // Calculate sheen color based on primary color for subtle iridescence
          const baseColor = new THREE.Color(color);
          const sheenColor = baseColor.clone().offsetHSL(0.05, 0.1, 0.2);

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.2,
            metalness: options.metalness ?? 0.0,
            clearcoat: options.clearcoat ?? 0.6,
            clearcoatRoughness: options.clearcoatRoughness ?? 0.06,
            reflectivity: options.reflectivity ?? 0.7,
            // Enhanced sheen for soft vinyl subsurface
            sheen: options.sheen ?? 0.35,
            sheenRoughness: options.sheenRoughness ?? 0.35,
            sheenColor: options.sheenColor ?? sheenColor,
            // Stronger iridescence for premium look
            iridescence: options.iridescence ?? 0.2,
            iridescenceIOR: options.iridescenceIOR ?? 1.4,
            // Environment map intensity for reflections
            envMapIntensity: options.envMapIntensity ?? 0.8,
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Matte material variant for softer areas
        function createMatteMaterial(color, options = {}) {
          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.6,
            metalness: 0.0,
            clearcoat: 0.1,
            sheen: 0.5,
            sheenRoughness: 0.8,
            sheenColor: new THREE.Color(color).offsetHSL(0, -0.1, 0.3),
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Cached materials
        const materialCache = new Map();
        function getMaterial(color, options = {}) {
          const key = `${color}-${JSON.stringify(options)}`;
          if (!materialCache.has(key)) {
            materialCache.set(key, createVinylMaterial(color, options));
          }
          return materialCache.get(key);
        }

        // Special materials - ENHANCED for premium look
        const SPECIAL_MATERIALS = {
          // Ultra-glossy deep pupil with subtle blue undertone
          eyeBlack: new THREE.MeshPhysicalMaterial({
            color: 0x050510,
            roughness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            metalness: 0.05,
            reflectivity: 1.0,
            ior: 1.5,
          }),
          // Creamy white sclera with subtle translucency
          eyeWhite: new THREE.MeshPhysicalMaterial({
            color: 0xfffef8,
            roughness: 0.08,
            clearcoat: 0.9,
            clearcoatRoughness: 0.05,
            sheen: 0.2,
            sheenColor: new THREE.Color(0xfff0f0),
            transmission: 0.02,
            thickness: 0.1,
          }),
          // Bright specular highlight with subtle bloom potential
          specular: new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.95,
          }),
          // Deep black slit pupil
          pupilSlit: new THREE.MeshBasicMaterial({ color: 0x000005 }),
          // New: Iris material for colored eye details
          iris: function (color) {
            return new THREE.MeshPhysicalMaterial({
              color: color,
              roughness: 0.1,
              clearcoat: 0.8,
              metalness: 0.0,
              sheen: 0.4,
              sheenColor: new THREE.Color(color).offsetHSL(0.1, 0, 0.2),
            });
          },
        };

        // ==========================================
        // ART STYLES SYSTEM
        // ==========================================

        // Current global art style
        let currentArtStyle = "vinyl";

        // Art style presets with material properties
        const ART_STYLES = {
          vinyl: {
            name: "Vinyl Toy",
            roughness: 0.15,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.1,
            sheen: 0.8,
            sheenRoughness: 0.3,
            envMapIntensity: 0.6,
            saturation: 1.0,
          },
          matte: {
            name: "Soft Plush",
            roughness: 0.7,
            metalness: 0.0,
            clearcoat: 0.0,
            clearcoatRoughness: 0.8,
            sheen: 0.9,
            sheenRoughness: 0.9,
            envMapIntensity: 0.2,
            saturation: 0.9,
          },
          plastic: {
            name: "Bright Plastic",
            roughness: 0.25,
            metalness: 0.02,
            clearcoat: 0.6,
            clearcoatRoughness: 0.2,
            sheen: 0.3,
            sheenRoughness: 0.4,
            envMapIntensity: 0.5,
            saturation: 1.2,
          },
          glossy: {
            name: "Glossy Wet",
            roughness: 0.05,
            metalness: 0.05,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            sheen: 0.2,
            sheenRoughness: 0.2,
            envMapIntensity: 0.9,
            saturation: 1.0,
          },
          fuzzy: {
            name: "Fuzzy Felt",
            roughness: 0.95,
            metalness: 0.0,
            clearcoat: 0.0,
            clearcoatRoughness: 1.0,
            sheen: 1.0,
            sheenRoughness: 1.0,
            envMapIntensity: 0.1,
            saturation: 0.85,
          },
        };

        // Create material with specified art style
        function createStyledMaterial(
          baseColor,
          artStyle = null,
          options = {}
        ) {
          const style = ART_STYLES[artStyle || currentArtStyle];
          const color = new THREE.Color(baseColor);

          // Apply saturation adjustment
          const hsl = {};
          color.getHSL(hsl);
          color.setHSL(hsl.h, hsl.s * style.saturation, hsl.l);

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: style.roughness,
            metalness: style.metalness,
            clearcoat: style.clearcoat,
            clearcoatRoughness: style.clearcoatRoughness,
            sheen: style.sheen,
            sheenRoughness: style.sheenRoughness,
            sheenColor: color.clone().offsetHSL(0, -0.1, 0.2),
            envMapIntensity: style.envMapIntensity,
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Change art style for all animals (will need respawn or material update)
        function setArtStyle(styleName) {
          if (ART_STYLES[styleName]) {
            currentArtStyle = styleName;
            console.log(`Art style changed to: ${ART_STYLES[styleName].name}`);
          }
        }

        // ==========================================
        // GEOMETRY HELPERS
        // ==========================================

        // Teardrop/Paddle shape for ears
        function createTeardropGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 16
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * (1 - t) - height / 2;
            const radius =
              radiusBottom + (radiusTop - radiusBottom) * Math.pow(1 - t, 0.5);
            points.push(new THREE.Vector2(radius, y));
          }
          points.push(new THREE.Vector2(0, -height / 2));
          return new THREE.LatheGeometry(points, 16);
        }

        // Pear shape for body
        function createPearGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 32
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * t - height / 2;
            // Pear curve - wider at bottom
            const radius =
              radiusTop + (radiusBottom - radiusTop) * Math.pow(t, 0.6);
            points.push(new THREE.Vector2(radius * Math.sin(Math.PI * t), y));
          }
          return new THREE.LatheGeometry(points, 24);
        }

        // Curved trunk with segments
        function createTrunkGeometry(
          baseRadius,
          tipRadius,
          segments,
          curveStrength = 0.3
        ) {
          const group = new THREE.Group();
          for (let i = 0; i < segments; i++) {
            const t = i / (segments - 1);
            const radius = baseRadius + (tipRadius - baseRadius) * t;
            const segment = new THREE.Mesh(
              new THREE.SphereGeometry(radius, 12, 12),
              null // Material applied later
            );
            // S-curve positioning
            const curve = Math.sin(t * Math.PI) * curveStrength;
            segment.position.y = -i * (baseRadius * 1.2);
            segment.position.z = curve + t * 0.2;
            group.add(segment);
          }
          return group;
        }

        // Eye with optional slit pupil - PREMIUM ENHANCED VERSION
        function createEye(scale = 1, slitPupil = false, options = {}) {
          const group = new THREE.Group();
          const baseScale = scale * 1.25; // 25% larger eyes overall

          // Optional eyelid ridge (for mammals)
          if (options.eyelid) {
            const lidGeom = new THREE.TorusGeometry(
              0.075 * baseScale,
              0.012 * baseScale,
              8,
              16,
              Math.PI
            );
            const lid = new THREE.Mesh(
              lidGeom,
              options.lidMaterial || getMaterial(0x1a1a1a)
            );
            lid.rotation.x = Math.PI / 2;
            lid.rotation.z = Math.PI;
            lid.position.set(0, 0.03 * baseScale, 0.02 * baseScale);
            group.add(lid);
          }

          // Ambient occlusion shadow ring around eye (subtle depth)
          const aoRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.078 * baseScale,
              0.008 * baseScale,
              8,
              24
            ),
            new THREE.MeshBasicMaterial({
              color: 0x2a2020,
              transparent: true,
              opacity: 0.15,
            })
          );
          aoRing.position.z = -0.002;
          group.add(aoRing);

          // Sclera (white) - slightly larger with depth
          const scleraGeom = new THREE.SphereGeometry(
            0.075 * baseScale,
            24,
            24
          );
          const sclera = new THREE.Mesh(scleraGeom, SPECIAL_MATERIALS.eyeWhite);
          group.add(sclera);

          // Iris ring (colored ring around pupil for depth)
          const irisColor = options.irisColor || 0x3a2510; // Deep brown default
          const irisRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.038 * baseScale,
              0.015 * baseScale,
              12,
              24
            ),
            SPECIAL_MATERIALS.iris(irisColor)
          );
          irisRing.position.z = 0.04 * baseScale;
          group.add(irisRing);

          // Inner iris gradient (darker inner ring)
          const innerIris = new THREE.Mesh(
            new THREE.RingGeometry(0.025 * baseScale, 0.045 * baseScale, 24),
            new THREE.MeshPhysicalMaterial({
              color: new THREE.Color(irisColor).offsetHSL(0, 0, -0.3),
              roughness: 0.15,
              clearcoat: 0.6,
              side: THREE.DoubleSide,
            })
          );
          innerIris.position.z = 0.042 * baseScale;
          group.add(innerIris);

          if (slitPupil) {
            // Cat-style slit pupil with subtle glow edge
            const pupilGeom = new THREE.CylinderGeometry(
              0.012 * baseScale,
              0.012 * baseScale,
              0.095 * baseScale,
              8
            );
            const pupil = new THREE.Mesh(
              pupilGeom,
              SPECIAL_MATERIALS.pupilSlit
            );
            pupil.rotation.x = Math.PI / 2;
            pupil.position.z = 0.055 * baseScale;
            group.add(pupil);

            // Subtle glow around slit for ethereal look
            const slitGlow = new THREE.Mesh(
              new THREE.CylinderGeometry(
                0.018 * baseScale,
                0.018 * baseScale,
                0.09 * baseScale,
                8
              ),
              new THREE.MeshBasicMaterial({
                color: irisColor,
                transparent: true,
                opacity: 0.25,
              })
            );
            slitGlow.rotation.x = Math.PI / 2;
            slitGlow.position.z = 0.054 * baseScale;
            group.add(slitGlow);
          } else {
            // Round pupil - larger for cuter look with depth
            const pupilGeom = new THREE.SphereGeometry(
              0.048 * baseScale,
              20,
              20
            );
            const pupil = new THREE.Mesh(pupilGeom, SPECIAL_MATERIALS.eyeBlack);
            pupil.position.z = 0.045 * baseScale;
            group.add(pupil);
          }

          // Primary highlight (larger, more prominent, positioned at 10 o'clock)
          const highlightGeom = new THREE.SphereGeometry(
            0.022 * baseScale,
            10,
            10
          );
          const highlight = new THREE.Mesh(
            highlightGeom,
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(
            0.018 * baseScale,
            0.028 * baseScale,
            0.068 * baseScale
          );
          group.add(highlight);

          // Secondary highlight (smaller, at 4 o'clock for depth)
          const highlight2Geom = new THREE.SphereGeometry(
            0.012 * baseScale,
            8,
            8
          );
          const highlight2 = new THREE.Mesh(
            highlight2Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(
            -0.012 * baseScale,
            -0.018 * baseScale,
            0.066 * baseScale
          );
          group.add(highlight2);

          // Tertiary micro-highlight (adds sparkle)
          const highlight3Geom = new THREE.SphereGeometry(
            0.006 * baseScale,
            6,
            6
          );
          const highlight3 = new THREE.Mesh(
            highlight3Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight3.position.set(
            0.03 * baseScale,
            0.008 * baseScale,
            0.067 * baseScale
          );
          group.add(highlight3);

          // Subtle lower eye shadow (adds dimension)
          const lowerShadow = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.065 * baseScale,
              0.006 * baseScale,
              8,
              16,
              Math.PI * 0.6
            ),
            new THREE.MeshBasicMaterial({
              color: 0x1a1015,
              transparent: true,
              opacity: 0.08,
            })
          );
          lowerShadow.rotation.x = Math.PI / 2;
          lowerShadow.rotation.z = Math.PI * 0.7;
          lowerShadow.position.set(0, -0.02 * baseScale, 0.03 * baseScale);
          group.add(lowerShadow);

          return group;
        }

        // Owl-style concentric eye - PREMIUM ENHANCED
        function createOwlEye(scale = 1) {
          const group = new THREE.Group();

          // Deep ambient shadow around eye socket
          const eyeSocket = new THREE.Mesh(
            new THREE.CircleGeometry(0.14 * scale, 32),
            new THREE.MeshBasicMaterial({
              color: 0x2a1a10,
              transparent: true,
              opacity: 0.2,
            })
          );
          eyeSocket.position.z = -0.005;
          group.add(eyeSocket);

          // Outer ring (facial disc) - thicker and more prominent
          const outerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.125 * scale, 0.025 * scale, 12, 32),
            getMaterial(0xdeb887, { roughness: 0.4 })
          );
          group.add(outerRing);

          // Secondary inner ring for depth
          const innerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.105 * scale, 0.01 * scale, 8, 24),
            getMaterial(0xc9a87a, { roughness: 0.5 })
          );
          innerRing.position.z = 0.003;
          group.add(innerRing);

          // Orange iris base - more vibrant
          const eyeBg = new THREE.Mesh(
            new THREE.CircleGeometry(0.1 * scale, 32),
            new THREE.MeshPhysicalMaterial({
              color: 0xff9500,
              roughness: 0.1,
              clearcoat: 0.7,
              sheen: 0.3,
              sheenColor: new THREE.Color(0xffcc00),
            })
          );
          eyeBg.position.z = 0.01;
          group.add(eyeBg);

          // Iris ring pattern (owls have radiating patterns)
          const irisPattern = new THREE.Mesh(
            new THREE.RingGeometry(0.055 * scale, 0.095 * scale, 24, 3),
            new THREE.MeshPhysicalMaterial({
              color: 0xcc6600,
              roughness: 0.2,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.6,
            })
          );
          irisPattern.position.z = 0.012;
          group.add(irisPattern);

          // Inner iris glow ring
          const innerGlow = new THREE.Mesh(
            new THREE.RingGeometry(0.05 * scale, 0.065 * scale, 24),
            new THREE.MeshPhysicalMaterial({
              color: 0xffaa00,
              roughness: 0.05,
              emissive: 0x331100,
              emissiveIntensity: 0.1,
              side: THREE.DoubleSide,
            })
          );
          innerGlow.position.z = 0.015;
          group.add(innerGlow);

          // Large deep pupil
          const pupil = new THREE.Mesh(
            new THREE.CircleGeometry(0.05 * scale, 24),
            SPECIAL_MATERIALS.eyeBlack
          );
          pupil.position.z = 0.018;
          group.add(pupil);

          // Primary highlight - larger for owl
          const highlight = new THREE.Mesh(
            new THREE.CircleGeometry(0.025 * scale, 12),
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(0.028 * scale, 0.028 * scale, 0.025);
          group.add(highlight);

          // Secondary highlight
          const highlight2 = new THREE.Mesh(
            new THREE.CircleGeometry(0.012 * scale, 8),
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(-0.015 * scale, -0.02 * scale, 0.024);
          group.add(highlight2);

          // Micro sparkle
          const sparkle = new THREE.Mesh(
            new THREE.CircleGeometry(0.006 * scale, 6),
            SPECIAL_MATERIALS.specular
          );
          sparkle.position.set(0.04 * scale, 0.01 * scale, 0.024);
          group.add(sparkle);

          return group;
        }

        // Paw with pad indentations
        function createPaw(radius, material, padMaterial) {
          const group = new THREE.Group();

          // Main paw
          const paw = new THREE.Mesh(
            new THREE.SphereGeometry(radius, 16, 16),
            material
          );
          paw.scale.set(1, 0.6, 1.2);
          group.add(paw);

          // Main pad
          const mainPad = new THREE.Mesh(
            new THREE.SphereGeometry(radius * 0.5, 12, 12),
            padMaterial
          );
          mainPad.position.set(0, -radius * 0.2, radius * 0.3);
          mainPad.scale.set(1.2, 0.5, 1);
          group.add(mainPad);

          // Toe pads
          for (let i = -1; i <= 1; i++) {
            const toePad = new THREE.Mesh(
              new THREE.SphereGeometry(radius * 0.2, 8, 8),
              padMaterial
            );
            toePad.position.set(i * radius * 0.4, -radius * 0.2, radius * 0.7);
            group.add(toePad);
          }

          return group;
        }

        // ==========================================
        // PARTICLE SYSTEM FOR TRANSITIONS
        // ==========================================
        class ParticleBurst {
          constructor(scene) {
            this.scene = scene;
            this.particles = [];
            this.geometry = new THREE.SphereGeometry(0.03, 8, 8);
            this.materials = [
              new THREE.MeshBasicMaterial({ color: 0xffb7c5 }),
              new THREE.MeshBasicMaterial({ color: 0xadd8e6 }),
              new THREE.MeshBasicMaterial({ color: 0xfffacd }),
              new THREE.MeshBasicMaterial({ color: 0x98fb98 }),
              new THREE.MeshBasicMaterial({ color: 0xdda0dd }),
            ];
          }

          burst(position, count = 20) {
            for (let i = 0; i < count; i++) {
              const material =
                this.materials[
                  Math.floor(Math.random() * this.materials.length)
                ];
              const particle = new THREE.Mesh(this.geometry, material);
              particle.position.copy(position);
              particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                Math.random() * 0.1 + 0.05,
                (Math.random() - 0.5) * 0.15
              );
              particle.userData.life = 1.0;
              this.scene.add(particle);
              this.particles.push(particle);
            }
          }

          update(delta) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const p = this.particles[i];
              p.position.add(p.userData.velocity);
              p.userData.velocity.y -= 0.005; // gravity
              p.userData.life -= delta * 2;
              p.scale.setScalar(p.userData.life);

              if (p.userData.life <= 0) {
                this.scene.remove(p);
                this.particles.splice(i, 1);
              }
            }
          }
        }

        const particleBurst = new ParticleBurst(scene);

        // ==========================================
        // ANIMAL MODEL FACTORY
        // ==========================================
        function createAnimalModel(type, colorOverride = null) {
          const config = ANIMAL_CONFIG[type];
          const animal = new THREE.Group();
          animal.userData.type = type;
          animal.userData.animationData = {};

          // Apply color override
          let primaryColor = config.primaryColor;
          let secondaryColor = config.secondaryColor;
          if (colorOverride && COLOR_PALETTES[colorOverride]) {
            primaryColor = COLOR_PALETTES[colorOverride].primary;
            secondaryColor = COLOR_PALETTES[colorOverride].secondary;
          }

          const primaryMat = getMaterial(primaryColor);
          const secondaryMat = getMaterial(secondaryColor);
          const accentMat = getMaterial(config.accentColor);

          // ============ BUNNY - ENHANCED ============
          if (type === "bunny") {
            // Pear-shaped body (larger hindquarters) - slightly rounder
            const bodyGeom = new THREE.SphereGeometry(0.42, 32, 32);
            const body = new THREE.Mesh(bodyGeom, primaryMat);
            body.scale.set(0.88, 1.12, 1.02);
            body.position.y = 0.45;
            body.castShadow = true;
            animal.add(body);

            // Hindquarters bump - more pronounced
            const hindquarters = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 24, 24),
              primaryMat
            );
            hindquarters.position.set(0, 0.28, -0.18);
            hindquarters.castShadow = true;
            animal.add(hindquarters);

            // Smooth body transition
            const bodyTransition = new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 16, 16),
              primaryMat
            );
            bodyTransition.position.set(0, 0.75, 0);
            animal.add(bodyTransition);

            // Head (slightly oval, wider at cheeks)
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 1.08;
            head.castShadow = true;
            animal.add(head);

            // Enhanced cheeks with subtle blush
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 20, 20),
                primaryMat
              );
              cheek.position.set(side * 0.3, 0.94, 0.16);
              animal.add(cheek);

              // Blush spots
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.35,
                  roughness: 0.6,
                })
              );
              blush.position.set(side * 0.34, 0.92, 0.28);
              blush.rotation.y = side * 0.3;
              animal.add(blush);
            });

            // Subtle eyebrow ridges
            [-1, 1].forEach((side) => {
              const brow = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.02, 0.08, 6, 8),
                primaryMat
              );
              brow.position.set(side * 0.16, 1.2, 0.32);
              brow.rotation.z = side * -0.3;
              brow.rotation.x = 0.2;
              animal.add(brow);
            });

            // Enhanced paddle-shaped ears (thicker, more teardrop)
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              const earOuter = new THREE.Group();

              // Main ear body - thicker elliptical paddle
              const earGeom = new THREE.CapsuleGeometry(0.12, 0.75, 12, 20);
              const ear = new THREE.Mesh(earGeom, primaryMat);
              ear.scale.set(1.15, 1, 0.45);
              earOuter.add(ear);

              // Ear edge rim for thickness
              const earRim = new THREE.Mesh(
                new THREE.TorusGeometry(0.085, 0.025, 8, 24, Math.PI * 1.6),
                primaryMat
              );
              earRim.position.set(0, 0.1, 0);
              earRim.rotation.x = Math.PI / 2;
              earRim.rotation.z = Math.PI * 0.7;
              earOuter.add(earRim);

              // Inner ear - softer pink
              const innerGeom = new THREE.CapsuleGeometry(0.07, 0.58, 10, 16);
              const inner = new THREE.Mesh(innerGeom, secondaryMat);
              inner.scale.set(1.1, 1, 0.32);
              inner.position.z = 0.025;
              earOuter.add(inner);

              // Ear tip (more rounded)
              const tip = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 16, 16),
                primaryMat
              );
              tip.scale.set(1.15, 0.85, 0.45);
              tip.position.y = 0.42;
              earOuter.add(tip);

              earOuter.position.set(side * 0.2, 1.55, -0.02);
              earOuter.rotation.z = side * -0.18;
              earOuter.rotation.x = -0.08;
              earGroup.add(earOuter);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Eyes with custom iris color
            [-1, 1].forEach((side) => {
              const eye = createEye(0.9, false, { irisColor: 0x4a3020 });
              eye.position.set(side * 0.19, 1.12, 0.34);
              animal.add(eye);
            });

            // Enhanced Y-shaped nose with nostrils
            const nose = new THREE.Group();
            const noseTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 20, 20),
              getMaterial(0xffb6c1)
            );
            noseTop.scale.set(1.35, 0.72, 1);
            nose.add(noseTop);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.014, 10, 10),
                getMaterial(0xc87090)
              );
              nostril.position.set(side * 0.02, -0.006, 0.025);
              nose.add(nostril);
            });

            // Nose line going down (philtrum)
            const noseLine = new THREE.Mesh(
              new THREE.CylinderGeometry(0.009, 0.014, 0.055, 10),
              getMaterial(0xffb6c1)
            );
            noseLine.position.y = -0.038;
            nose.add(noseLine);

            nose.position.set(0, 1.02, 0.4);
            animal.userData.animationData.nose = nose;
            animal.add(nose);

            // Whiskers (3 per side) - slightly curved
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.001, 0.25, 6),
                  getMaterial(0xffffff)
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.28;
                whisker.rotation.x = (i - 1) * 0.12;
                whisker.position.set(side * 0.2, 1.0 + (i - 1) * 0.028, 0.34);
                animal.add(whisker);
              }
            });

            // Enhanced fluffy tail with color variation
            const tailGroup = new THREE.Group();
            // Core
            const tailCore = new THREE.Mesh(
              new THREE.SphereGeometry(0.11, 20, 20),
              primaryMat
            );
            tailGroup.add(tailCore);

            // Fluffy outer layers with slight color variation
            for (let i = 0; i < 12; i++) {
              const puffSize = 0.055 + Math.random() * 0.025;
              const puff = new THREE.Mesh(
                new THREE.SphereGeometry(puffSize, 12, 12),
                i % 3 === 0 ? secondaryMat : primaryMat
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.065 + Math.random() * 0.02;
              puff.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle * 0.6) * 0.05 + (Math.random() - 0.5) * 0.02,
                Math.sin(angle) * radius
              );
              tailGroup.add(puff);
            }
            tailGroup.position.set(0, 0.5, -0.4);
            animal.add(tailGroup);

            // Legs - back legs larger than front
            // Front legs with paw detail
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.075, 0.16, 10, 14),
                primaryMat
              );
              frontLeg.position.set(side * 0.22, 0.16, 0.22);
              animal.add(frontLeg);

              // Front paw
              const frontPaw = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 12, 12),
                primaryMat
              );
              frontPaw.scale.set(1, 0.6, 1.3);
              frontPaw.position.set(side * 0.22, 0.04, 0.28);
              animal.add(frontPaw);
            });

            // Back legs (much larger) with better definition
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 16, 16),
                primaryMat
              );
              thigh.scale.set(0.9, 1.1, 1);
              thigh.position.set(side * 0.24, 0.25, -0.12);
              animal.add(thigh);

              const backLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.22, 10, 14),
                primaryMat
              );
              backLeg.position.set(side * 0.24, 0.14, -0.08);
              backLeg.rotation.x = 0.35;
              animal.add(backLeg);

              // Back foot - elongated bunny foot
              const backFoot = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.085, 0.2, 10, 14),
                primaryMat
              );
              backFoot.rotation.x = Math.PI / 2;
              backFoot.position.set(side * 0.24, 0.05, 0.08);
              animal.add(backFoot);

              // Foot pad hint
              const footPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 10, 10),
                secondaryMat
              );
              footPad.scale.set(1.2, 0.5, 1.5);
              footPad.position.set(side * 0.24, 0.02, 0.12);
              animal.add(footPad);
            });
          }

          // ============ BEAR - ENHANCED ============
          else if (type === "bear") {
            // Barrel-shaped torso (1.5x wider than tall)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.58, 32, 32),
              primaryMat
            );
            body.scale.set(1.32, 1.0, 1.15);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Enhanced shoulder hump - more prominent (30% larger)
            const hump = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 20, 20),
              primaryMat
            );
            hump.scale.set(1.2, 0.9, 1);
            hump.position.set(0, 0.92, -0.12);
            animal.add(hump);

            // Secondary hump for smooth transition
            const hump2 = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 16, 16),
              primaryMat
            );
            hump2.position.set(0, 1.02, -0.05);
            animal.add(hump2);

            // Belly patch - rounder
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.0, 1.15, 0.52);
            belly.position.set(0, 0.48, 0.28);
            animal.add(belly);

            // Wide, round head with pronounced forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 1.22;
            head.castShadow = true;
            animal.add(head);

            // Cheek puffs for rounder face
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                primaryMat
              );
              cheek.position.set(side * 0.32, 1.12, 0.22);
              animal.add(cheek);
            });

            // Forehead bulge - more subtle
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 18, 18),
              primaryMat
            );
            forehead.position.set(0, 1.48, 0.12);
            animal.add(forehead);

            // Smooth blended muzzle (no box geometry)
            const muzzleBase = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            muzzleBase.scale.set(1.1, 0.85, 0.9);
            muzzleBase.position.set(0, 1.1, 0.42);
            animal.add(muzzleBase);

            const muzzleFront = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 18, 18),
              secondaryMat
            );
            muzzleFront.scale.set(1.0, 0.78, 0.85);
            muzzleFront.position.set(0, 1.1, 0.52);
            animal.add(muzzleFront);

            // Muzzle bridge for smooth transition
            const muzzleBridge = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.08, 0.12, 10, 12),
              secondaryMat
            );
            muzzleBridge.rotation.x = Math.PI / 2;
            muzzleBridge.scale.set(1.2, 1, 0.8);
            muzzleBridge.position.set(0, 1.12, 0.38);
            animal.add(muzzleBridge);

            // Enhanced nose with nostrils
            const nose = new THREE.Group();
            const noseMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.09, 14, 14),
              accentMat
            );
            noseMain.scale.set(1.35, 0.88, 1.0);
            nose.add(noseMain);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.04, -0.01, 0.04);
              nose.add(nostril);
            });
            nose.position.set(0, 1.16, 0.58);
            animal.add(nose);

            // Enhanced ears at 10 and 2 o'clock with depth
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();
              const angle = (side * Math.PI) / 4.2;
              const earRadius = 0.48;

              // Main ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 18, 18),
                primaryMat
              );
              earGroup.add(ear);

              // Ear inner recess (darker)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                secondaryMat
              );
              innerEar.position.z = 0.08;
              earGroup.add(innerEar);

              // Ear cavity shadow
              const earCavity = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 12),
                new THREE.MeshBasicMaterial({
                  color: 0x3a2a20,
                  transparent: true,
                  opacity: 0.3,
                })
              );
              earCavity.position.z = 0.085;
              earGroup.add(earCavity);
              // FIXED: Simple ear position at 10 and 2 o'clock
              earGroup.position.set(side * 0.32, 1.52, 0.05);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Eyes - slightly lower and forward
            [-1, 1].forEach((side) => {
              const eye = createEye(0.7, false, { irisColor: 0x2a1810 });
              eye.position.set(side * 0.22, 1.26, 0.4);
              animal.add(eye);
            });

            // Thick plantigrade legs with enhanced paw pads and curved claws
            const legPositions = [
              { x: -0.38, z: 0.22, front: true },
              { x: 0.38, z: 0.22, front: true },
              { x: -0.32, z: -0.28, front: false },
              { x: 0.32, z: -0.28, front: false },
            ];

            legPositions.forEach((pos) => {
              // Thicker legs with slight curve
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.4, 18),
                primaryMat
              );
              leg.position.set(pos.x, 0.2, pos.z);
              animal.add(leg);

              // Knee/joint bulge
              const knee = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 12, 12),
                primaryMat
              );
              knee.position.set(pos.x, 0.32, pos.z);
              animal.add(knee);

              // Enhanced paw
              const paw = createPaw(0.15, primaryMat, secondaryMat);
              paw.position.set(pos.x, 0.02, pos.z + 0.06);
              animal.add(paw);

              // 5 Curved claws per paw
              for (let c = -2; c <= 2; c++) {
                const clawGroup = new THREE.Group();
                const claw = new THREE.Mesh(
                  new THREE.ConeGeometry(0.02, 0.07, 10),
                  accentMat
                );
                claw.position.y = 0.035;
                clawGroup.add(claw);

                // Claw curve
                clawGroup.rotation.x = -Math.PI / 2 - 0.35;
                clawGroup.rotation.z = c * 0.08;
                clawGroup.position.set(pos.x + c * 0.038, 0.01, pos.z + 0.2);
                animal.add(clawGroup);
              }
            });

            // Head for animation
            animal.userData.animationData.head = head;
          }

          // ============ PENGUIN - CARTOON REDESIGN ============
          else if (type === "penguin") {
            // Rounded egg-shaped body (black outer shell)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.52, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.95);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // LARGE WHITE CIRCULAR BELLY (Center of body - like reference!)
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.44, 32, 32),
              secondaryMat
            );
            // distinct circular shape centered on body
            belly.scale.set(0.95, 1.0, 0.5);
            belly.position.set(0, 0.55, 0.22);
            animal.add(belly);

            // White chest connector (smooth blend to face)
            const chestTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 24, 24),
              secondaryMat
            );
            chestTop.scale.set(0.9, 0.7, 0.4);
            chestTop.position.set(0, 0.88, 0.24);
            animal.add(chestTop);

            // Round head attached to body (black)
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            head.position.y = 1.1;
            animal.add(head);

            // HEART-SHAPED WHITE FACE PATCH (key feature from reference!)
            // Create heart shape using two overlapping circles and a triangle bottom
            const faceGroup = new THREE.Group();

            // Left circle of heart
            const heartLeft = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartLeft.scale.set(1, 1, 0.4);
            heartLeft.position.set(-0.1, 0.08, 0);
            faceGroup.add(heartLeft);

            // Right circle of heart
            const heartRight = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartRight.scale.set(1, 1, 0.4);
            heartRight.position.set(0.1, 0.08, 0);
            faceGroup.add(heartRight);

            // Center fill for heart
            const heartCenter = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              secondaryMat
            );
            heartCenter.scale.set(1.4, 1, 0.4);
            heartCenter.position.set(0, 0.02, 0);
            faceGroup.add(heartCenter);

            // Bottom point of heart (chin area)
            const heartBottom = new THREE.Mesh(
              new THREE.ConeGeometry(0.16, 0.22, 16),
              secondaryMat
            );
            heartBottom.scale.set(1, 1, 0.4);
            heartBottom.rotation.x = Math.PI;
            heartBottom.position.set(0, -0.1, 0);
            faceGroup.add(heartBottom);

            faceGroup.position.set(0, 1.08, 0.28);
            animal.add(faceGroup);

            // LARGE CARTOON EYES (like reference image)
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Large black pupil (cartoon style - fills most of eye)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.075, 18, 18),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.04;
              eyeGroup.add(pupil);

              // Large white highlight (cartoon shine)
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.035, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025 * side, 0.03, 0.08);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.02 * side, -0.02, 0.08);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.12, 1.15, 0.32);
              animal.add(eyeGroup);
            });

            // PINK BLUSH MARKS (like reference image!)
            [-1, 1].forEach((side) => {
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.05, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.6,
                  roughness: 0.8,
                })
              );
              blush.position.set(side * 0.18, 1.02, 0.35);
              animal.add(blush);
            });

            // CUTE ROUNDED ORANGE BEAK (like reference)
            const beakGroup = new THREE.Group();

            // Main beak body - rounded capsule shape
            const beakMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0xf5a623)
            );
            beakMain.scale.set(1.3, 0.8, 1.0);
            beakGroup.add(beakMain);

            // Slight bump on top for cute look
            const beakTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xf5a623)
            );
            beakTop.position.set(0, 0.02, -0.02);
            beakGroup.add(beakTop);

            beakGroup.position.set(0, 0.98, 0.4);
            animal.add(beakGroup);

            // Small flipper wings (like reference - held out slightly)
            [-1, 1].forEach((side) => {
              const flipperGroup = new THREE.Group();

              // Main flipper shape
              const flipper = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.28, 12, 18),
                primaryMat
              );
              flipper.scale.set(1.1, 1, 0.4);
              flipperGroup.add(flipper);

              // Flipper tip
              const flipperTip = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 12, 12),
                primaryMat
              );
              flipperTip.scale.set(1, 0.8, 0.4);
              flipperTip.position.y = -0.16;
              flipperGroup.add(flipperTip);

              flipperGroup.position.set(side * 0.48, 0.55, 0.05);
              flipperGroup.rotation.z = side * 0.45;
              animal.add(flipperGroup);
            });

            // Cute orange webbed feet
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Main foot oval
              const footBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                getMaterial(0xf5a623)
              );
              footBase.scale.set(1.3, 0.3, 1.6);
              footGroup.add(footBase);

              // Three rounded toes
              for (let i = -1; i <= 1; i++) {
                const toe = new THREE.Mesh(
                  new THREE.SphereGeometry(0.035, 10, 10),
                  getMaterial(0xf5a623)
                );
                toe.scale.set(1, 0.5, 1.5);
                toe.position.set(i * 0.05, 0, 0.1);
                footGroup.add(toe);
              }

              footGroup.position.set(side * 0.18, 0.02, 0.12);
              animal.add(footGroup);
            });

            // Animation reference
            animal.userData.animationData.body = animal;
          }

          // ============ FOX - ENHANCED ============
          else if (type === "fox") {
            // Slender, agile body
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.3, 0.52, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.88);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Enhanced chest fluff - more prominent
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.92, 1.15, 0.65);
            chest.position.set(0, 0.58, 0.2);
            animal.add(chest);

            // Additional chest fluff layers
            const chestFluff = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 14, 14),
              secondaryMat
            );
            chestFluff.position.set(0, 0.72, 0.18);
            animal.add(chestFluff);

            // Diamond/triangular head - slightly larger
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.34, 32, 32),
              primaryMat
            );
            head.scale.set(1.02, 0.92, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // White cheek patches (fox marking)
            [-1, 1].forEach((side) => {
              const cheekPatch = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              cheekPatch.scale.set(1.2, 0.9, 0.5);
              cheekPatch.position.set(side * 0.18, 0.95, 0.22);
              animal.add(cheekPatch);
            });

            // Enhanced long pointed snout with gradient
            const snoutBase = new THREE.Mesh(
              new THREE.ConeGeometry(0.14, 0.25, 18),
              primaryMat
            );
            snoutBase.rotation.x = Math.PI / 2;
            snoutBase.position.set(0, 0.94, 0.32);
            animal.add(snoutBase);

            const snoutTip = new THREE.Mesh(
              new THREE.ConeGeometry(0.1, 0.2, 16),
              secondaryMat
            );
            snoutTip.rotation.x = Math.PI / 2;
            snoutTip.position.set(0, 0.92, 0.45);
            animal.add(snoutTip);

            // Nose with nostrils
            const noseGroup = new THREE.Group();
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.045, 14, 14),
              accentMat
            );
            noseGroup.add(nose);

            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.02, -0.01, 0.02);
              noseGroup.add(nostril);
            });
            noseGroup.position.set(0, 0.92, 0.58);
            animal.add(noseGroup);

            // Facial tear lines (dark markings from eye to snout)
            [-1, 1].forEach((side) => {
              const tearLine = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.012, 0.15, 6, 10),
                getMaterial(0x2a1810)
              );
              tearLine.rotation.x = 0.8;
              tearLine.rotation.z = side * 0.25;
              tearLine.position.set(side * 0.1, 0.98, 0.32);
              animal.add(tearLine);
            });

            // Enhanced triangular ears with fur tufts
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.13, 0.42, 5),
                primaryMat
              );
              ear.position.y = 0.16;
              earGroup.add(ear);

              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.32, 5),
                secondaryMat
              );
              innerEar.position.set(0, 0.13, 0.035);
              earGroup.add(innerEar);

              // Black ear tips
              const earTip = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, 0.1, 5),
                accentMat
              );
              earTip.position.y = 0.35;
              earGroup.add(earTip);

              earGroup.position.set(side * 0.2, 1.28, -0.02);
              earGroup.rotation.z = side * -0.15;
              animal.add(earGroup);
            });

            // Slit pupil eyes for fox
            [-1, 1].forEach((side) => {
              const eye = createEye(0.82, true, { irisColor: 0xc4a040 });
              eye.position.set(side * 0.15, 1.06, 0.3);
              animal.add(eye);
            });

            // Enhanced bushy tail (12 segments + fur overlays)
            const tailGroup = new THREE.Group();

            const tailSegments = 12;
            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseSize = 0.15 - t * 0.07;
              const isWhiteTip = t >= 0.72;

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseSize, 14, 12),
                isWhiteTip ? secondaryMat : primaryMat
              );

              const curve = Math.sin(t * Math.PI * 0.6) * 0.38;
              segment.position.y = i * 0.085;
              segment.position.z = -0.12 - curve;
              segment.position.x = Math.sin(t * Math.PI * 0.3) * 0.055;
              tailGroup.add(segment);

              if (i % 2 === 0 && i < tailSegments - 2) {
                for (let f = 0; f < 5; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(
                      baseSize * 0.55 + Math.random() * 0.02,
                      8,
                      8
                    ),
                    isWhiteTip ? secondaryMat : primaryMat
                  );
                  const angle = (f / 5) * Math.PI * 2 + Math.random() * 0.3;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseSize * 0.72,
                    segment.position.y + (Math.random() - 0.5) * 0.035,
                    segment.position.z + Math.sin(angle) * baseSize * 0.52
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.4, -0.2);
            tailGroup.rotation.x = -0.28;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Thin black "sock" legs with better definition
            const legPositions = [
              { x: -0.16, z: 0.16 },
              { x: 0.16, z: 0.16 },
              { x: -0.13, z: -0.2 },
              { x: 0.13, z: -0.2 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.32, 10, 14),
                accentMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              // Dainty paw with toe details
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                accentMat
              );
              paw.scale.set(1, 0.58, 1.35);
              paw.position.set(pos.x, 0.03, pos.z + 0.04);
              animal.add(paw);
            });
          }

          // ============ ELEPHANT ============
          else if (type === "elephant") {
            // Massive barrel body with saggy belly
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.6, 32, 32),
              primaryMat
            );
            body.scale.set(1.1, 0.9, 1.3);
            body.position.y = 0.65;
            body.castShadow = true;
            animal.add(body);

            // Saggy belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              primaryMat
            );
            belly.position.set(0, 0.4, 0);
            animal.add(belly);

            // Domed head with forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.45, 32, 32),
              primaryMat
            );
            head.scale.set(1.0, 1.1, 1.0);
            head.position.set(0, 1.25, 0.25);
            animal.add(head);

            // Domed forehead
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 16, 16),
              primaryMat
            );
            forehead.position.set(0, 1.55, 0.2);
            animal.add(forehead);

            // LARGE fan-shaped ears (60% of body height) - FIXED visibility
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              // Main ear shape - using flattened sphere for 3D visibility
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.45,
                  24,
                  16,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.6
                ),
                primaryMat
              );
              ear.scale.set(1, 1.2, 0.15); // Wide, tall, thin
              ear.rotation.y = side * 0.2;
              earGroup.add(ear);

              // Inner ear (pinkish)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.35,
                  20,
                  12,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.5
                ),
                getMaterial(0xd4a5a5) // Pink inner ear
              );
              innerEar.scale.set(0.9, 1, 0.1);
              innerEar.position.set(side * -0.02, -0.05, 0.05);
              innerEar.rotation.y = side * 0.2;
              earGroup.add(innerEar);

              earGroup.position.set(side * 0.55, 1.25, 0.1);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Smooth trunk using TubeGeometry with natural S-curve
            const trunkGroup = new THREE.Group();

            // Define trunk path as smooth S-curve
            const trunkPath = new THREE.CatmullRomCurve3([
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(0, -0.15, 0.08),
              new THREE.Vector3(0, -0.35, 0.18),
              new THREE.Vector3(0, -0.55, 0.25),
              new THREE.Vector3(0, -0.75, 0.2),
              new THREE.Vector3(0, -0.9, 0.1),
            ]);

            // Create tapered tube geometry
            const radiusSegments = 8;
            const tubularSegments = 24;
            const trunkRadii = [];
            for (let i = 0; i <= tubularSegments; i++) {
              const t = i / tubularSegments;
              trunkRadii.push(0.12 - t * 0.08); // Taper from 0.12 to 0.04
            }

            // Note: THREE.TubeGeometry doesn't support variable radius,
            // so we use multiple scaled torus/cylinder sections for smooth look
            const trunkSegments = 16;
            for (let i = 0; i < trunkSegments; i++) {
              const t = i / (trunkSegments - 1);
              const radius = 0.11 - t * 0.07;
              const point = trunkPath.getPointAt(t);

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 16, 12),
                primaryMat
              );
              segment.scale.set(1, 0.8, 1); // Slightly flatten for organic look
              segment.position.copy(point);
              trunkGroup.add(segment);
            }

            // Trunk tip with nostril openings
            const tipPoint = trunkPath.getPointAt(1);
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.TorusGeometry(0.02, 0.008, 8, 12),
                getMaterial(0x5a6a7a) // Darker for depth
              );
              nostril.position.set(
                side * 0.025,
                tipPoint.y - 0.02,
                tipPoint.z + 0.03
              );
              nostril.rotation.y = Math.PI / 2;
              trunkGroup.add(nostril);
            });

            trunkGroup.position.set(0, 1.15, 0.55);
            animal.userData.animationData.trunk = trunkGroup;
            animal.add(trunkGroup);

            // Curved tusks (outward and upward)
            [-1, 1].forEach((side) => {
              const tuskGroup = new THREE.Group();

              for (let i = 0; i < 5; i++) {
                const t = i / 4;
                const tuskSeg = new THREE.Mesh(
                  new THREE.SphereGeometry(0.04 - t * 0.02, 8, 8),
                  secondaryMat
                );
                tuskSeg.position.x = side * t * 0.1;
                tuskSeg.position.y = -t * 0.1 + t * t * 0.15; // Curve up
                tuskSeg.position.z = t * 0.08;
                tuskGroup.add(tuskSeg);
              }

              tuskGroup.position.set(side * 0.15, 1.0, 0.6);
              animal.add(tuskGroup);
            });

            // Enhanced visible eyes with eyelid ridges
            [-1, 1].forEach((side) => {
              // Eyelid ridge/brow for definition
              const browRidge = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.1, 8, 12),
                primaryMat
              );
              browRidge.position.set(side * 0.28, 1.42, 0.48);
              browRidge.rotation.z = side * 0.3;
              animal.add(browRidge);

              // Eye socket depression
              const eyeSocket = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 12, 12),
                getMaterial(0x5a6a7a)
              );
              eyeSocket.scale.set(1.2, 1, 0.6);
              eyeSocket.position.set(side * 0.28, 1.35, 0.48);
              animal.add(eyeSocket);

              // Larger, more visible eye
              const eye = createEye(0.75, false, { irisColor: 0x3a2a20 });
              eye.position.set(side * 0.28, 1.35, 0.52);
              animal.add(eye);
            });

            // Column-like legs with toenails
            const legPositions = [
              { x: -0.35, z: 0.35 },
              { x: 0.35, z: 0.35 },
              { x: -0.3, z: -0.35 },
              { x: 0.3, z: -0.35 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.16, 0.5, 16),
                primaryMat
              );
              leg.position.set(pos.x, 0.25, pos.z);
              animal.add(leg);

              // Foot
              const foot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.16, 0.18, 0.08, 16),
                primaryMat
              );
              foot.position.set(pos.x, 0.04, pos.z);
              animal.add(foot);

              // Toenails
              for (let i = -1; i <= 1; i++) {
                const nail = new THREE.Mesh(
                  new THREE.SphereGeometry(0.03, 8, 8),
                  secondaryMat
                );
                nail.position.set(pos.x + i * 0.06, 0.02, pos.z + 0.15);
                animal.add(nail);
              }
            });

            // Thin tail with tuft
            const tailGroup = new THREE.Group();

            const tailBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.03, 0.4, 8),
              primaryMat
            );
            tailBase.position.y = -0.15;
            tailGroup.add(tailBase);

            const tuft = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 12, 12),
              primaryMat
            );
            tuft.scale.set(0.8, 1.5, 0.8);
            tuft.position.y = -0.4;
            tailGroup.add(tuft);

            tailGroup.position.set(0, 0.5, -0.65);
            tailGroup.rotation.x = 0.3;
            animal.add(tailGroup);
          }

          // ============ CAT - ENHANCED ============
          else if (type === "cat") {
            // Sleek body - slightly more elegant
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.32, 0.48, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.92);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Fluffy chest
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.95, 1.1, 0.65);
            chest.position.set(0, 0.58, 0.17);
            animal.add(chest);

            // Head with better cheekbone structure
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.08, 1.0, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // Cheekbones for cat-like face
            [-1, 1].forEach((side) => {
              const cheekbone = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                primaryMat
              );
              cheekbone.scale.set(1.2, 0.8, 0.6);
              cheekbone.position.set(side * 0.2, 0.95, 0.18);
              animal.add(cheekbone);
            });

            // Enhanced muzzle with whisker pads
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.13, 18, 18),
              secondaryMat
            );
            muzzle.scale.set(1, 0.72, 0.82);
            muzzle.position.set(0, 0.93, 0.27);
            animal.add(muzzle);

            // Whisker pads (puffy areas on either side of nose)
            [-1, 1].forEach((side) => {
              const whiskerPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                secondaryMat
              );
              whiskerPad.scale.set(1.2, 0.9, 1);
              whiskerPad.position.set(side * 0.07, 0.91, 0.32);
              animal.add(whiskerPad);
            });

            // Pink nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 14, 14),
              getMaterial(0xffb6c1)
            );
            nose.scale.set(1.1, 0.85, 1);
            nose.position.set(0, 0.96, 0.35);
            animal.add(nose);

            // Enhanced whiskers (curved)
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.002, 0.22, 6),
                  secondaryMat
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.22;
                whisker.rotation.x = (i - 1) * 0.08;
                whisker.position.set(side * 0.18, 0.93 + (i - 1) * 0.032, 0.28);
                animal.add(whisker);
              }
            });

            // Enhanced pointed ears with fur tufts
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              // Main ear
              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.11, 0.24, 5),
                primaryMat
              );
              ear.position.set(side * 0.2, 1.32, 0);
              ear.rotation.z = side * -0.18;
              earGroup.add(ear);

              // Inner pink ear
              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.065, 0.17, 5),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.2, 1.3, 0.035);
              innerEar.rotation.z = side * -0.18;
              earGroup.add(innerEar);

              // Fur tuft at ear tip
              const earTuft = new THREE.Mesh(
                new THREE.ConeGeometry(0.025, 0.06, 4),
                primaryMat
              );
              earTuft.position.set(side * 0.2, 1.45, 0);
              earTuft.rotation.z = side * -0.2;
              earGroup.add(earTuft);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Enhanced slit pupil eyes with green/amber iris
            [-1, 1].forEach((side) => {
              const eye = createEye(0.92, true, { irisColor: 0x7cb342 });
              eye.position.set(side * 0.14, 1.06, 0.27);
              animal.add(eye);
            });

            // Enhanced long curved tail (12 segments + fur)
            const tailGroup = new THREE.Group();
            const tailSegments = 14;

            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseRadius = 0.058 - t * 0.028;
              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseRadius, 12, 10),
                primaryMat
              );
              segment.position.y = i * 0.072;
              segment.position.z = -Math.sin(t * Math.PI) * 0.2;
              segment.position.x = Math.sin(t * Math.PI * 0.55) * 0.13;
              tailGroup.add(segment);

              if (i % 3 === 0 && i < tailSegments - 1) {
                for (let f = 0; f < 3; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(baseRadius * 0.52, 6, 6),
                    primaryMat
                  );
                  const angle = (f / 3) * Math.PI * 2;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseRadius * 0.82,
                    segment.position.y,
                    segment.position.z + Math.sin(angle) * baseRadius * 0.62
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.5, -0.24);
            tailGroup.rotation.x = -0.58;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Enhanced legs with paw pads
            const legPositions = [
              { x: -0.16, z: 0.14 },
              { x: 0.16, z: 0.14 },
              { x: -0.13, z: -0.16 },
              { x: 0.13, z: -0.16 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.27, 10, 14),
                primaryMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              const paw = createPaw(0.065, primaryMat, getMaterial(0xffb6c1));
              paw.position.set(pos.x, 0.02, pos.z + 0.025);
              animal.add(paw);
            });
          }

          // ============ OWL ============
          else if (type === "owl") {
            // Round body (1:1 with head)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.position.y = 0.5;
            body.castShadow = true;
            animal.add(body);

            // Belly feathers (layered discs)
            for (let i = 0; i < 4; i++) {
              const featherRow = new THREE.Mesh(
                new THREE.TorusGeometry(0.25 - i * 0.04, 0.03, 8, 24),
                secondaryMat
              );
              featherRow.rotation.x = Math.PI / 2;
              featherRow.position.set(0, 0.6 - i * 0.1, 0.2);
              animal.add(featherRow);
            }

            // Large round head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 32, 32),
              primaryMat
            );
            head.position.y = 1.05;
            animal.userData.animationData.head = head;
            animal.add(head);

            // Facial disc
            const facialDisc = new THREE.Mesh(
              new THREE.CircleGeometry(0.35, 32),
              secondaryMat
            );
            facialDisc.position.set(0, 1.05, 0.2);
            animal.add(facialDisc);

            // HUGE forward-facing eyes - FIXED position forward
            [-1, 1].forEach((side) => {
              const eye = createOwlEye(1.5);
              eye.position.set(side * 0.14, 1.1, 0.38);
              animal.add(eye);
            });

            // Small hooked beak
            const beak = new THREE.Mesh(
              new THREE.ConeGeometry(0.05, 0.1, 8),
              getMaterial(0x8b7355)
            );
            beak.rotation.x = Math.PI / 2 + 0.3;
            beak.position.set(0, 0.98, 0.32);
            animal.add(beak);

            // Ear tufts - ENLARGED for visibility
            [-1, 1].forEach((side) => {
              const tuft = new THREE.Group();

              // More feathers, larger sizes
              for (let i = 0; i < 4; i++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.04, 0.2 - i * 0.03, 6),
                  primaryMat
                );
                feather.position.set(i * side * 0.025, i * 0.05, 0);
                tuft.add(feather);
              }

              tuft.position.set(side * 0.28, 1.42, -0.02);
              tuft.rotation.z = side * -0.35;
              animal.add(tuft);
            });

            // Enhanced wings with feather details
            [-1, 1].forEach((side) => {
              const wingGroup = new THREE.Group();

              // Main wing body
              const wingBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                primaryMat
              );
              wingBase.scale.set(0.4, 0.8, 0.6);
              wingGroup.add(wingBase);

              // Feather layers (3 rows)
              for (let row = 0; row < 3; row++) {
                const featherRow = new THREE.Mesh(
                  new THREE.TorusGeometry(
                    0.12 - row * 0.025,
                    0.02,
                    6,
                    12,
                    Math.PI * 0.8
                  ),
                  getMaterial(row === 0 ? 0x654321 : config.primaryColor)
                );
                featherRow.rotation.set(0, (side * Math.PI) / 2, Math.PI);
                featherRow.position.set(side * 0.02, -0.1 - row * 0.08, 0.05);
                wingGroup.add(featherRow);
              }

              // Primary flight feathers at tip (5 feathers)
              for (let f = 0; f < 5; f++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.015, 0.12, 4),
                  getMaterial(f === 0 ? 0x4a3728 : config.primaryColor)
                );
                feather.rotation.z = side * (0.3 + f * 0.15);
                feather.rotation.x = 0.2;
                feather.position.set(
                  side * (0.05 + f * 0.02),
                  -0.35 + f * 0.03,
                  0.1 - f * 0.02
                );
                wingGroup.add(feather);
              }

              wingGroup.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wingGroup);
            });

            // Feet/talons
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Three forward talons
              for (let i = -1; i <= 1; i++) {
                const talon = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.025, 0.1, 6, 8),
                  getMaterial(0x8b7355)
                );
                talon.position.set(i * 0.04, 0, 0.05);
                talon.rotation.x = 0.3;
                footGroup.add(talon);
              }

              // One back talon
              const backTalon = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.025, 0.08, 6, 8),
                getMaterial(0x8b7355)
              );
              backTalon.position.set(0, 0, -0.05);
              backTalon.rotation.x = -0.3;
              footGroup.add(backTalon);

              footGroup.position.set(side * 0.12, 0.1, 0.05);
              animal.add(footGroup);
            });
          }

          // ============ PANDA - CARTOON REDESIGN ============
          else if (type === "panda") {
            // Rounded white body (upright standing pose)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.9);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Large round white head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 32, 32),
              primaryMat
            );
            head.position.y = 1.18;
            animal.add(head);

            // BLACK EARS WITH PINK INNER EAR (like reference!)
            [-1, 1].forEach((side) => {
              // Main black ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 18, 18),
                secondaryMat
              );
              ear.position.set(side * 0.32, 1.52, -0.02);
              animal.add(ear);

              // Pink inner ear (key feature from reference!)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 14, 14),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.32, 1.52, 0.06);
              animal.add(innerEar);
            });

            // TILTED BLACK EYE PATCHES (like reference - diagonal orientation)
            [-1, 1].forEach((side) => {
              // Main black eye patch - larger and tilted
              const patch = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 20, 20),
                secondaryMat
              );
              patch.scale.set(1.4, 1.7, 0.4);
              patch.position.set(side * 0.18, 1.2, 0.26);
              // Tilt outer corners upward (panda signature look)
              patch.rotation.z = side * 0.4;
              animal.add(patch);

              // LARGE EXPRESSIVE BLUE EYES (like reference!)
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.15, 0.55);
              eyeGroup.add(sclera);

              // Blue iris (like reference image!)
              const iris = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 18, 18),
                new THREE.MeshPhysicalMaterial({
                  color: 0x4a90d9,
                  roughness: 0.1,
                  clearcoat: 0.5,
                })
              );
              iris.scale.set(1, 1.1, 0.6);
              iris.position.z = 0.03;
              eyeGroup.add(iris);

              // Black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.05;
              eyeGroup.add(pupil);

              // Large white highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.02 * side, 0.02, 0.065);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.015 * side, -0.015, 0.065);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.17, 1.22, 0.36);
              animal.add(eyeGroup);
            });

            // White muzzle area
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              primaryMat
            );
            muzzle.scale.set(1, 0.75, 0.65);
            muzzle.position.set(0, 1.02, 0.35);
            animal.add(muzzle);

            // Small black nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 14, 14),
              secondaryMat
            );
            nose.scale.set(1.3, 0.9, 0.9);
            nose.position.set(0, 1.04, 0.44);
            animal.add(nose);

            // OPEN SMILING MOUTH (like reference with visible tongue!)
            const mouthGroup = new THREE.Group();

            // Mouth opening (dark inside)
            const mouthOpen = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0x2a1a1a)
            );
            mouthOpen.scale.set(1.5, 0.8, 0.5);
            mouthGroup.add(mouthOpen);

            // Pink tongue inside mouth
            const tongue = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xff6b8a)
            );
            tongue.scale.set(1.3, 0.7, 0.8);
            tongue.position.set(0, -0.015, 0.015);
            mouthGroup.add(tongue);

            mouthGroup.position.set(0, 0.93, 0.42);
            animal.add(mouthGroup);

            // BLACK ARMS (like reference - holding down at sides)
            [-1, 1].forEach((side) => {
              const armGroup = new THREE.Group();

              // Upper arm
              const arm = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.28, 10, 14),
                secondaryMat
              );
              armGroup.add(arm);

              // Paw at end
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              paw.position.y = -0.18;
              armGroup.add(paw);

              armGroup.position.set(side * 0.48, 0.48, 0.08);
              armGroup.rotation.z = side * 0.15;
              animal.add(armGroup);
            });

            // BLACK LEGS (like reference - standing upright)
            [-1, 1].forEach((side) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.13, 0.22, 10, 14),
                secondaryMat
              );
              leg.position.set(side * 0.22, 0.18, 0.02);
              animal.add(leg);

              const foot = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 14, 14),
                secondaryMat
              );
              foot.scale.set(1.1, 0.55, 1.35);
              foot.position.set(side * 0.22, 0.06, 0.08);
              animal.add(foot);
            });

            // Small white fluffy tail
            const pandaTail = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            pandaTail.position.set(0, 0.5, -0.42);
            animal.add(pandaTail);

            // Animation references
            animal.userData.animationData.head = head;
            animal.userData.animationData.muzzle = muzzle;
          }

          // ============ DUCK ============
          else if (type === "duck") {
            // Compact oval body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.45;
            body.castShadow = true;
            animal.add(body);

            // Round head with slight crest
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 32, 32),
              primaryMat
            );
            head.position.set(0, 0.95, 0.2);
            animal.userData.animationData.head = head;
            animal.add(head);

            // Crest
            const crest = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            crest.position.set(0, 1.18, 0.1);
            animal.add(crest);

            // Rounded duck bill (replaces angular boxes)
            const beakGroup = new THREE.Group();

            // Upper bill - flattened capsule shape
            const beakUpper = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
              getMaterial(config.accentColor)
            );
            beakUpper.scale.set(1.4, 0.35, 1);
            beakUpper.rotation.x = Math.PI / 2;
            beakUpper.position.set(0, 0.02, 0.12);
            beakGroup.add(beakUpper);

            // Lower bill - slightly smaller
            const beakLower = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.05, 0.12, 8, 12),
              getMaterial(config.accentColor)
            );
            beakLower.scale.set(1.3, 0.3, 0.9);
            beakLower.rotation.x = Math.PI / 2;
            beakLower.position.set(0, -0.02, 0.1);
            beakGroup.add(beakLower);

            // Spatula tip (rounded end)
            const beakTip = new THREE.Mesh(
              new THREE.SphereGeometry(0.055, 12, 12),
              getMaterial(config.accentColor)
            );
            beakTip.scale.set(1.5, 0.4, 1);
            beakTip.position.set(0, 0, 0.2);
            beakGroup.add(beakTip);

            // Nail/tip marking
            const beakNail = new THREE.Mesh(
              new THREE.SphereGeometry(0.02, 8, 8),
              getMaterial(0x1a1a1a)
            );
            beakNail.scale.set(1.2, 0.8, 1);
            beakNail.position.set(0, 0.01, 0.24);
            beakGroup.add(beakNail);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 6, 6),
                getMaterial(0x1a1a1a)
              );
              nostril.position.set(side * 0.03, 0.025, 0.08);
              beakGroup.add(nostril);
            });

            beakGroup.position.set(0, 0.92, 0.32);
            animal.add(beakGroup);

            // FIXED: Larger, more visible eyes on head
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // White sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 16, 16),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Black pupil (large for cartoon look)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.75);
              pupil.position.z = 0.025;
              eyeGroup.add(pupil);

              // White highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.018, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.015 * side, 0.018, 0.05);
              eyeGroup.add(highlight);

              // Position on head - forward facing
              eyeGroup.position.set(side * 0.12, 0.98, 0.42);
              animal.add(eyeGroup);
            });

            // Wings tucked at sides
            [-1, 1].forEach((side) => {
              const wing = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                primaryMat
              );
              wing.scale.set(0.35, 0.6, 0.9);
              wing.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wing);
            });

            // Tail feathers pointing up
            const tailGroup = new THREE.Group();
            for (let i = -1; i <= 1; i++) {
              const feather = new THREE.Mesh(
                new THREE.ConeGeometry(0.04, 0.15, 6),
                primaryMat
              );
              feather.position.set(i * 0.05, 0.05, 0);
              feather.rotation.x = -0.5;
              tailGroup.add(feather);
            }
            tailGroup.position.set(0, 0.45, -0.45);
            animal.add(tailGroup);

            // Enhanced webbed feet with membrane
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Rounded foot base (replaces box)
              const footBase = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.04, 0.06, 8, 8),
                getMaterial(config.accentColor)
              );
              footBase.rotation.x = Math.PI / 2;
              footBase.scale.set(1.4, 0.3, 1);
              footGroup.add(footBase);

              // Three toes with webbing between them
              const toePositions = [-0.045, 0, 0.045];
              toePositions.forEach((xPos, idx) => {
                // Toe
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.018, 0.08, 6, 8),
                  getMaterial(config.accentColor)
                );
                toe.rotation.x = -Math.PI / 2 + 0.1;
                toe.position.set(xPos, 0.005, 0.09);
                footGroup.add(toe);

                // Webbing membrane between toes (triangular shape)
                if (idx < toePositions.length - 1) {
                  const webShape = new THREE.Shape();
                  webShape.moveTo(0, 0);
                  webShape.lineTo(0.04, 0.08);
                  webShape.lineTo(-0.04, 0.08);
                  webShape.lineTo(0, 0);

                  const webGeom = new THREE.ShapeGeometry(webShape);
                  const web = new THREE.Mesh(
                    webGeom,
                    getMaterial(config.accentColor, {
                      transparent: true,
                      opacity: 0.85,
                      side: THREE.DoubleSide,
                    })
                  );
                  web.rotation.x = -Math.PI / 2 + 0.15;
                  web.position.set(xPos + 0.022, 0.002, 0.05);
                  footGroup.add(web);
                }
              });

              footGroup.position.set(side * 0.15, 0.02, 0.12);
              animal.add(footGroup);
            });
          }

          // ============ FROG ============
          else if (type === "frog") {
            // Wide flat body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1.2, 0.7, 1.0);
            body.position.y = 0.35;
            body.castShadow = true;
            animal.add(body);

            // Spots and warts on back (darker green spots)
            const spotPositions = [
              { x: -0.15, y: 0.45, z: -0.1 },
              { x: 0.12, y: 0.48, z: -0.08 },
              { x: 0.0, y: 0.5, z: -0.15 },
              { x: -0.2, y: 0.38, z: 0.05 },
              { x: 0.18, y: 0.4, z: 0.08 },
              { x: -0.08, y: 0.42, z: 0.12 },
              { x: 0.1, y: 0.35, z: -0.2 },
            ];
            spotPositions.forEach((pos) => {
              const spot = new THREE.Mesh(
                new THREE.SphereGeometry(0.04 + Math.random() * 0.02, 8, 8),
                getMaterial(0x228b22) // Darker forest green
              );
              spot.scale.set(1.2, 0.6, 1.2);
              spot.position.set(pos.x, pos.y, pos.z);
              animal.add(spot);
            });

            // Small wart bumps
            for (let i = 0; i < 12; i++) {
              const wart = new THREE.Mesh(
                new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
                getMaterial(0x2e8b2e)
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.3 + Math.random() * 0.1;
              wart.position.set(
                Math.cos(angle) * radius * 0.8,
                0.4 + Math.random() * 0.1,
                Math.sin(angle) * radius * 0.6 - 0.05
              );
              animal.add(wart);
            }

            // Belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.1, 0.6, 0.8);
            belly.position.set(0, 0.3, 0.15);
            animal.add(belly);

            // Wide flat head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.3, 0.8, 1.0);
            head.position.set(0, 0.55, 0.25);
            animal.add(head);

            // HUGE bulging eyes on top - ENHANCED
            [-1, 1].forEach((side) => {
              // Larger eye bulge
              const eyeBulge = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 18, 18),
                primaryMat
              );
              eyeBulge.position.set(side * 0.22, 0.82, 0.22);
              animal.add(eyeBulge);

              // Eye shadow ring
              const eyeShadow = new THREE.Mesh(
                new THREE.TorusGeometry(0.1, 0.015, 8, 20),
                getMaterial(0x228b22)
              );
              eyeShadow.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeShadow);

              // Larger eye group
              const eyeGroup = new THREE.Group();
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 18, 18),
                SPECIAL_MATERIALS.eyeWhite
              );
              eyeGroup.add(sclera);

              // Golden iris ring (frog style)
              const irisRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.05, 0.025, 10, 20),
                getMaterial(0xc4a020)
              );
              irisRing.position.z = 0.06;
              eyeGroup.add(irisRing);

              // Larger black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.position.z = 0.075;
              eyeGroup.add(pupil);

              // Specular highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025, 0.03, 0.1);
              eyeGroup.add(highlight);

              eyeGroup.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeGroup);
            });

            // Wide mouth line
            const mouth = new THREE.Mesh(
              new THREE.TorusGeometry(0.2, 0.015, 8, 24, Math.PI),
              getMaterial(0x228b22)
            );
            mouth.rotation.x = Math.PI;
            mouth.position.set(0, 0.45, 0.42);
            animal.add(mouth);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 8, 8),
                getMaterial(0x228b22)
              );
              nostril.position.set(side * 0.08, 0.6, 0.48);
              animal.add(nostril);
            });

            // Front legs
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
                primaryMat
              );
              frontLeg.position.set(side * 0.35, 0.2, 0.2);
              frontLeg.rotation.z = side * 0.5;
              animal.add(frontLeg);

              // Front foot with webbing
              const footGroup = new THREE.Group();
              for (let i = 0; i < 3; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.015, 0.06, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1) * 0.03, 0, 0.03);
                footGroup.add(toe);
              }
              footGroup.position.set(side * 0.42, 0.1, 0.25);
              animal.add(footGroup);
            });

            // Long folded back legs
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.1, 0.2, 8, 12),
                primaryMat
              );
              thigh.position.set(side * 0.3, 0.3, -0.15);
              thigh.rotation.z = side * -0.8;
              thigh.rotation.x = 0.3;
              animal.add(thigh);

              // Shin (folded back)
              const shin = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.07, 0.2, 8, 12),
                primaryMat
              );
              shin.position.set(side * 0.45, 0.2, -0.05);
              shin.rotation.z = side * 0.5;
              animal.add(shin);

              // Webbed back foot
              const backFootGroup = new THREE.Group();
              for (let i = 0; i < 4; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.02, 0.1, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1.5) * 0.04, 0, 0.05);
                toe.rotation.x = 0.3;
                backFootGroup.add(toe);
              }
              // Webbing
              const webbing = new THREE.Mesh(
                new THREE.CircleGeometry(0.08, 8),
                primaryMat
              );
              webbing.rotation.x = -Math.PI / 2 + 0.3;
              webbing.position.y = -0.02;
              backFootGroup.add(webbing);

              backFootGroup.position.set(side * 0.5, 0.08, 0.1);
              animal.add(backFootGroup);
            });

            // Throat for pulse animation
            const throat = new THREE.Mesh(
              new THREE.SphereGeometry(0.12, 16, 16),
              secondaryMat
            );
            throat.scale.set(1, 0.6, 0.8);
            throat.position.set(0, 0.35, 0.35);
            animal.userData.animationData.throat = throat;
            animal.add(throat);
          }

          return animal;
        }

        // ==========================================
        // ROOM SYSTEM - 3D ENVIRONMENT
        // ==========================================

        // Room configuration
        const ROOM_CONFIG = {
          living: {
            name: "Living Room",
            size: { x: 10, y: 4, z: 10 },
            floorColor: 0x8b7355, // Warm wood
            wallColor: 0xfff8e7, // Cream
            accentColor: 0xd4a574,
            animals: ["bunny", "cat", "bear"],
          },
          bedroom: {
            name: "Bedroom",
            size: { x: 8, y: 3.5, z: 8 },
            floorColor: 0x6b5b7a, // Purple carpet
            wallColor: 0xe8e4f0, // Soft lavender
            accentColor: 0x9b8ab8,
            animals: ["owl", "panda", "fox"],
          },
          garden: {
            name: "Garden",
            size: { x: 12, y: 6, z: 12 },
            floorColor: 0x4a7c4e, // Grass green
            wallColor: 0x87ceeb, // Sky blue (open sky)
            accentColor: 0x8fbc8f,
            animals: ["penguin", "duck", "frog", "elephant"],
          },
        };

        // Room class
        class Room {
          constructor(config, key) {
            this.config = config;
            this.key = key;
            this.group = new THREE.Group();
            this.animals = [];
            this.createRoom();
          }

          createRoom() {
            const { size, floorColor, wallColor } = this.config;

            // Floor
            const floorGeo = new THREE.PlaneGeometry(size.x, size.z);
            const floorMat = new THREE.MeshPhysicalMaterial({
              color: floorColor,
              roughness: 0.7,
              metalness: 0,
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            this.group.add(floor);

            // Contact shadow in center
            const shadowGeo = new THREE.CircleGeometry(1.5, 32);
            const shadowMat = new THREE.MeshBasicMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.25,
              depthWrite: false,
            });
            const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
            shadowMesh.rotation.x = -Math.PI / 2;
            shadowMesh.position.y = 0.01;
            this.group.add(shadowMesh);

            // Walls (only for indoor rooms)
            if (this.key !== "garden") {
              this.createWalls(size, wallColor);
            } else {
              // Garden has sky dome instead
              this.createSkyDome();
            }
          }

          createWalls(size, wallColor) {
            const wallMat = new THREE.MeshPhysicalMaterial({
              color: wallColor,
              roughness: 0.9,
              side: THREE.DoubleSide,
            });

            // Back wall
            const backWall = new THREE.Mesh(
              new THREE.PlaneGeometry(size.x, size.y),
              wallMat
            );
            backWall.position.set(0, size.y / 2, -size.z / 2);
            this.group.add(backWall);

            // Side walls
            [-1, 1].forEach((side) => {
              const sideWall = new THREE.Mesh(
                new THREE.PlaneGeometry(size.z, size.y),
                wallMat
              );
              sideWall.position.set((side * size.x) / 2, size.y / 2, 0);
              sideWall.rotation.y = (side * Math.PI) / 2;
              this.group.add(sideWall);
            });
          }

          createSkyDome() {
            // Simple sky gradient for garden
            const skyGeo = new THREE.SphereGeometry(
              15,
              32,
              16,
              0,
              Math.PI * 2,
              0,
              Math.PI / 2
            );
            const skyMat = new THREE.MeshBasicMaterial({
              color: 0x87ceeb,
              side: THREE.BackSide,
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            this.group.add(sky);

            // Grass texture on floor (dots)
            for (let i = 0; i < 50; i++) {
              const blade = new THREE.Mesh(
                new THREE.ConeGeometry(0.03, 0.15, 4),
                new THREE.MeshBasicMaterial({ color: 0x3a6b3a })
              );
              blade.position.set(
                (Math.random() - 0.5) * 10,
                0.05,
                (Math.random() - 0.5) * 10
              );
              this.group.add(blade);
            }
          }

          addAnimal(animal) {
            this.animals.push(animal);
            this.group.add(animal);
          }
        }

        // Create all rooms
        const rooms = {};
        let roomOffsetX = 0;
        Object.entries(ROOM_CONFIG).forEach(([key, config]) => {
          const room = new Room(config, key);
          room.group.position.x = roomOffsetX;
          room.group.visible = false; // Hide all initially
          rooms[key] = room;
          scene.add(room.group);
          roomOffsetX += 50; // Offset rooms far apart
        });

        // Current room state
        let currentRoom = "living";
        rooms[currentRoom].group.visible = true;

        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let currentAnimal = null;
        let currentType = "bunny";
        let currentColor = "default";
        let isTransitioning = false;

        function switchAnimal(type, colorOverride = null) {
          if (isTransitioning) return;

          const color = colorOverride || currentColor;
          const config = ANIMAL_CONFIG[type];

          if (!config) return;

          isTransitioning = true;

          // Scale down current animal
          if (currentAnimal) {
            const oldAnimal = currentAnimal;
            const startScale = { value: 1 };

            const animateOut = () => {
              startScale.value -= 0.08;
              if (startScale.value > 0) {
                oldAnimal.scale.setScalar(startScale.value);
                requestAnimationFrame(animateOut);
              } else {
                // Particle burst at center
                particleBurst.burst(new THREE.Vector3(0, 0.8, 0), 25);

                scene.remove(oldAnimal);
                oldAnimal.traverse((child) => {
                  if (child.geometry) child.geometry.dispose();
                });

                // Create and animate in new animal
                createNewAnimal();
              }
            };
            animateOut();
          } else {
            createNewAnimal();
          }

          function createNewAnimal() {
            currentAnimal = createAnimalModel(type, color);
            currentAnimal.scale.setScalar(0);
            scene.add(currentAnimal);

            currentType = type;

            // Animate in with bounce
            let scaleProgress = 0;
            const animateIn = () => {
              scaleProgress += 0.06;
              if (scaleProgress < 1) {
                // Bounce easing
                const t = scaleProgress;
                const bounce = 1 + Math.sin(t * Math.PI) * 0.15 * (1 - t);
                currentAnimal.scale.setScalar(t * bounce);
                requestAnimationFrame(animateIn);
              } else {
                currentAnimal.scale.setScalar(1);
                isTransitioning = false;
              }
            };
            animateIn();
          }

          // Update UI
          document.getElementById("animal-name").textContent = config.name;
          document.getElementById("animal-emoji").textContent = config.emoji;

          const badgeEl = document.getElementById("animal-badge");
          badgeEl.classList.remove("pop-in");
          void badgeEl.offsetWidth;
          badgeEl.classList.add("pop-in");
        }

        // Color change handler
        function changeColor(colorName) {
          currentColor = colorName;
          document.querySelectorAll(".color-swatch").forEach((swatch) => {
            swatch.classList.toggle(
              "active",
              swatch.dataset.color === colorName
            );
          });
        }

        // ==========================================
        // ROOM SWITCHING SYSTEM
        // ==========================================
        function switchRoom(roomKey) {
          if (roomKey === currentRoom) return;

          // Hide current room
          rooms[currentRoom].group.visible = false;

          // Show new room
          currentRoom = roomKey;
          rooms[currentRoom].group.visible = true;

          // Move camera to new room position
          const roomPos = rooms[currentRoom].group.position;
          camera.position.set(roomPos.x, 3, roomPos.z + 8);
          controls.target.set(roomPos.x, 1, roomPos.z);
          controls.update();

          // Update room badge
          const roomConfig = ROOM_CONFIG[roomKey];
          document.getElementById("animal-name").textContent = roomConfig.name;
          document.getElementById("animal-emoji").textContent =
            roomKey === "living" ? "üõãÔ∏è" : roomKey === "bedroom" ? "üõèÔ∏è" : "üå≥";

          // Update room button active states
          document.querySelectorAll(".room-btn").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.room === roomKey);
          });
        }

        // ANIMAL AI - PHASE 2 TYPE-SPECIFIC LOCOMOTION
        // ==========================================

        // Type-specific locomotion profiles
        const LOCOMOTION_PROFILES = {
          bunny: {
            hopHeight: 0.35,
            hopSpeed: 8,
            waddle: 0.05,
            squashIntensity: 0.25,
            speed: 1.2,
            style: "hop",
          },
          bear: {
            hopHeight: 0.08,
            hopSpeed: 4,
            waddle: 0.12,
            squashIntensity: 0.15,
            speed: 0.5,
            style: "lumber",
          },
          penguin: {
            hopHeight: 0.05,
            hopSpeed: 6,
            waddle: 0.25,
            squashIntensity: 0.1,
            speed: 0.6,
            style: "waddle",
          },
          fox: {
            hopHeight: 0.15,
            hopSpeed: 7,
            waddle: 0.08,
            squashIntensity: 0.18,
            speed: 1.0,
            style: "trot",
          },
          elephant: {
            hopHeight: 0.03,
            hopSpeed: 2,
            waddle: 0.06,
            squashIntensity: 0.08,
            speed: 0.3,
            style: "stomp",
          },
          cat: {
            hopHeight: 0.12,
            hopSpeed: 5,
            waddle: 0.04,
            squashIntensity: 0.2,
            speed: 0.9,
            style: "prowl",
          },
          owl: {
            hopHeight: 0.2,
            hopSpeed: 3,
            waddle: 0.02,
            squashIntensity: 0.15,
            speed: 0.4,
            style: "hop",
          },
          panda: {
            hopHeight: 0.06,
            hopSpeed: 3,
            waddle: 0.18,
            squashIntensity: 0.12,
            speed: 0.4,
            style: "waddle",
          },
          duck: {
            hopHeight: 0.08,
            hopSpeed: 7,
            waddle: 0.22,
            squashIntensity: 0.1,
            speed: 0.7,
            style: "waddle",
          },
          frog: {
            hopHeight: 0.5,
            hopSpeed: 2,
            waddle: 0.0,
            squashIntensity: 0.4,
            speed: 0.8,
            style: "leap",
          },
        };

        class AnimalAI {
          constructor(animal, roomConfig) {
            this.animal = animal;
            this.roomConfig = roomConfig;
            this.animalType = animal.userData.type || "bunny";
            this.locomotion =
              LOCOMOTION_PROFILES[this.animalType] || LOCOMOTION_PROFILES.bunny;

            this.state = "idle"; // idle, anticipation, walking, arriving, sitting, playing
            this.targetPosition = new THREE.Vector3();
            this.startPosition = new THREE.Vector3();
            this.moveSpeed = this.locomotion.speed + Math.random() * 0.2;
            this.stateTimer = 0;
            this.stateDuration = 3 + Math.random() * 2;
            this.roomBounds = {
              x: roomConfig.size.x / 2 - 1.5,
              z: roomConfig.size.z / 2 - 1.5,
            };
            this.walkCycle = 0;
            this.bouncePhase = 0;
            this.squash = 1;
            this.stretch = 1;
            this.hopCount = 0; // For discrete hop styles
            this.pickNewTarget();
          }

          pickNewTarget() {
            this.startPosition.copy(this.animal.position);

            // Try to find a good target that avoids other animals
            let attempts = 0;
            let bestTarget = new THREE.Vector3();
            let valid = false;

            while (!valid && attempts < 5) {
              attempts++;

              // Occasionally explore edges/corners (30% chance)
              if (Math.random() < 0.3) {
                // Pick an edge or corner position
                const edgeX =
                  (Math.random() > 0.5 ? 1 : -1) * this.roomBounds.x * 0.85;
                const edgeZ =
                  (Math.random() > 0.5 ? 1 : -1) * this.roomBounds.z * 0.85;
                if (Math.random() > 0.5) {
                  bestTarget.set(
                    edgeX,
                    0,
                    (Math.random() - 0.5) * this.roomBounds.z
                  );
                } else {
                  bestTarget.set(
                    (Math.random() - 0.5) * this.roomBounds.x,
                    0,
                    edgeZ
                  );
                }
              } else {
                // Normal random position
                bestTarget.set(
                  (Math.random() - 0.5) * this.roomBounds.x * 1.4,
                  0,
                  (Math.random() - 0.5) * this.roomBounds.z * 1.4
                );
              }

              // Check distance from other animals
              valid = true;
              animalAIs.forEach((otherAI) => {
                if (otherAI !== this && otherAI.roomKey === this.roomKey) {
                  const dist = bestTarget.distanceTo(otherAI.animal.position);
                  if (dist < 1.2) {
                    // Minimum safe distance
                    valid = false;
                  }
                }
              });
            }

            this.targetPosition.copy(bestTarget);
            this.journeyLength = this.startPosition.distanceTo(
              this.targetPosition
            );
          }

          // Cartoon easing functions
          easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
          }

          easeOutElastic(t) {
            if (t === 0 || t === 1) return t;
            return (
              Math.pow(2, -10 * t) *
                Math.sin(((t * 10 - 0.75) * (2 * Math.PI)) / 3) +
              1
            );
          }

          easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          }

          update(deltaTime) {
            this.stateTimer += deltaTime;
            const t = this.stateTimer;

            switch (this.state) {
              case "idle":
                // Gentle breathing (reset squash/stretch)
                this.squash = 1 + Math.sin(t * 2) * 0.02;
                this.stretch = 1;
                this.applySquashStretch();

                // ===== PERSONALITY BEHAVIORS WHILE IDLE =====
                const data = this.animal.userData.animationData;

                // Curious looking around (head movement)
                if (data && data.head) {
                  const lookCycle = t * 0.5;
                  // Occasional look to side
                  const lookSide = Math.sin(lookCycle) * 0.2;
                  // Random curious tilt
                  const tilt = Math.sin(t * 0.3) * 0.1;
                  data.head.rotation.y = lookSide;
                  data.head.rotation.z = tilt;
                }

                // Ear twitches (alert/curious)
                if (data && data.ears) {
                  data.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      const twitch = Math.sin(t * 4 + i * 2) * 0.05;
                      ear.rotation.z = (i === 0 ? -1 : 1) * (0.15 + twitch);
                    }
                  });
                }

                // Occasional yawn (every 8+ seconds)
                const yawnPhase = t % 10;
                if (yawnPhase > 8 && yawnPhase < 8.8) {
                  const yawnProgress = (yawnPhase - 8) / 0.8;
                  // Open mouth wide, tilt head back
                  if (data && data.head) {
                    data.head.rotation.x =
                      -Math.sin(yawnProgress * Math.PI) * 0.2;
                  }
                  // Squash-stretch during yawn
                  this.squash = 1 + Math.sin(yawnProgress * Math.PI) * 0.1;
                  this.applySquashStretch();
                }

                // Tail gentle sway while idle
                if (data && data.tail) {
                  data.tail.rotation.z = Math.sin(t * 1.5) * 0.15;
                }

                if (t > this.stateDuration) {
                  this.transitionTo("anticipation");
                }
                break;

              case "anticipation":
                // SQUASH DOWN before jumping/moving (wind-up)
                const anticipationDuration = 0.4;
                const anticipationProgress = Math.min(
                  t / anticipationDuration,
                  1
                );

                // Turn to face target BEFORE hopping
                const turnDirection = new THREE.Vector3().subVectors(
                  this.targetPosition,
                  this.animal.position
                );
                if (turnDirection.length() > 0.1) {
                  const targetRot = Math.atan2(
                    turnDirection.x,
                    turnDirection.z
                  );
                  let rotDiff = targetRot - this.animal.rotation.y;
                  while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                  while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                  this.animal.rotation.y += rotDiff * 0.6; // Faster turn (was 0.3)
                }

                // Squash down dramatically
                this.squash = 1 - anticipationProgress * 0.3; // Compress to 70%
                this.stretch = 1 + anticipationProgress * 0.15; // Widen
                this.applySquashStretch();

                // Crouch down
                this.animal.position.y = -anticipationProgress * 0.1;

                if (t > anticipationDuration) {
                  this.transitionTo("walking");
                }
                break;

              case "walking":
                // TYPE-SPECIFIC LOCOMOTION
                const loco = this.locomotion;
                const walkDuration = this.journeyLength / this.moveSpeed;
                const walkProgress = Math.min(t / walkDuration, 1);

                // Hop/walk cycle using type-specific speed
                this.walkCycle += deltaTime * loco.hopSpeed;
                const hopPhase = Math.sin(this.walkCycle * Math.PI);

                // Apply hop based on style
                if (loco.style === "hop") {
                  // BUNNY/OWL: Distinct bouncy hops
                  const discreteHop = Math.abs(
                    Math.sin(this.walkCycle * Math.PI)
                  );
                  this.animal.position.y = discreteHop * loco.hopHeight;
                } else if (loco.style === "leap") {
                  // FROG: Big single leap with hang time
                  const leapProgress = this.easeInOutQuad(
                    Math.sin(walkProgress * Math.PI)
                  );
                  this.animal.position.y = leapProgress * loco.hopHeight;
                } else if (loco.style === "stomp") {
                  // ELEPHANT: Heavy stomp with ground impact
                  this.animal.position.y = Math.max(
                    0,
                    Math.abs(hopPhase) * loco.hopHeight
                  );
                  // Add "weight" shake on landing
                  if (Math.abs(hopPhase) < 0.1) {
                    this.animal.rotation.x = Math.random() * 0.02;
                  }
                } else if (loco.style === "waddle") {
                  // PENGUIN/DUCK/PANDA: Tiny bounces with strong side-to-side
                  this.animal.position.y = Math.abs(hopPhase) * loco.hopHeight;
                } else {
                  // DEFAULT (trot, lumber, prowl): Standard hop
                  this.animal.position.y = Math.max(
                    0,
                    Math.abs(hopPhase) * loco.hopHeight
                  );
                }

                // Squash on landing, stretch in air (type-specific intensity)
                if (hopPhase > 0) {
                  // In air - stretch tall
                  this.squash = 1 + loco.squashIntensity;
                  this.stretch = 1 - loco.squashIntensity * 0.6;
                } else {
                  // Landing - squash wide
                  this.squash = 1 - loco.squashIntensity;
                  this.stretch = 1 + loco.squashIntensity * 0.6;
                }
                this.applySquashStretch();

                // Move towards target with easing
                const easedProgress = this.easeInOutQuad(walkProgress);
                const newX =
                  this.startPosition.x +
                  (this.targetPosition.x - this.startPosition.x) *
                    easedProgress;
                const newZ =
                  this.startPosition.z +
                  (this.targetPosition.z - this.startPosition.z) *
                    easedProgress;
                this.animal.position.x = newX;
                this.animal.position.z = newZ;

                // Face movement direction - use start‚Üítarget direction (not current‚Üítarget)
                const moveDirection = new THREE.Vector3().subVectors(
                  this.targetPosition,
                  this.startPosition
                );
                if (moveDirection.length() > 0.1) {
                  const targetRot = Math.atan2(
                    moveDirection.x,
                    moveDirection.z
                  );
                  // Snap rotation faster for responsiveness
                  let rotDiff = targetRot - this.animal.rotation.y;
                  // Normalize angle
                  while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                  while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                  this.animal.rotation.y += rotDiff * 0.5; // Faster rotation (was 0.2)
                }

                // Type-specific waddle side-to-side
                const waddleAmount = Math.sin(this.walkCycle * 2) * loco.waddle;
                this.animal.rotation.z = waddleAmount;

                // Type-specific tilt based on locomotion style
                if (loco.style === "prowl") {
                  this.animal.rotation.x = 0.03; // Cat: sleek, low profile
                } else if (loco.style === "lumber") {
                  this.animal.rotation.x = 0.12; // Bear: heavy lean
                } else if (loco.style === "leap") {
                  this.animal.rotation.x = -0.1; // Frog: nose up during leap
                } else {
                  this.animal.rotation.x = 0.06; // Default forward tilt
                }

                // Animate body parts during walking
                this.animateBodyParts(hopPhase, deltaTime);

                // Check if arrived
                if (walkProgress >= 1) {
                  this.transitionTo("arriving");
                }
                break;

              case "arriving":
                // OVERSHOOT and settle with bounce
                const arriveDuration = 0.5;
                const arriveProgress = Math.min(t / arriveDuration, 1);

                // Elastic overshoot bounce
                const bounce = this.easeOutElastic(arriveProgress);
                this.squash =
                  1 +
                  (1 - bounce) * 0.2 * Math.sin(arriveProgress * Math.PI * 4);
                this.stretch = 1;
                this.applySquashStretch();

                // Settle rotation
                this.animal.rotation.x *= 0.9;
                this.animal.rotation.z *= 0.9;
                this.animal.position.y *= 0.8;

                if (t > arriveDuration) {
                  const nextState = Math.random();
                  if (nextState < 0.4) this.transitionTo("idle");
                  else if (nextState < 0.7) this.transitionTo("sitting");
                  else this.transitionTo("playing");
                }
                break;

              case "sitting":
                // Cute sit-down animation
                const sitProgress = Math.min(t / 0.3, 1);
                this.squash = 0.8; // Stay squashed
                this.stretch = 1.1;
                this.applySquashStretch();
                this.animal.position.y = -0.08 * sitProgress;

                // ===== SITTING PERSONALITY =====
                const sitData = this.animal.userData.animationData;

                // Sleepy slow breathing
                const sleepyBreath = Math.sin(t * 1.2) * 0.03;
                this.squash = 0.8 + sleepyBreath;

                // Content head resting/looking around slowly
                if (sitData && sitData.head) {
                  sitData.head.rotation.y = Math.sin(t * 0.4) * 0.15;
                  sitData.head.rotation.x = 0.1; // Looking down slightly
                }

                // Occasional grooming (look at side as if checking fur)
                const groomPhase = t % 6;
                if (
                  groomPhase > 4.5 &&
                  groomPhase < 5.5 &&
                  sitData &&
                  sitData.head
                ) {
                  sitData.head.rotation.y = 0.5; // Turn head to side
                  sitData.head.rotation.z = 0.2; // Tilt
                }

                // Ears relaxed/droopy while sitting
                if (sitData && sitData.ears) {
                  sitData.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      ear.rotation.z = (i === 0 ? -1 : 1) * 0.25; // Relaxed droopy
                    }
                  });
                }

                // Tail curled calmly
                if (sitData && sitData.tail) {
                  sitData.tail.rotation.z = Math.sin(t * 0.8) * 0.1;
                  sitData.tail.rotation.x = 0.3; // Curled up
                }

                // Stretch when about to get up
                if (
                  t > this.stateDuration * 1.3 &&
                  t < this.stateDuration * 1.5
                ) {
                  const stretchProgress =
                    (t - this.stateDuration * 1.3) / (this.stateDuration * 0.2);
                  this.squash = 0.8 + stretchProgress * 0.4; // Stretch tall!
                  this.stretch = 1.1 - stretchProgress * 0.2;
                  this.applySquashStretch();
                }

                if (t > this.stateDuration * 1.5) {
                  this.transitionTo("idle");
                }
                break;

              case "playing":
                // Excited spinning and bouncing!
                this.animal.rotation.y += deltaTime * 4;
                this.bouncePhase += deltaTime * 8;
                this.animal.position.y =
                  Math.abs(Math.sin(this.bouncePhase)) * 0.15;

                // Joyful squash-stretch
                this.squash = 1 + Math.sin(this.bouncePhase * 2) * 0.1;
                this.stretch = 1 - Math.sin(this.bouncePhase * 2) * 0.05;
                this.applySquashStretch();

                // ===== PLAYFUL EXPRESSIONS =====
                const playData = this.animal.userData.animationData;

                // Happy perked up ears
                if (playData && playData.ears) {
                  playData.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      // Perky and bouncy
                      ear.rotation.z =
                        (i === 0 ? -1 : 1) *
                        (0.1 + Math.sin(this.bouncePhase * 2 + i) * 0.1);
                      ear.rotation.x = -0.1; // Forward alert position
                    }
                  });
                }

                // Excited tail wagging
                if (playData && playData.tail) {
                  playData.tail.rotation.z =
                    Math.sin(this.bouncePhase * 3) * 0.4; // Fast wag!
                  playData.tail.rotation.y =
                    Math.sin(this.bouncePhase * 2) * 0.2;
                }

                // Happy head bobbing
                if (playData && playData.head) {
                  playData.head.rotation.x =
                    Math.sin(this.bouncePhase * 2) * 0.1;
                  playData.head.rotation.z = Math.sin(this.bouncePhase) * 0.1;
                }

                if (t > this.stateDuration * 0.8) {
                  this.transitionTo("arriving");
                }
                break;
            }

            // Keep in bounds
            this.animal.position.x = Math.max(
              -this.roomBounds.x,
              Math.min(this.roomBounds.x, this.animal.position.x)
            );
            this.animal.position.z = Math.max(
              -this.roomBounds.z,
              Math.min(this.roomBounds.z, this.animal.position.z)
            );
          }

          applySquashStretch() {
            this.animal.scale.y = this.squash;
            this.animal.scale.x = this.stretch;
            this.animal.scale.z = this.stretch;
          }

          animateBodyParts(hopPhase, deltaTime) {
            const data = this.animal.userData.animationData;
            if (!data) return;

            const walkCycle = this.walkCycle;

            // ===== EAR ANIMATION =====
            if (data.ears) {
              data.ears.children.forEach((ear, i) => {
                if (ear.isMesh || ear.isGroup) {
                  // Bounce ears with each hop (opposite phase for natural look)
                  const earBounce =
                    Math.sin(walkCycle * Math.PI + i * Math.PI) * 0.2;
                  const earFlop = Math.abs(hopPhase) * 0.15;
                  ear.rotation.z =
                    (i === 0 ? -1 : 1) * (0.15 + earBounce + earFlop);
                  // Slight forward/back with movement
                  ear.rotation.x = hopPhase * 0.1;
                }
              });
            }

            // ===== TAIL ANIMATION =====
            if (data.tail) {
              // Tail waves with a delay (drag effect)
              const tailPhase = walkCycle - 0.5; // Lags behind body
              data.tail.rotation.z = Math.sin(tailPhase * 2) * 0.3;
              data.tail.rotation.x = -0.2 + Math.sin(tailPhase) * 0.15;

              // Animate tail segments if they exist
              data.tail.children.forEach((seg, i) => {
                if (seg.isMesh) {
                  const delay = i * 0.3;
                  seg.rotation.z = Math.sin(tailPhase * 2 - delay) * 0.15;
                }
              });
            }

            // ===== HEAD ANIMATION =====
            if (data.head) {
              // Head bobs with walking
              data.head.rotation.x = Math.sin(walkCycle * 2 * Math.PI) * 0.05;
              // Slight side tilt with waddle
              data.head.rotation.z = Math.sin(walkCycle * Math.PI) * 0.03;
            }

            // ===== NOSE ANIMATION =====
            if (data.nose) {
              // Nose twitches faster during movement
              data.nose.rotation.z = Math.sin(walkCycle * 4 * Math.PI) * 0.1;
            }

            // ===== TRUNK ANIMATION (Elephant) =====
            if (data.trunk) {
              // Trunk swings with walking
              data.trunk.rotation.z = Math.sin(walkCycle * Math.PI) * 0.2;
              data.trunk.rotation.x = Math.sin(walkCycle * 2 * Math.PI) * 0.1;
            }

            // ===== THROAT ANIMATION (Frog) =====
            if (data.throat) {
              // Throat pulses faster during hopping
              const pulse = 1 + Math.abs(hopPhase) * 0.3;
              data.throat.scale.set(1.1 * pulse, 0.6 * pulse, 0.8);
            }
          }

          transitionTo(newState) {
            // Reset animation properties for clean transitions
            this.animal.rotation.x = 0;
            this.animal.rotation.z = 0;
            this.squash = 1;
            this.stretch = 1;
            this.applySquashStretch();
            this.walkCycle = 0;
            this.bouncePhase = 0;

            // Special handling for state-specific resets
            if (newState === "idle" || newState === "anticipation") {
              this.animal.position.y = 0;
            }

            this.state = newState;
            this.stateTimer = 0;
            this.stateDuration = 2 + Math.random() * 3;

            if (newState === "anticipation") {
              this.pickNewTarget();
            }
          }
        }

        // Store AI instances
        const animalAIs = [];

        // Spawn animals in their rooms with AI
        function spawnAnimalsInRooms() {
          Object.entries(ROOM_CONFIG).forEach(([roomKey, config]) => {
            const room = rooms[roomKey];
            config.animals.forEach((animalType, index) => {
              const animal = createAnimalModel(animalType);
              // Position animals spread out in room
              const angle = (index / config.animals.length) * Math.PI * 2;
              const radius = 2;
              animal.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
              );
              animal.rotation.y = -angle + Math.PI; // Face center
              room.addAnimal(animal);

              // Create AI for this animal
              const ai = new AnimalAI(animal, config);
              ai.roomKey = roomKey; // Track which room
              animalAIs.push(ai);
            });
          });
        }

        // Initialize rooms with animals
        spawnAnimalsInRooms();

        // Set initial camera for living room
        camera.position.set(0, 3, 8);
        controls.target.set(0, 1, 0);
        controls.update();

        // Event listeners - Room buttons
        document.querySelectorAll(".room-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const roomKey = e.currentTarget.dataset.room;
            if (roomKey) switchRoom(roomKey);
          });
        });

        // Event listeners - Art Style buttons
        document.querySelectorAll(".style-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const styleName = e.currentTarget.dataset.style;
            if (styleName && ART_STYLES[styleName]) {
              // Update active state
              document.querySelectorAll(".style-btn").forEach(b => b.classList.remove("active"));
              e.currentTarget.classList.add("active");
              
              // Set art style and update all animals
              setArtStyle(styleName);
              updateAllAnimalMaterials(styleName);
            }
          });
        });

        // Update all animal materials with new art style
        function updateAllAnimalMaterials(styleName) {
          Object.values(rooms).forEach(room => {
            room.animals.forEach(animal => {
              animal.traverse(child => {
                if (child.isMesh && child.material && !child.userData.preserveMaterial) {
                  const oldColor = child.material.color ? child.material.color.getHex() : 0x888888;
                  child.material = createStyledMaterial(oldColor, styleName);
                }
              });
            });
          });
        }

        document.querySelectorAll(".color-swatch").forEach((swatch) => {
          swatch.addEventListener("click", (e) => {
            const color = e.currentTarget.dataset.color;
            if (color) changeColor(color);
          });
        });

        // Screenshot
        document
          .getElementById("btn-screenshot")
          .addEventListener("click", () => {
            composer.render();
            const link = document.createElement("a");
            link.download = `vinyl-${currentType}-${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            link.click();
          });

        // Fullscreen
        document
          .getElementById("btn-fullscreen")
          .addEventListener("click", () => {
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else {
              document.documentElement.requestFullscreen();
            }
          });

        // Sound toggle (placeholder)
        let soundEnabled = false;
        document.getElementById("btn-sound").addEventListener("click", (e) => {
          soundEnabled = !soundEnabled;
          e.currentTarget.textContent = soundEnabled ? "üîä" : "üîá";
        });

        // ==========================================
        // ANIMATION SYSTEM
        // ==========================================
        const clock = new THREE.Clock();

        function tick() {
          const t = clock.getElapsedTime();
          const delta = clock.getDelta();

          // Update particles
          particleBurst.update(delta || 0.016);

          // Update animal AI (only for current room)
          const effectiveDelta = delta || 0.016;
          animalAIs.forEach((ai) => {
            if (ai.roomKey === currentRoom) {
              ai.update(effectiveDelta);
            }
          });

          // Animate all animals in the current visible room
          const room = rooms[currentRoom];
          if (room && room.animals) {
            room.animals.forEach((animal, animalIndex) => {
              const type = animal.userData.type;
              const data = animal.userData.animationData;

              // Offset time per animal for variety
              const at = t + animalIndex * 0.7;

              // ===== ENHANCED BREATHING (localized to body) =====
              const breathCycle = Math.sin(at * 1.8);
              const breath = 1 + breathCycle * 0.015;
              animal.scale.set(1, breath, 1 + breathCycle * 0.008);

              // ===== ENHANCED BLINKING (asymmetric + expressive) =====
              const blinkCycle = 4;
              const blinkPhase = (t % blinkCycle) / blinkCycle;
              // Add occasional slow "sleepy" blink
              const slowBlink = Math.floor(t / 12) % 3 === 0;
              const blinkSpeed = slowBlink ? 0.08 : 0.03;

              let eyeScaleY = 1;
              if (blinkPhase < blinkSpeed) {
                eyeScaleY = 1 - blinkPhase / blinkSpeed; // Close
              } else if (blinkPhase < blinkSpeed * 2) {
                eyeScaleY = (blinkPhase - blinkSpeed) / blinkSpeed; // Open
              }
              // Squash effect during blink (eyes widen slightly horizontally)
              const eyeScaleX = 1 + (1 - eyeScaleY) * 0.15;
              eyeScaleY = Math.max(0.1, eyeScaleY);

              // ===== EYE DART - SMOOTH LOOK, HOLD, RETURN =====
              // Look cycle: 8 seconds total
              // 0-1s: smoothly look to side, 1-2.5s: hold, 2.5-3.5s: return, 3.5-8s: rest
              const lookCycle = 8;
              const lookPhase = t % lookCycle;
              let eyeOffsetX = 0;

              // Determine direction (alternate left/right each cycle)
              const lookDir = Math.floor(t / lookCycle) % 2 === 0 ? 1 : -1;
              const maxOffset = 0.012;

              if (lookPhase < 1.0) {
                // Smooth ease-out to look position
                const progress = lookPhase / 1.0;
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                eyeOffsetX = maxOffset * lookDir * eased;
              } else if (lookPhase < 2.5) {
                // Hold at look position
                eyeOffsetX = maxOffset * lookDir;
              } else if (lookPhase < 3.5) {
                // Smooth ease-in-out return to center
                const progress = (lookPhase - 2.5) / 1.0;
                const eased =
                  progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                eyeOffsetX = maxOffset * lookDir * (1 - eased);
              }
              // else: rest at center (eyeOffsetX = 0)

              // Apply enhanced blink and eye dart to ALL eye parts
              animal.traverse((child) => {
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.eyeWhite
                ) {
                  if (child.userData.origScaleY === undefined) {
                    child.userData.origScaleY = child.scale.y;
                    child.userData.origScaleX = child.scale.x;
                    child.userData.origPosX = child.position.x;
                  }
                  child.scale.y = child.userData.origScaleY * eyeScaleY;
                  child.scale.x = child.userData.origScaleX * eyeScaleX;
                  child.position.x = child.userData.origPosX + eyeOffsetX;
                }
                // Move pupils with eye dart
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.eyeBlack
                ) {
                  if (child.userData.origPosX === undefined) {
                    child.userData.origPosX = child.position.x;
                  }
                  child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
                }
                // Move specular highlights with eye dart too!
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.specular
                ) {
                  if (child.userData.origPosX === undefined) {
                    child.userData.origPosX = child.position.x;
                  }
                  child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
                }
              });

              // ===== WEIGHT SHIFT (subtle body sway) =====
              const swayPhase = Math.sin(at * 0.7) * 0.008;
              animal.rotation.z = swayPhase;

              // Type-specific animations
              switch (type) {
                case "bunny":
                  // Enhanced ear twitch with independent timing
                  if (data.ears) {
                    data.ears.children.forEach((ear, i) => {
                      const earPhase = t * 3 + i * 1.5;
                      ear.rotation.z =
                        (i === 0 ? -1 : 1) * (0.15 + Math.sin(earPhase) * 0.08);
                      // Occasional alert perk
                      if (Math.floor(t / 6) % 3 === i) {
                        ear.rotation.z += (i === 0 ? -1 : 1) * 0.15;
                      }
                    });
                  }
                  // Faster nose wiggle (bunnies twitch a lot!)
                  if (data.nose) {
                    data.nose.rotation.z = Math.sin(t * 10) * 0.12;
                    data.nose.scale.x = 1 + Math.sin(t * 8) * 0.15;
                  }
                  // Note: Foot thump removed - AI handles hopping now
                  break;

                case "bear":
                  // Enhanced head sway with occasional look around
                  if (data.head) {
                    const lookAround = Math.floor(t / 8) % 2 === 0;
                    const headSwayAmp = lookAround ? 0.08 : 0.03;
                    data.head.rotation.z = Math.sin(t * 1.2) * headSwayAmp;
                    data.head.rotation.y =
                      Math.sin(t * 0.6) * headSwayAmp * 1.5;
                    // Gentle head tilt
                    data.head.rotation.x = Math.sin(t * 0.4) * 0.02;
                  }
                  // Shoulder roll motion
                  animal.rotation.x = Math.sin(t * 0.8) * 0.015;
                  break;

                case "penguin":
                  // Enhanced waddle with happy flipper flutter
                  const waddleSpeed = 2.5;
                  animal.rotation.z = Math.sin(at * waddleSpeed) * 0.06;
                  // Occasional excited hop
                  const hopPhase = at % 10;
                  if (hopPhase > 9.5) {
                    animal.position.y =
                      Math.sin((hopPhase - 9.5) * Math.PI * 2) * 0.05;
                  }
                  break;

                case "fox":
                  // Enhanced tail physics
                  if (data.tail) {
                    data.tail.rotation.z = Math.sin(at * 3) * 0.22;
                    data.tail.rotation.x = -0.25 + Math.sin(at * 1.5) * 0.1;
                    data.tail.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.15;
                        seg.rotation.z = Math.sin(at * 4 - delay) * 0.12;
                      }
                    });
                  }
                  // Alert sniff motion (head bob)
                  if (data.head) {
                    const sniffCycle = at % 4;
                    if (sniffCycle > 3.5) {
                      data.head.rotation.x =
                        Math.sin((sniffCycle - 3.5) * Math.PI * 8) * 0.03;
                    }
                  }
                  break;

                case "elephant":
                  // Trunk sway with curl
                  if (data.trunk) {
                    data.trunk.rotation.z = Math.sin(at * 1.5) * 0.15;
                    data.trunk.rotation.x = Math.sin(at * 0.8) * 0.1;
                    // Wave through trunk segments
                    data.trunk.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.1;
                        seg.position.x = Math.sin(at * 2 - delay) * 0.015;
                      }
                    });
                  }
                  break;

                case "cat":
                  // Enhanced tail swish with physics
                  if (data.tail) {
                    const swishSpeed = 2.5;
                    const swishAmp = 0.28;
                    data.tail.rotation.z = Math.sin(at * swishSpeed) * swishAmp;
                    data.tail.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.12;
                        seg.rotation.z = Math.sin(at * 3 - delay) * 0.1;
                      }
                    });
                  }
                  // Enhanced ear swivel (independent movement)
                  if (data.ears) {
                    data.ears.children.forEach((ear, i) => {
                      if (i % 2 === 0) {
                        ear.rotation.y = Math.sin(at * 1.8 + i * 0.5) * 0.12;
                      }
                    });
                  }
                  break;

                case "owl":
                  // Enhanced head rotation with tilt
                  if (data.head) {
                    const headRotation = Math.sin(at * 0.5) * 0.35;
                    // Occasional dramatic turn (owls are known for this!)
                    const dramaticTurn =
                      Math.floor(at / 5) % 2 === 0
                        ? Math.sin(((at % 5) * Math.PI) / 5) * 1.8
                        : 0;
                    data.head.rotation.y = headRotation + dramaticTurn * 0.35;
                    // Head tilt (curious look)
                    data.head.rotation.z = Math.sin(at * 0.7) * 0.15;
                  }
                  // Feather ruffle (body puff)
                  const rufflePhase = at % 12;
                  if (rufflePhase > 11.5) {
                    animal.scale.x =
                      1 + Math.sin((rufflePhase - 11.5) * Math.PI * 4) * 0.03;
                  }
                  break;

                case "panda":
                  // Enhanced chewing motion (happy munching!)
                  if (data.muzzle) {
                    const munchSpeed = 5;
                    data.muzzle.scale.y =
                      0.7 + Math.abs(Math.sin(at * munchSpeed)) * 0.12;
                  }
                  if (data.head) {
                    data.head.rotation.x = Math.sin(at * 5) * 0.025;
                    // Gentle side-to-side while eating
                    data.head.rotation.y = Math.sin(at * 0.8) * 0.04;
                  }
                  break;

                case "duck":
                  // Enhanced head rotation with occasional quack
                  if (data.head) {
                    data.head.rotation.x = Math.sin(at * 2.2) * 0.06;
                    data.head.rotation.y = Math.sin(at * 1.3) * 0.04;
                    // Quack motion (head up!)
                    const quackPhase = at % 6;
                    if (quackPhase > 5.5 && quackPhase < 5.7) {
                      data.head.rotation.x = -0.15;
                    }
                  }
                  // Tail waggle
                  const tailWag = Math.sin(at * 4) * 0.03;
                  animal.rotation.z = tailWag;
                  break;

                case "frog":
                  // Enhanced throat pulse
                  if (data.throat) {
                    const pulseSpeed = 2.5;
                    const pulse =
                      1 + Math.max(0, Math.sin(at * pulseSpeed)) * 0.35;
                    data.throat.scale.set(1.1 * pulse, 0.6 * pulse, 0.8);
                  }
                  // Occasional jump anticipation with crouch
                  const jumpPhase = at % 8;
                  if (jumpPhase > 7.3 && jumpPhase < 7.5) {
                    animal.scale.y = 0.92; // Crouch
                  } else if (jumpPhase > 7.5) {
                    animal.position.y = 0.05 + (jumpPhase - 7.5) * 0.12;
                  }
                  break;
              }

              // Gentle idle sway for all
              animal.rotation.z += Math.sin(at * 1.5) * 0.01;
            }); // End forEach animal
          } // End if room

          controls.update();
          composer.render();
          requestAnimationFrame(tick);
        }

        // ==========================================
        // RESIZE HANDLER
        // ==========================================
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading
        setTimeout(() => {
          document.getElementById("loading").style.opacity = "0";
          setTimeout(
            () => (document.getElementById("loading").style.display = "none"),
            700
          );
        }, 800);

        tick();
      } catch (err) {
        console.error(err);
        showError("Failed to initialize 3D scene. " + err.message);
      }
    </script>
  </body>
</html>
