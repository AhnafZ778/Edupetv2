<it provided the above code but I think the models can be better, provide a more
detailed prompt for improving the models and push the LLMs to their absolute
limits. Below is the code it gave:>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Soft Vinyl Diorama - Enhanced Collection</title>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background: radial-gradient(circle at center, #2a2a35 0%, #1a1a25 100%);
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: fixed;
        inset: 0;
      }

      .loader {
        width: 50px;
        height: 50px;
        border: 4px solid rgba(107, 91, 122, 0.2);
        border-top-color: #8b9bb4;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .glass {
        background: rgba(30, 30, 40, 0.7);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        border: 1px solid rgba(60, 60, 80, 0.5);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .animal-btn,
      .room-btn {
        transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        position: relative;
        overflow: hidden;
        background: rgba(40, 40, 55, 0.6);
        color: #b0b8c8;
      }
      .animal-btn::after,
      .room-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          135deg,
          rgba(80, 80, 100, 0.3),
          rgba(40, 40, 55, 0)
        );
        opacity: 0;
        transition: opacity 0.3s;
      }
      .animal-btn:hover,
      .room-btn:hover {
        transform: translateY(-2px);
        background: rgba(60, 60, 80, 0.85);
        color: #e0e4ec;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      }
      .animal-btn.active,
      .room-btn.active {
        background: #4a5068;
        color: #ffffff;
        font-weight: 700;
        box-shadow: 0 4px 12px rgba(139, 155, 180, 0.25);
        transform: scale(1.02);
      }
      .style-btn {
        background: rgba(40, 44, 56, 0.8);
        color: #8b9bb4;
        border: 1px solid rgba(139, 155, 180, 0.2);
        transition: all 0.2s ease;
        cursor: pointer;
        font-size: 11px;
        padding: 8px 12px;
        border-radius: 8px;
      }
      .style-btn:hover {
        background: rgba(60, 66, 82, 0.9);
        border-color: rgba(139, 155, 180, 0.4);
      }
      .style-btn.active {
        background: #5a6478;
        color: #ffffff;
        border-color: rgba(139, 155, 180, 0.6);
      }
      .animal-btn.active::after,
      .room-btn.active::after {
        opacity: 1;
      }

      @keyframes popIn {
        0% {
          transform: scale(0.8);
          opacity: 0;
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .pop-in {
        animation: popIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .tool-btn {
        transition: all 0.2s ease;
        background: rgba(255, 255, 255, 0.7);
      }
      .tool-btn:hover {
        background: rgba(255, 255, 255, 0.95);
        transform: scale(1.05);
      }

      .color-swatch {
        transition: all 0.2s ease;
        cursor: pointer;
      }
      .color-swatch:hover {
        transform: scale(1.15);
      }
      .color-swatch.active {
        ring: 2px solid #6b7c93;
        transform: scale(1.1);
        box-shadow: 0 0 0 2px #6b7c93;
      }

      /* Scrollbar styling for button container */
      .btn-scroll::-webkit-scrollbar {
        height: 4px;
      }
      .btn-scroll::-webkit-scrollbar-track {
        background: transparent;
      }
      .btn-scroll::-webkit-scrollbar-thumb {
        background: rgba(139, 155, 180, 0.3);
        border-radius: 2px;
      }
    </style>
  </head>
  <body>
    <!-- Loading Screen -->
    <div
      id="loading"
      class="fixed inset-0 z-[1000] flex flex-col items-center justify-center bg-[#f0f8ff] transition-opacity duration-700"
    >
      <div class="loader"></div>
      <div class="mt-6 text-center">
        <div class="tracking-[0.2em] text-[#6b7c93] text-lg font-medium">
          VINYL SERENITY
        </div>
        <div class="mt-2 text-[#98a6b8] text-sm">Molding plastic...</div>
      </div>
    </div>

    <!-- Error Overlay -->
    <div
      id="error-overlay"
      class="fixed inset-0 z-[2000] hidden flex-col items-center justify-center bg-red-50/95 p-6"
    >
      <div class="max-w-md text-center">
        <div class="text-5xl mb-4">âš ï¸</div>
        <h1 class="text-xl font-bold text-red-800 mb-2">Rendering Error</h1>
        <p class="text-red-600 mb-6 text-sm" id="error-message">
          WebGL Context Lost
        </p>
        <button
          onclick="location.reload()"
          class="px-6 py-2 bg-white text-red-800 rounded-full shadow-md hover:shadow-lg transition text-sm font-medium border border-red-100"
        >
          Reload Viewer
        </button>
      </div>
    </div>

    <!-- Header -->
    <div
      class="pointer-events-none fixed top-6 left-1/2 -translate-x-1/2 z-[120]"
    >
      <div
        class="text-[#8b9bb4] text-xs font-bold tracking-[0.3em] uppercase opacity-80"
      >
        Soft Vinyl Collection
      </div>
    </div>

    <!-- Animal Badge -->
    <div class="fixed top-12 left-1/2 -translate-x-1/2 z-[120]">
      <div
        id="animal-badge"
        class="glass rounded-full px-6 py-2 text-[#5a6b85] text-sm font-semibold transition-all duration-300 flex items-center gap-2"
      >
        <span id="animal-emoji" class="text-lg">ğŸ°</span>
        <span id="animal-name">Bunny</span>
      </div>
    </div>

    <!-- Tool Buttons (Top Right) -->
    <div class="fixed top-6 right-6 z-[120] flex gap-2">
      <button
        id="btn-screenshot"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Screenshot"
      >
        ğŸ“·
      </button>
      <button
        id="btn-fullscreen"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Fullscreen"
      >
        â›¶
      </button>
      <button
        id="btn-sound"
        class="tool-btn glass rounded-full w-10 h-10 flex items-center justify-center text-[#6b7c93]"
        title="Sound"
      >
        ğŸ”‡
      </button>
    </div>

    <!-- Color Palette (Top Left) -->
    <div class="fixed top-6 left-6 z-[120]">
      <div class="glass rounded-2xl p-3">
        <div
          class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
        >
          Color
        </div>
        <div id="color-palette" class="flex gap-2">
          <div
            class="color-swatch active w-6 h-6 rounded-full bg-white border border-gray-200"
            data-color="default"
            title="Default"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-pink-200"
            data-color="pink"
            title="Pink"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-blue-200"
            data-color="blue"
            title="Blue"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-yellow-200"
            data-color="yellow"
            title="Yellow"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-green-200"
            data-color="green"
            title="Green"
          ></div>
          <div
            class="color-swatch w-6 h-6 rounded-full bg-purple-200"
            data-color="purple"
            title="Purple"
          ></div>
        </div>
      </div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- Toggle Button for Control Panel -->
    <button
      id="panel-toggle"
      class="fixed bottom-4 left-1/2 -translate-x-1/2 z-[130] glass rounded-full w-12 h-12 flex items-center justify-center text-xl hover:scale-110 transition-transform cursor-pointer"
      title="Toggle Controls"
    >
      âš™ï¸
    </button>

    <!-- Room Navigation (Collapsible) -->
    <div
      id="control-panel"
      class="fixed bottom-6 left-1/2 -translate-x-1/2 z-[120] w-[95%] max-w-2xl transition-all duration-300"
    >
      <div class="glass rounded-2xl p-3">
        <div
          class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
        >
          Rooms
        </div>
        <div class="flex gap-3 justify-center">
          <button
            class="room-btn active px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="living"
          >
            <span class="text-2xl">ğŸ›‹ï¸</span>
            <span class="text-[#5a6b85]">Living Room</span>
            <span class="text-[10px] text-[#8b9bb4]">ğŸ°ğŸ±ğŸ»</span>
          </button>
          <button
            class="room-btn px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="bedroom"
          >
            <span class="text-2xl">ğŸ›ï¸</span>
            <span class="text-[#5a6b85]">Bedroom</span>
            <span class="text-[10px] text-[#8b9bb4]">ğŸ¦‰ğŸ¼ğŸ¦Š</span>
          </button>
          <button
            class="room-btn px-4 py-3 rounded-xl text-xs font-medium flex flex-col items-center gap-1 min-w-[90px]"
            data-room="garden"
          >
            <span class="text-2xl">ğŸŒ³</span>
            <span class="text-[#5a6b85]">Garden</span>
            <span class="text-[10px] text-[#8b9bb4]">ğŸ§ğŸ¦†ğŸ¸ğŸ˜</span>
          </button>
        </div>

        <!-- Art Style Selector -->
        <div class="mt-4">
          <div
            class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
          >
            Art Style
          </div>
          <div class="flex gap-2 justify-center flex-wrap" id="style-selector">
            <button class="style-btn active" data-style="vinyl">
              ğŸ¨ Vinyl
            </button>
            <button class="style-btn" data-style="matte">ğŸ§¸ Matte</button>
            <button class="style-btn" data-style="plastic">âœ¨ Plastic</button>
            <button class="style-btn" data-style="glossy">ğŸ’§ Glossy</button>
            <button class="style-btn" data-style="fuzzy">ğŸ§¶ Fuzzy</button>
          </div>
        </div>

        <!-- Model Style Selector -->
        <div class="mt-4">
          <div
            class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
          >
            Model Style
          </div>
          <div
            class="flex gap-2 justify-center flex-wrap"
            id="model-style-selector"
          >
            <button class="style-btn active" data-model-style="vinyl">
              ğŸ¨ Vinyl
            </button>
            <button class="style-btn" data-model-style="celshaded">
              ğŸ’¥ Comic
            </button>
            <button class="style-btn" data-model-style="lowpoly">
              ğŸ”· LowPoly
            </button>
            <button class="style-btn" data-model-style="chibi">ğŸ€ Chibi</button>
            <button class="style-btn" data-model-style="voxel">ğŸ§± Voxel</button>
            <button class="style-btn" data-model-style="ghibli">
              ğŸŒ¸ Ghibli
            </button>
            <button class="style-btn" data-model-style="anime">âœ¨ Anime</button>
          </div>
        </div>

        <!-- Variant Selector -->
        <div class="mt-4">
          <div
            class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
          >
            Animal Variants
          </div>
          <div class="flex gap-2 justify-center items-center flex-wrap">
            <select
              id="variant-animal"
              class="style-btn px-3 py-2 bg-[#282c38] text-white rounded-lg text-xs"
            >
              <option value="bunny">ğŸ° Bunny</option>
              <option value="bear">ğŸ» Bear</option>
              <option value="cat">ğŸ± Cat</option>
              <option value="fox">ğŸ¦Š Fox</option>
              <option value="owl">ğŸ¦‰ Owl</option>
              <option value="penguin">ğŸ§ Penguin</option>
              <option value="panda">ğŸ¼ Panda</option>
              <option value="duck">ğŸ¦† Duck</option>
              <option value="frog">ğŸ¸ Frog</option>
              <option value="elephant">ğŸ˜ Elephant</option>
            </select>
            <select
              id="variant-type"
              class="style-btn px-3 py-2 bg-[#282c38] text-white rounded-lg text-xs"
            >
              <!-- Populated dynamically -->
            </select>
            <button
              id="apply-variant"
              class="style-btn px-3 py-2 bg-[#4a5068] text-white rounded-lg text-xs hover:bg-[#5a6078]"
            >
              âœ¨ Apply
            </button>
          </div>
        </div>

        <!-- Room Themes -->
        <div class="mt-4">
          <div
            class="text-[#8b9bb4] text-[10px] font-bold tracking-widest uppercase mb-2 text-center"
          >
            Room Themes
          </div>
          <div class="flex gap-2 justify-center flex-wrap" id="theme-selector">
            <button class="style-btn" data-theme="arctic">â„ï¸ Arctic</button>
            <button class="style-btn" data-theme="jungle">ğŸŒ´ Jungle</button>
            <button class="style-btn" data-theme="farm">ğŸŒ¾ Farm</button>
            <button class="style-btn" data-theme="ocean">ğŸŒŠ Ocean</button>
            <button class="style-btn" data-theme="forest">ğŸŒ² Forest</button>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // ==========================================
      // ERROR HANDLING
      // ==========================================
      function showError(msg) {
        document.getElementById("loading").style.display = "none";
        const el = document.getElementById("error-overlay");
        el.classList.remove("hidden");
        el.classList.add("flex");
        document.getElementById("error-message").innerText = msg;
      }

      try {
        // ==========================================
        // ANIMAL CONFIGURATION SYSTEM
        // ==========================================
        const ANIMAL_CONFIG = {
          bunny: {
            name: "Bunny",
            emoji: "ğŸ°",
            primaryColor: 0xffffff,
            secondaryColor: 0xffb7c5,
            accentColor: 0x1a1a1a,
          },
          bear: {
            name: "Bear",
            emoji: "ğŸ»",
            primaryColor: 0x8d7b68,
            secondaryColor: 0xe0cda7,
            accentColor: 0x1a1a1a,
          },
          penguin: {
            name: "Penguin",
            emoji: "ğŸ§",
            primaryColor: 0x1a1a1a,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c42,
          },
          fox: {
            name: "Fox",
            emoji: "ğŸ¦Š",
            primaryColor: 0xff8c42,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          elephant: {
            name: "Elephant",
            emoji: "ğŸ˜",
            primaryColor: 0x9ca3af,
            secondaryColor: 0xffffff,
            accentColor: 0x6b7280,
          },
          cat: {
            name: "Cat",
            emoji: "ğŸ±",
            primaryColor: 0xffa500,
            secondaryColor: 0xffffff,
            accentColor: 0x1a1a1a,
          },
          owl: {
            name: "Owl",
            emoji: "ğŸ¦‰",
            primaryColor: 0x8b4513,
            secondaryColor: 0xdeb887,
            accentColor: 0xffa500,
          },
          panda: {
            name: "Panda",
            emoji: "ğŸ¼",
            primaryColor: 0xffffff,
            secondaryColor: 0x1a1a1a,
            accentColor: 0x1a1a1a,
          },
          duck: {
            name: "Duck",
            emoji: "ğŸ¦†",
            primaryColor: 0xf5deb3,
            secondaryColor: 0xffffff,
            accentColor: 0xff8c00,
          },
          frog: {
            name: "Frog",
            emoji: "ğŸ¸",
            primaryColor: 0x32cd32,
            secondaryColor: 0x98fb98,
            accentColor: 0xff6347,
          },
        };

        // ==========================================
        // ANIMAL VARIANTS (Subspecies)
        // ==========================================
        const ANIMAL_VARIANTS = {
          bunny: {
            default: {
              name: "White Rabbit",
              primary: 0xffffff,
              secondary: 0xffb7c5,
              accent: 0x1a1a1a,
            },
            brown: {
              name: "Brown Rabbit",
              primary: 0x8b7355,
              secondary: 0xdeb887,
              accent: 0x1a1a1a,
            },
            dutch: {
              name: "Dutch Rabbit",
              primary: 0xffffff,
              secondary: 0x1a1a1a,
              accent: 0xffb7c5,
            },
            lop: {
              name: "Lop Ear",
              primary: 0xe8dcc8,
              secondary: 0xd4c4b0,
              accent: 0x1a1a1a,
            },
          },
          bear: {
            default: {
              name: "Brown Bear",
              primary: 0x8d7b68,
              secondary: 0xe0cda7,
              accent: 0x1a1a1a,
            },
            polar: {
              name: "Polar Bear",
              primary: 0xf5f5f5,
              secondary: 0xffffff,
              accent: 0x1a1a1a,
            },
            black: {
              name: "Black Bear",
              primary: 0x2a2a2a,
              secondary: 0x4a4a4a,
              accent: 0x1a1a1a,
            },
            grizzly: {
              name: "Grizzly Bear",
              primary: 0x6b5344,
              secondary: 0xb8a590,
              accent: 0x1a1a1a,
            },
          },
          penguin: {
            default: {
              name: "Emperor",
              primary: 0x1a1a1a,
              secondary: 0xffffff,
              accent: 0xff8c42,
            },
            adelie: {
              name: "Adelie",
              primary: 0x1a1a1a,
              secondary: 0xffffff,
              accent: 0x2a2a2a,
            },
            rockhopper: {
              name: "Rockhopper",
              primary: 0x1a1a1a,
              secondary: 0xffffff,
              accent: 0xffd700,
            },
            blue: {
              name: "Little Blue",
              primary: 0x4a6fa5,
              secondary: 0xffffff,
              accent: 0x5a7fb5,
            },
          },
          fox: {
            default: {
              name: "Red Fox",
              primary: 0xff8c42,
              secondary: 0xffffff,
              accent: 0x1a1a1a,
            },
            arctic: {
              name: "Arctic Fox",
              primary: 0xf5f5f5,
              secondary: 0xffffff,
              accent: 0x1a1a1a,
            },
            fennec: {
              name: "Fennec Fox",
              primary: 0xf5deb3,
              secondary: 0xffffff,
              accent: 0x8b7355,
            },
            silver: {
              name: "Silver Fox",
              primary: 0x708090,
              secondary: 0xc0c0c0,
              accent: 0x1a1a1a,
            },
          },
          elephant: {
            default: {
              name: "African",
              primary: 0x9ca3af,
              secondary: 0xffffff,
              accent: 0x6b7280,
            },
            asian: {
              name: "Asian",
              primary: 0x8b7355,
              secondary: 0xd4c4b0,
              accent: 0x6b5344,
            },
            pink: {
              name: "Pink Baby",
              primary: 0xffb6c1,
              secondary: 0xffc0cb,
              accent: 0xff69b4,
            },
          },
          cat: {
            default: {
              name: "Ginger",
              primary: 0xffa500,
              secondary: 0xffffff,
              accent: 0x1a1a1a,
            },
            tabby: {
              name: "Tabby",
              primary: 0x8b7355,
              secondary: 0xe8dcc8,
              accent: 0x1a1a1a,
            },
            siamese: {
              name: "Siamese",
              primary: 0xf5deb3,
              secondary: 0x8b7355,
              accent: 0x4169e1,
            },
            tuxedo: {
              name: "Tuxedo",
              primary: 0x1a1a1a,
              secondary: 0xffffff,
              accent: 0x1a1a1a,
            },
            calico: {
              name: "Calico",
              primary: 0xffffff,
              secondary: 0xffa500,
              accent: 0x1a1a1a,
            },
          },
          owl: {
            default: {
              name: "Barn Owl",
              primary: 0x8b4513,
              secondary: 0xdeb887,
              accent: 0xffa500,
            },
            snowy: {
              name: "Snowy Owl",
              primary: 0xf5f5f5,
              secondary: 0xffffff,
              accent: 0xffd700,
            },
            horned: {
              name: "Great Horned",
              primary: 0x5c4033,
              secondary: 0xa0522d,
              accent: 0xffa500,
            },
            elf: {
              name: "Elf Owl",
              primary: 0xc4a575,
              secondary: 0xe8dcc8,
              accent: 0xffd700,
            },
          },
          panda: {
            default: {
              name: "Giant Panda",
              primary: 0xffffff,
              secondary: 0x1a1a1a,
              accent: 0x1a1a1a,
            },
            red: {
              name: "Red Panda",
              primary: 0xb5651d,
              secondary: 0xdeb887,
              accent: 0x8b4513,
            },
          },
          duck: {
            default: {
              name: "Mallard",
              primary: 0x228b22,
              secondary: 0xffffff,
              accent: 0xff8c00,
            },
            white: {
              name: "White Duck",
              primary: 0xffffff,
              secondary: 0xfff8dc,
              accent: 0xff8c00,
            },
            rubber: {
              name: "Rubber Duck",
              primary: 0xffd700,
              secondary: 0xffff00,
              accent: 0xff8c00,
            },
          },
          frog: {
            default: {
              name: "Tree Frog",
              primary: 0x32cd32,
              secondary: 0x98fb98,
              accent: 0xff6347,
            },
            dart: {
              name: "Poison Dart",
              primary: 0x4169e1,
              secondary: 0x00bfff,
              accent: 0xff4500,
            },
            bullfrog: {
              name: "Bullfrog",
              primary: 0x556b2f,
              secondary: 0x8fbc8f,
              accent: 0x2e8b57,
            },
          },
        };

        // Current variant selection per animal type
        const currentVariants = {};
        Object.keys(ANIMAL_VARIANTS).forEach((type) => {
          currentVariants[type] = "default";
        });

        // Get variant colors for an animal
        function getVariantColors(animalType, variantKey = null) {
          const variants = ANIMAL_VARIANTS[animalType];
          if (!variants) return null;
          const key = variantKey || currentVariants[animalType] || "default";
          return variants[key] || variants.default;
        }

        // ==========================================
        // ROOM THEMES
        // ==========================================
        const ROOM_THEMES = {
          arctic: {
            name: "â„ï¸ Arctic",
            description: "Snowy white animals",
            animals: [
              { type: "bear", variant: "polar" },
              { type: "fox", variant: "arctic" },
              { type: "owl", variant: "snowy" },
              { type: "penguin", variant: "default" },
            ],
          },
          jungle: {
            name: "ğŸŒ´ Jungle",
            description: "Tropical creatures",
            animals: [
              { type: "frog", variant: "dart" },
              { type: "elephant", variant: "asian" },
              { type: "panda", variant: "red" },
              { type: "owl", variant: "elf" },
            ],
          },
          farm: {
            name: "ğŸŒ¾ Farm",
            description: "Barnyard friends",
            animals: [
              { type: "bunny", variant: "brown" },
              { type: "cat", variant: "tabby" },
              { type: "duck", variant: "white" },
              { type: "owl", variant: "default" },
            ],
          },
          ocean: {
            name: "ğŸŒŠ Ocean",
            description: "Aquatic pals",
            animals: [
              { type: "penguin", variant: "blue" },
              { type: "duck", variant: "rubber" },
              { type: "frog", variant: "default" },
              { type: "bear", variant: "polar" },
            ],
          },
          forest: {
            name: "ğŸŒ² Forest",
            description: "Woodland creatures",
            animals: [
              { type: "fox", variant: "default" },
              { type: "bear", variant: "grizzly" },
              { type: "owl", variant: "horned" },
              { type: "bunny", variant: "default" },
            ],
          },
        };

        // Current room theme (null = default random)
        let currentRoomTheme = null;

        // ==========================================
        // MODEL STYLE BUILDERS SYSTEM (Phase 1)
        // ==========================================

        // Registry for all style builders
        const MODEL_STYLE_BUILDERS = {};

        // Required animals for each style
        const REQUIRED_ANIMALS = [
          "bunny",
          "bear",
          "cat",
          "fox",
          "owl",
          "penguin",
          "panda",
          "duck",
          "frog",
          "elephant",
        ];

        // Current model style
        let currentModelStyleName = "vinyl";

        // ===== FAILSAFE: Error Placeholder =====
        function createErrorPlaceholder(type = "unknown") {
          const group = new THREE.Group();

          // Red wireframe cube indicates missing model
          const errorMesh = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.5, 0.5),
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
          );
          errorMesh.position.y = 0.25;
          group.add(errorMesh);

          // Question mark sphere on top
          const questionMark = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
          );
          questionMark.position.y = 0.65;
          group.add(questionMark);

          // Set required userData
          group.userData.type = type;
          group.userData.animationData = {};
          group.userData.isErrorPlaceholder = true;

          console.error(`Created error placeholder for: ${type}`);
          return group;
        }

        // ===== FAILSAFE: Validate Model Builder =====
        function validateModelBuilder(builder, styleName, animalType) {
          if (typeof builder !== "function") {
            console.error(
              `[Validation] Invalid builder for ${styleName}/${animalType}: not a function`
            );
            return false;
          }

          try {
            const testModel = builder();

            if (!testModel) {
              throw new Error("Builder returned null/undefined");
            }

            if (!testModel.isObject3D) {
              throw new Error("Builder did not return Object3D");
            }

            if (!testModel.userData || !testModel.userData.type) {
              console.warn(
                `[Validation] ${styleName}/${animalType}: missing userData.type`
              );
            }

            if (!testModel.userData || !testModel.userData.animationData) {
              console.warn(
                `[Validation] ${styleName}/${animalType}: missing userData.animationData`
              );
            }

            // Clean up test model (important to prevent memory leaks)
            testModel.traverse((child) => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) {
                if (Array.isArray(child.material)) {
                  child.material.forEach((m) => m.dispose());
                } else {
                  child.material.dispose();
                }
              }
            });

            return true;
          } catch (e) {
            console.error(
              `[Validation] Builder failed for ${styleName}/${animalType}: ${e.message}`
            );
            return false;
          }
        }

        // ===== FAILSAFE: Get Model Builder with Fallback Chain =====
        function getModelBuilder(styleName, animalType) {
          // Level 1: Try requested style
          const styleBuilders = MODEL_STYLE_BUILDERS[styleName];
          if (styleBuilders && styleBuilders[animalType]) {
            return styleBuilders[animalType];
          }

          // Level 2: Fallback to vinyl
          if (styleName !== "vinyl" && MODEL_STYLE_BUILDERS.vinyl) {
            const vinylBuilder = MODEL_STYLE_BUILDERS.vinyl[animalType];
            if (vinylBuilder) {
              console.warn(
                `[Fallback] Using vinyl for ${styleName}/${animalType}`
              );
              return vinylBuilder;
            }
          }

          // Level 3: Return error placeholder builder
          console.error(
            `[Fallback] No builder found for ${styleName}/${animalType}, using placeholder`
          );
          return () => createErrorPlaceholder(animalType);
        }

        // ===== Register Style Builders with Validation =====
        function registerStyleBuilders(styleName, builders) {
          // Check for missing animals
          const provided = Object.keys(builders);
          const missing = REQUIRED_ANIMALS.filter(
            (animal) => !builders[animal]
          );

          if (missing.length > 0) {
            console.warn(
              `[Registration] Style "${styleName}" missing builders for: ${missing.join(
                ", "
              )}`
            );
          }

          // Validate each builder
          let validCount = 0;
          for (const [animal, builder] of Object.entries(builders)) {
            if (validateModelBuilder(builder, styleName, animal)) {
              validCount++;
            }
          }

          console.log(
            `[Registration] Style "${styleName}": ${validCount}/${provided.length} builders validated`
          );

          // Register even if some fail (fallback will handle)
          MODEL_STYLE_BUILDERS[styleName] = builders;

          return missing.length === 0 && validCount === provided.length;
        }

        // ===== Toon Gradient for Cel-Shading =====
        const toonGradientColors = new Uint8Array([
          40,
          40,
          40, // Dark shadow
          120,
          120,
          120, // Mid shadow
          200,
          200,
          200, // Light
          255,
          255,
          255, // Highlight
        ]);
        const toonGradient = new THREE.DataTexture(
          toonGradientColors,
          4,
          1,
          THREE.RGBFormat
        );
        toonGradient.minFilter = THREE.NearestFilter;
        toonGradient.magFilter = THREE.NearestFilter;
        toonGradient.needsUpdate = true;

        // ===== Outline Material for Cel-Shading =====
        const outlineMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          side: THREE.BackSide,
        });

        // ===== Helper: Create Outline Mesh =====
        function createOutlineMesh(mesh, scale = 1.05) {
          const outline = mesh.clone();
          outline.material = outlineMaterial;
          outline.scale.multiplyScalar(scale);
          outline.userData.isOutline = true;
          return outline;
        }

        // ===== Style-Specific Material Helpers =====
        function createToonMaterial(color) {
          return new THREE.MeshToonMaterial({
            color: color,
            gradientMap: toonGradient,
          });
        }

        function createGhibliMaterial(color) {
          const c = new THREE.Color(color);
          const hsl = {};
          c.getHSL(hsl);
          // Desaturate and warm up for Ghibli look
          c.setHSL(hsl.h, hsl.s * 0.7, hsl.l * 1.1);

          return new THREE.MeshPhysicalMaterial({
            color: c,
            roughness: 0.6,
            metalness: 0,
            clearcoat: 0.1,
            sheen: 0.8,
            sheenRoughness: 0.9,
            sheenColor: c.clone().offsetHSL(0.05, 0, 0.2),
          });
        }

        function createLowPolyMaterial(color) {
          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: 0.5,
            metalness: 0,
            flatShading: true,
          });
        }

        function createVoxelMaterial(color) {
          return new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.4,
            metalness: 0.05,
          });
        }

        function createClaymationMaterial(color) {
          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: 0.95,
            metalness: 0,
            clearcoat: 0.05,
            sheen: 0.3,
            sheenRoughness: 1.0,
          });
        }

        // ==========================================
        // ART STYLES (Material Properties)
        // ==========================================
        let currentArtStyle = "vinyl";

        const ART_STYLES = {
          vinyl: {
            name: "Vinyl Toy",
            roughness: 0.15,
            metalness: 0.0,
            clearcoat: 0.8,
            clearcoatRoughness: 0.1,
            sheen: 0.8,
            sheenRoughness: 0.3,
            envMapIntensity: 0.6,
            saturation: 1.0,
          },
          matte: {
            name: "Soft Plush",
            roughness: 0.7,
            metalness: 0.0,
            clearcoat: 0.0,
            clearcoatRoughness: 0.8,
            sheen: 0.9,
            sheenRoughness: 0.9,
            envMapIntensity: 0.2,
            saturation: 0.9,
          },
          plastic: {
            name: "Bright Plastic",
            roughness: 0.25,
            metalness: 0.02,
            clearcoat: 0.6,
            clearcoatRoughness: 0.2,
            sheen: 0.3,
            sheenRoughness: 0.4,
            envMapIntensity: 0.5,
            saturation: 1.2,
          },
          glossy: {
            name: "Glossy Wet",
            roughness: 0.05,
            metalness: 0.05,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            sheen: 0.2,
            sheenRoughness: 0.2,
            envMapIntensity: 0.9,
            saturation: 1.0,
          },
          fuzzy: {
            name: "Fuzzy Felt",
            roughness: 0.95,
            metalness: 0.0,
            clearcoat: 0.0,
            clearcoatRoughness: 1.0,
            sheen: 1.0,
            sheenRoughness: 1.0,
            envMapIntensity: 0.1,
            saturation: 0.85,
          },
        };

        // Create material with specified art style
        function createStyledMaterial(
          baseColor,
          artStyle = null,
          options = {}
        ) {
          const style = ART_STYLES[artStyle || currentArtStyle];
          const color = new THREE.Color(baseColor);

          // Apply saturation adjustment
          const hsl = {};
          color.getHSL(hsl);
          color.setHSL(hsl.h, hsl.s * style.saturation, hsl.l);

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: style.roughness,
            metalness: style.metalness,
            clearcoat: style.clearcoat,
            clearcoatRoughness: style.clearcoatRoughness,
            sheen: style.sheen,
            sheenRoughness: style.sheenRoughness,
            sheenColor: color.clone().offsetHSL(0, -0.1, 0.2),
            envMapIntensity: style.envMapIntensity,
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Change art style
        function setArtStyle(styleName) {
          if (ART_STYLES[styleName]) {
            currentArtStyle = styleName;
            console.log(`Art style changed to: ${ART_STYLES[styleName].name}`);
          }
        }

        // ==========================================
        // VINYL STYLE BUILDERS (Phase 2)
        // ==========================================

        // Helper: Get colors for a builder
        function getBuilderColors(type, colorOverride, options) {
          const config = ANIMAL_CONFIG[type];

          // Get variant colors
          let variantKey = options.variant;
          if (!variantKey) {
            const variants = ANIMAL_VARIANTS[type];
            if (variants) {
              const variantKeys = Object.keys(variants);
              variantKey =
                variantKeys[Math.floor(Math.random() * variantKeys.length)];
            }
          }

          const variantColors = getVariantColors(type, variantKey);
          let primaryColor = variantColors
            ? variantColors.primary
            : config.primaryColor;
          let secondaryColor = variantColors
            ? variantColors.secondary
            : config.secondaryColor;
          let accentColor = variantColors
            ? variantColors.accent
            : config.accentColor;

          // Color palette override
          if (colorOverride && COLOR_PALETTES[colorOverride]) {
            primaryColor = COLOR_PALETTES[colorOverride].primary;
            secondaryColor = COLOR_PALETTES[colorOverride].secondary;
          }

          return { primaryColor, secondaryColor, accentColor, variantKey };
        }

        // ===== VINYL BUNNY BUILDER =====
        function createBunnyVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Create materials
          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);

          // Pear-shaped body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          body.scale.set(0.88, 1.12, 1.02);
          body.position.y = 0.45;
          body.castShadow = true;
          animal.add(body);

          // Hindquarters
          const hindquarters = new THREE.Mesh(
            new THREE.SphereGeometry(0.38, 24, 24),
            primaryMat
          );
          hindquarters.position.set(0, 0.28, -0.18);
          hindquarters.castShadow = true;
          animal.add(hindquarters);

          // Body transition
          const bodyTransition = new THREE.Mesh(
            new THREE.SphereGeometry(0.25, 16, 16),
            primaryMat
          );
          bodyTransition.position.set(0, 0.75, 0);
          animal.add(bodyTransition);

          // Head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 32, 32),
            primaryMat
          );
          head.scale.set(1.12, 1.0, 1.0);
          head.position.y = 1.08;
          head.castShadow = true;
          animal.add(head);

          // Cheeks and blush
          [-1, 1].forEach((side) => {
            const cheek = new THREE.Mesh(
              new THREE.SphereGeometry(0.17, 20, 20),
              primaryMat
            );
            cheek.position.set(side * 0.3, 0.94, 0.16);
            animal.add(cheek);

            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.06, 16),
              new THREE.MeshPhysicalMaterial({
                color: 0xffb6c1,
                transparent: true,
                opacity: 0.35,
                roughness: 0.6,
              })
            );
            blush.position.set(side * 0.34, 0.92, 0.28);
            blush.rotation.y = side * 0.3;
            animal.add(blush);
          });

          // Ears
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const earOuter = new THREE.Group();

            // Main ear
            const ear = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.12, 0.75, 12, 20),
              primaryMat
            );
            ear.scale.set(1.15, 1, 0.45);
            earOuter.add(ear);

            // Inner ear
            const inner = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.07, 0.58, 10, 16),
              secondaryMat
            );
            inner.scale.set(1.1, 1, 0.32);
            inner.position.z = 0.025;
            earOuter.add(inner);

            // Ear tip
            const tip = new THREE.Mesh(
              new THREE.SphereGeometry(0.11, 16, 16),
              primaryMat
            );
            tip.scale.set(1.15, 0.85, 0.45);
            tip.position.y = 0.42;
            earOuter.add(tip);

            earOuter.position.set(side * 0.2, 1.55, -0.02);
            earOuter.rotation.z = side * -0.18;
            earOuter.rotation.x = -0.08;
            earGroup.add(earOuter);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Eyes
          [-1, 1].forEach((side) => {
            const eye = createEye(0.9, false, { irisColor: 0x4a3020 });
            eye.position.set(side * 0.19, 1.12, 0.34);
            animal.add(eye);
          });

          // Nose
          const nose = new THREE.Group();
          const noseTop = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 20, 20),
            getMaterial(0xffb6c1)
          );
          noseTop.scale.set(1.35, 0.72, 1);
          nose.add(noseTop);
          nose.position.set(0, 1.02, 0.4);
          animal.userData.animationData.nose = nose;
          animal.add(nose);

          // Whiskers
          [-1, 1].forEach((side) => {
            for (let i = 0; i < 3; i++) {
              const whisker = new THREE.Mesh(
                new THREE.CylinderGeometry(0.003, 0.001, 0.25, 6),
                getMaterial(0xffffff)
              );
              whisker.rotation.z = (Math.PI / 2) * side;
              whisker.rotation.y = (i - 1) * 0.28;
              whisker.position.set(side * 0.2, 1.0 + (i - 1) * 0.028, 0.34);
              animal.add(whisker);
            }
          });

          // Fluffy tail
          const tailGroup = new THREE.Group();
          const tailCore = new THREE.Mesh(
            new THREE.SphereGeometry(0.11, 20, 20),
            primaryMat
          );
          tailGroup.add(tailCore);

          for (let i = 0; i < 12; i++) {
            const puffSize = 0.055 + Math.random() * 0.025;
            const puff = new THREE.Mesh(
              new THREE.SphereGeometry(puffSize, 12, 12),
              i % 3 === 0 ? secondaryMat : primaryMat
            );
            const angle = (i / 12) * Math.PI * 2;
            const radius = 0.065 + Math.random() * 0.02;
            puff.position.set(
              Math.cos(angle) * radius,
              Math.sin(angle * 0.6) * 0.05,
              Math.sin(angle) * radius
            );
            tailGroup.add(puff);
          }
          tailGroup.position.set(0, 0.5, -0.4);
          animal.add(tailGroup);

          // Legs
          [-1, 1].forEach((side) => {
            // Front legs
            const frontLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.075, 0.16, 10, 14),
              primaryMat
            );
            frontLeg.position.set(side * 0.22, 0.16, 0.22);
            animal.add(frontLeg);

            // Front paws
            const frontPaw = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 12, 12),
              primaryMat
            );
            frontPaw.scale.set(1, 0.6, 1.3);
            frontPaw.position.set(side * 0.22, 0.04, 0.28);
            animal.add(frontPaw);

            // Back legs
            const thigh = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 16, 16),
              primaryMat
            );
            thigh.scale.set(0.9, 1.1, 1);
            thigh.position.set(side * 0.24, 0.25, -0.12);
            animal.add(thigh);

            const backLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.11, 0.22, 10, 14),
              primaryMat
            );
            backLeg.position.set(side * 0.24, 0.14, -0.08);
            backLeg.rotation.x = 0.35;
            animal.add(backLeg);

            // Back feet
            const backFoot = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.085, 0.2, 10, 14),
              primaryMat
            );
            backFoot.rotation.x = Math.PI / 2;
            backFoot.position.set(side * 0.24, 0.05, 0.08);
            animal.add(backFoot);

            // Foot pads
            const footPad = new THREE.Mesh(
              new THREE.SphereGeometry(0.04, 10, 10),
              secondaryMat
            );
            footPad.scale.set(1.2, 0.5, 1.5);
            footPad.position.set(side * 0.24, 0.02, 0.12);
            animal.add(footPad);
          });

          return animal;
        }

        // ===== VINYL BEAR BUILDER =====
        function createBearVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Barrel-shaped torso
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.58, 32, 32),
            primaryMat
          );
          body.scale.set(1.32, 1.0, 1.15);
          body.position.y = 0.55;
          body.castShadow = true;
          animal.add(body);

          // Shoulder hump
          const hump = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 20, 20),
            primaryMat
          );
          hump.scale.set(1.2, 0.9, 1);
          hump.position.set(0, 0.92, -0.12);
          animal.add(hump);

          // Belly patch
          const belly = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 24, 24),
            secondaryMat
          );
          belly.scale.set(1.0, 1.15, 0.52);
          belly.position.set(0, 0.48, 0.28);
          animal.add(belly);

          // Head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.48, 32, 32),
            primaryMat
          );
          head.scale.set(1.12, 1.0, 1.0);
          head.position.y = 1.22;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 16, 16),
              primaryMat
            );
            cheek.position.set(side * 0.32, 1.12, 0.22);
            animal.add(cheek);
          });

          // Muzzle
          const muzzleBase = new THREE.Mesh(
            new THREE.SphereGeometry(0.18, 20, 20),
            secondaryMat
          );
          muzzleBase.scale.set(1.1, 0.85, 0.9);
          muzzleBase.position.set(0, 1.1, 0.42);
          animal.add(muzzleBase);

          const muzzleFront = new THREE.Mesh(
            new THREE.SphereGeometry(0.14, 18, 18),
            secondaryMat
          );
          muzzleFront.scale.set(1.0, 0.78, 0.85);
          muzzleFront.position.set(0, 1.1, 0.52);
          animal.add(muzzleFront);

          // Nose
          const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.09, 14, 14),
            accentMat
          );
          nose.scale.set(1.35, 0.88, 1.0);
          nose.position.set(0, 1.16, 0.58);
          animal.add(nose);

          // Ears
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = new THREE.Mesh(
              new THREE.SphereGeometry(0.16, 18, 18),
              primaryMat
            );
            earGroup.add(ear);

            const innerEar = new THREE.Mesh(
              new THREE.SphereGeometry(0.09, 14, 14),
              secondaryMat
            );
            innerEar.position.z = 0.08;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.32, 1.52, 0.05);
            earGroup.rotation.z = side * 0.15;
            animal.add(earGroup);
          });

          // Eyes
          [-1, 1].forEach((side) => {
            const eye = createEye(0.7, false, { irisColor: 0x2a1810 });
            eye.position.set(side * 0.22, 1.26, 0.4);
            animal.add(eye);
          });

          // Legs with paws
          const legPositions = [
            { x: -0.38, z: 0.22 },
            { x: 0.38, z: 0.22 },
            { x: -0.32, z: -0.28 },
            { x: 0.32, z: -0.28 },
          ];

          legPositions.forEach((pos) => {
            const leg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.15, 0.18, 0.4, 18),
              primaryMat
            );
            leg.position.set(pos.x, 0.2, pos.z);
            animal.add(leg);

            const paw = createPaw(0.15, primaryMat, secondaryMat);
            paw.position.set(pos.x, 0.02, pos.z + 0.06);
            animal.add(paw);

            // Claws
            for (let c = -2; c <= 2; c++) {
              const claw = new THREE.Mesh(
                new THREE.ConeGeometry(0.02, 0.07, 10),
                accentMat
              );
              claw.rotation.x = -Math.PI / 2 - 0.35;
              claw.rotation.z = c * 0.08;
              claw.position.set(pos.x + c * 0.038, 0.01, pos.z + 0.2);
              animal.add(claw);
            }
          });

          return animal;
        }

        // ===== VINYL PENGUIN BUILDER =====
        function createPenguinVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Egg-shaped body with better proportions
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.52, 32, 32),
            primaryMat
          );
          body.scale.set(1.0, 1.15, 0.95);
          body.position.y = 0.55;
          body.castShadow = true;
          animal.add(body);

          // Rounder white belly with better coverage
          const belly = new THREE.Mesh(
            new THREE.SphereGeometry(0.46, 32, 32),
            secondaryMat
          );
          belly.scale.set(0.92, 1.05, 0.52);
          belly.position.set(0, 0.52, 0.2);
          animal.add(belly);

          // Belly highlight for premium feel
          const bellyHighlight = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 24, 24),
            secondaryMat
          );
          bellyHighlight.scale.set(0.8, 0.6, 0.3);
          bellyHighlight.position.set(0, 0.65, 0.28);
          animal.add(bellyHighlight);

          // Head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          head.scale.set(1.02, 0.98, 1.0);
          head.position.y = 1.12;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face patch with better shape
          const facePatch = new THREE.Mesh(
            new THREE.SphereGeometry(0.28, 24, 24),
            secondaryMat
          );
          facePatch.scale.set(1.05, 1.0, 0.42);
          facePatch.position.set(0, 1.1, 0.28);
          animal.add(facePatch);

          // Cheek patches for character
          [-1, 1].forEach((side) => {
            const cheek = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 16, 16),
              new THREE.MeshPhysicalMaterial({
                color: 0xffccaa,
                roughness: 0.5,
                transparent: true,
                opacity: 0.4,
              })
            );
            cheek.scale.set(1.2, 0.8, 0.5);
            cheek.position.set(side * 0.25, 1.02, 0.28);
            animal.add(cheek);
          });

          // Eyes with better size
          [-1, 1].forEach((side) => {
            const eye = createEye(0.9, false, { irisColor: 0x1a1a1a });
            eye.position.set(side * 0.14, 1.14, 0.34);
            animal.add(eye);
          });

          // Improved beak with two parts
          const beakTop = new THREE.Mesh(
            new THREE.ConeGeometry(0.08, 0.16, 16),
            accentMat
          );
          beakTop.rotation.x = -Math.PI / 2 - 0.25;
          beakTop.position.set(0, 1.04, 0.42);
          animal.add(beakTop);

          const beakBottom = new THREE.Mesh(
            new THREE.ConeGeometry(0.06, 0.1, 12),
            accentMat
          );
          beakBottom.rotation.x = -Math.PI / 2 - 0.5;
          beakBottom.position.set(0, 0.98, 0.4);
          animal.add(beakBottom);

          // Flippers with feather edge detail
          [-1, 1].forEach((side) => {
            const flipperGroup = new THREE.Group();

            const flipper = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.085, 0.38, 10, 16),
              primaryMat
            );
            flipper.scale.set(0.5, 1, 1);
            flipperGroup.add(flipper);

            // Feather edge hints
            for (let i = 0; i < 4; i++) {
              const featherEdge = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                primaryMat
              );
              featherEdge.scale.set(0.8, 1.2, 0.6);
              featherEdge.position.set(side * 0.02, -0.12 - i * 0.06, 0.02);
              flipperGroup.add(featherEdge);
            }

            flipperGroup.rotation.z = side * 0.35;
            flipperGroup.position.set(side * 0.48, 0.55, 0);
            animal.add(flipperGroup);
          });

          // Improved feet with webbing detail
          [-1, 1].forEach((side) => {
            const foot = new THREE.Mesh(
              new THREE.SphereGeometry(0.11, 16, 16),
              accentMat
            );
            foot.scale.set(1.25, 0.38, 1.6);
            foot.position.set(side * 0.17, 0.04, 0.1);
            animal.add(foot);

            // Toe webbing hints
            for (let t = 0; t < 3; t++) {
              const toe = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 8, 8),
                accentMat
              );
              toe.scale.set(0.8, 0.4, 1.8);
              toe.position.set(side * 0.17 + (t - 1) * 0.04, 0.03, 0.18);
              animal.add(toe);
            }
          });

          return animal;
        }

        // ===== VINYL FOX BUILDER =====
        function createFoxVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Sleek elongated body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          body.scale.set(1.0, 0.88, 1.35);
          body.position.y = 0.46;
          body.castShadow = true;
          animal.add(body);
          animal.userData.animationData.body = body;

          // White chest/bib extending up
          const chest = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 26, 26),
            secondaryMat
          );
          chest.scale.set(0.82, 1.05, 0.62);
          chest.position.set(0, 0.52, 0.22);
          animal.add(chest);

          // Head with slightly pointed shape
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.34, 32, 32),
            primaryMat
          );
          head.scale.set(1.12, 0.96, 1.02);
          head.position.y = 0.98;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // White cheek fur
          [-1, 1].forEach((side) => {
            const cheekFur = new THREE.Mesh(
              new THREE.SphereGeometry(0.1, 14, 14),
              secondaryMat
            );
            cheekFur.scale.set(1.2, 0.85, 0.6);
            cheekFur.position.set(side * 0.28, 0.92, 0.15);
            animal.add(cheekFur);
          });

          // Pointed snout
          const snout = new THREE.Mesh(
            new THREE.ConeGeometry(0.13, 0.3, 18),
            secondaryMat
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.9, 0.38);
          animal.add(snout);

          // Shiny black nose
          const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.045, 14, 14),
            accentMat
          );
          nose.scale.set(1.2, 0.9, 1.0);
          nose.position.set(0, 0.9, 0.52);
          animal.add(nose);

          // Large pointed ears with BLACK TIPS
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const earOuter = new THREE.Group();

            // Main ear
            const ear = new THREE.Mesh(
              new THREE.ConeGeometry(0.13, 0.28, 14),
              primaryMat
            );
            earOuter.add(ear);

            // Black tip
            const tip = new THREE.Mesh(
              new THREE.ConeGeometry(0.06, 0.1, 10),
              accentMat
            );
            tip.position.y = 0.12;
            earOuter.add(tip);

            // Inner ear (pink)
            const innerEar = new THREE.Mesh(
              new THREE.ConeGeometry(0.07, 0.18, 12),
              secondaryMat
            );
            innerEar.position.set(0, -0.02, 0.02);
            earOuter.add(innerEar);

            earOuter.position.set(side * 0.24, 1.28, -0.04);
            earOuter.rotation.z = side * -0.2;
            earGroup.add(earOuter);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Amber eyes with highlights
          [-1, 1].forEach((side) => {
            const eye = createEye(0.8, false, { irisColor: 0xd4a574 });
            eye.position.set(side * 0.17, 1.0, 0.28);
            animal.add(eye);
          });

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.04, 14),
              new THREE.MeshPhysicalMaterial({
                color: 0xffcccc,
                transparent: true,
                opacity: 0.25,
                roughness: 0.7,
              })
            );
            blush.position.set(side * 0.3, 0.9, 0.2);
            blush.rotation.y = side * 0.3;
            animal.add(blush);
          });

          // Magnificent bushy tail
          const tailGroup = new THREE.Group();

          // Tail base
          const tailBase = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.14, 0.35, 14, 18),
            primaryMat
          );
          tailBase.rotation.x = 0.7;
          tailGroup.add(tailBase);

          // Tail mid
          const tailMid = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 14, 14),
            primaryMat
          );
          tailMid.scale.set(1.0, 0.9, 1.3);
          tailMid.position.set(0, 0.28, -0.15);
          tailGroup.add(tailMid);

          // White tail tip
          const tailTip = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 14, 14),
            secondaryMat
          );
          tailTip.scale.set(1.0, 0.9, 1.2);
          tailTip.position.set(0, 0.38, -0.25);
          tailGroup.add(tailTip);

          tailGroup.position.set(0, 0.35, -0.45);
          animal.userData.animationData.tail = tailGroup;
          animal.add(tailGroup);

          // Legs with black "sock" markings
          [-1, 1].forEach((side) => {
            // Front legs
            const frontLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.065, 0.22, 10, 14),
              primaryMat
            );
            frontLeg.position.set(side * 0.19, 0.12, 0.22);
            animal.add(frontLeg);

            // Front paw (darker)
            const frontPaw = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 10, 10),
              accentMat
            );
            frontPaw.scale.set(1.1, 0.6, 1.2);
            frontPaw.position.set(side * 0.19, 0.04, 0.24);
            animal.add(frontPaw);

            // Back legs
            const backLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.075, 0.24, 10, 14),
              primaryMat
            );
            backLeg.position.set(side * 0.18, 0.13, -0.22);
            animal.add(backLeg);

            // Back paw
            const backPaw = new THREE.Mesh(
              new THREE.SphereGeometry(0.055, 10, 10),
              accentMat
            );
            backPaw.scale.set(1.0, 0.55, 1.15);
            backPaw.position.set(side * 0.18, 0.04, -0.2);
            animal.add(backPaw);
          });

          return animal;
        }

        // ===== VINYL CAT BUILDER =====
        function createCatVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);

          // Sleek elongated body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.36, 32, 32),
            primaryMat
          );
          body.scale.set(0.92, 0.88, 1.25);
          body.position.y = 0.42;
          body.castShadow = true;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Chest
          const chest = new THREE.Mesh(
            new THREE.SphereGeometry(0.25, 22, 22),
            secondaryMat
          );
          chest.scale.set(0.8, 0.9, 0.55);
          chest.position.set(0, 0.42, 0.2);
          animal.add(chest);

          // Head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 32, 32),
            primaryMat
          );
          head.scale.set(1.12, 1.0, 0.96);
          head.position.y = 0.88;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = new THREE.Mesh(
              new THREE.SphereGeometry(0.1, 14, 14),
              primaryMat
            );
            cheek.position.set(side * 0.24, 0.82, 0.16);
            animal.add(cheek);
          });

          // Muzzle
          const muzzle = new THREE.Mesh(
            new THREE.SphereGeometry(0.13, 18, 18),
            secondaryMat
          );
          muzzle.scale.set(1.02, 0.72, 0.82);
          muzzle.position.set(0, 0.8, 0.27);
          animal.add(muzzle);

          // Pink nose
          const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.035, 12, 12),
            getMaterial(0xffb6c1)
          );
          nose.scale.set(1.2, 0.85, 1.0);
          nose.position.set(0, 0.84, 0.35);
          animal.add(nose);

          // Triangle ears with inner detail
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const earOuter = new THREE.Group();

            const ear = new THREE.Mesh(
              new THREE.ConeGeometry(0.11, 0.22, 14),
              primaryMat
            );
            earOuter.add(ear);

            const innerEar = new THREE.Mesh(
              new THREE.ConeGeometry(0.06, 0.14, 12),
              getMaterial(0xffb6c1)
            );
            innerEar.position.set(0, -0.02, 0.02);
            earOuter.add(innerEar);

            earOuter.position.set(side * 0.22, 1.15, -0.04);
            earOuter.rotation.z = side * -0.16;
            earGroup.add(earOuter);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Cat eyes (almond shaped with vertical pupils)
          [-1, 1].forEach((side) => {
            const eye = createEye(0.9, false, { irisColor: 0x7cfc00 });
            eye.scale.set(1.22, 0.92, 1);
            eye.position.set(side * 0.15, 0.9, 0.26);
            animal.add(eye);
          });

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.04, 14),
              new THREE.MeshPhysicalMaterial({
                color: 0xffcccc,
                transparent: true,
                opacity: 0.25,
                roughness: 0.7,
              })
            );
            blush.position.set(side * 0.28, 0.78, 0.2);
            blush.rotation.y = side * 0.3;
            animal.add(blush);
          });

          // Whiskers (6 total)
          [-1, 1].forEach((side) => {
            for (let i = 0; i < 3; i++) {
              const whisker = new THREE.Mesh(
                new THREE.CylinderGeometry(0.003, 0.001, 0.22, 8),
                getMaterial(0xffffff)
              );
              whisker.rotation.z = (Math.PI / 2) * side;
              whisker.rotation.y = (i - 1) * 0.22;
              whisker.position.set(side * 0.16, 0.8 + (i - 1) * 0.022, 0.3);
              animal.add(whisker);
            }
          });

          // S-curved tail
          const tailGroup = new THREE.Group();
          for (let s = 0; s < 5; s++) {
            const seg = new THREE.Mesh(
              new THREE.SphereGeometry(0.045 - s * 0.005, 10, 10),
              primaryMat
            );
            seg.scale.set(1.0, 1.2, 1.0);
            const angle = s * 0.4;
            seg.position.set(Math.sin(angle) * 0.08, s * 0.1, -s * 0.06);
            tailGroup.add(seg);
          }
          tailGroup.rotation.x = 1.0;
          tailGroup.position.set(0, 0.42, -0.38);
          animal.userData.animationData.tail = tailGroup;
          animal.add(tailGroup);

          // Legs with paw pads
          [-1, 1].forEach((side) => {
            // Front legs
            const frontLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.055, 0.2, 10, 14),
              primaryMat
            );
            frontLeg.position.set(side * 0.16, 0.11, 0.16);
            animal.add(frontLeg);

            // Front paw
            const frontPaw = new THREE.Mesh(
              new THREE.SphereGeometry(0.045, 10, 10),
              primaryMat
            );
            frontPaw.scale.set(1.1, 0.55, 1.15);
            frontPaw.position.set(side * 0.16, 0.04, 0.18);
            animal.add(frontPaw);

            // Back legs
            const backLeg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.065, 0.22, 10, 14),
              primaryMat
            );
            backLeg.position.set(side * 0.16, 0.12, -0.2);
            animal.add(backLeg);

            // Back paw
            const backPaw = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 10, 10),
              primaryMat
            );
            backPaw.scale.set(1.05, 0.5, 1.1);
            backPaw.position.set(side * 0.16, 0.04, -0.18);
            animal.add(backPaw);
          });

          return animal;
        }

        // ===== VINYL OWL BUILDER =====
        function createOwlVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Round fluffy body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          body.scale.set(1.0, 1.12, 0.92);
          body.position.y = 0.46;
          body.castShadow = true;
          animal.add(body);

          // Layered chest feathers
          const chest = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 24, 24),
            secondaryMat
          );
          chest.scale.set(0.92, 1.05, 0.52);
          chest.position.set(0, 0.42, 0.2);
          animal.add(chest);

          // Feather layer detail
          for (let i = 0; i < 3; i++) {
            const featherRow = new THREE.Mesh(
              new THREE.SphereGeometry(0.22 - i * 0.04, 16, 16),
              i % 2 === 0 ? secondaryMat : primaryMat
            );
            featherRow.scale.set(1.1, 0.35, 0.4);
            featherRow.position.set(0, 0.28 + i * 0.12, 0.22);
            animal.add(featherRow);
          }

          // Large round head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 32, 32),
            primaryMat
          );
          head.scale.set(1.02, 1.0, 0.98);
          head.position.y = 0.98;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Enhanced facial disc
          const facialDisc = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 28, 28),
            secondaryMat
          );
          facialDisc.scale.set(1.05, 1.0, 0.42);
          facialDisc.position.set(0, 0.96, 0.24);
          animal.add(facialDisc);

          // Heart-shaped face outline
          const faceOutline = new THREE.Mesh(
            new THREE.TorusGeometry(0.22, 0.025, 8, 24),
            primaryMat
          );
          faceOutline.position.set(0, 0.96, 0.32);
          animal.add(faceOutline);

          // LARGER dramatic eyes with rings
          [-1, 1].forEach((side) => {
            // Outer eye ring
            const outerRing = new THREE.Mesh(
              new THREE.TorusGeometry(0.13, 0.025, 10, 28),
              primaryMat
            );
            outerRing.position.set(side * 0.14, 1.0, 0.32);
            animal.add(outerRing);

            // Inner eye ring
            const innerRing = new THREE.Mesh(
              new THREE.TorusGeometry(0.1, 0.018, 8, 24),
              secondaryMat
            );
            innerRing.position.set(side * 0.14, 1.0, 0.34);
            animal.add(innerRing);

            // Larger eye
            const eye = createEye(1.2, false, { irisColor: 0xffa500 });
            eye.position.set(side * 0.14, 1.0, 0.36);
            animal.add(eye);
          });

          // Detailed beak
          const beakTop = new THREE.Mesh(
            new THREE.ConeGeometry(0.055, 0.1, 12),
            accentMat
          );
          beakTop.rotation.x = -Math.PI / 2 - 0.35;
          beakTop.position.set(0, 0.88, 0.38);
          animal.add(beakTop);

          const beakHook = new THREE.Mesh(
            new THREE.SphereGeometry(0.025, 10, 10),
            accentMat
          );
          beakHook.position.set(0, 0.85, 0.42);
          animal.add(beakHook);

          // Enhanced ear tufts with multiple feathers
          [-1, 1].forEach((side) => {
            const tuftGroup = new THREE.Group();

            for (let i = 0; i < 3; i++) {
              const tuft = new THREE.Mesh(
                new THREE.ConeGeometry(0.04 - i * 0.01, 0.14 - i * 0.02, 10),
                primaryMat
              );
              tuft.position.set((i - 1) * side * 0.025, i * 0.03, 0);
              tuft.rotation.z = side * -0.25;
              tuftGroup.add(tuft);
            }

            tuftGroup.position.set(side * 0.26, 1.28, -0.02);
            animal.add(tuftGroup);
          });

          // Layered wings with feather tips
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wingBase = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 18, 18),
              primaryMat
            );
            wingBase.scale.set(0.42, 1.1, 0.85);
            wingGroup.add(wingBase);

            // Feather tips
            for (let f = 0; f < 4; f++) {
              const featherTip = new THREE.Mesh(
                new THREE.ConeGeometry(0.035, 0.1, 8),
                primaryMat
              );
              featherTip.position.set(0, -0.15 - f * 0.06, 0.02);
              featherTip.rotation.x = 0.4;
              wingGroup.add(featherTip);
            }

            wingGroup.position.set(side * 0.4, 0.46, -0.04);
            animal.add(wingGroup);
          });

          // Detailed talons with claws
          [-1, 1].forEach((side) => {
            const footBase = new THREE.Mesh(
              new THREE.SphereGeometry(0.065, 12, 12),
              accentMat
            );
            footBase.scale.set(1.2, 0.55, 1.4);
            footBase.position.set(side * 0.12, 0.045, 0.05);
            animal.add(footBase);

            // Individual claws
            for (let c = 0; c < 3; c++) {
              const claw = new THREE.Mesh(
                new THREE.ConeGeometry(0.015, 0.05, 8),
                new THREE.MeshPhysicalMaterial({
                  color: 0x2a2a2a,
                  roughness: 0.4,
                })
              );
              claw.rotation.x = Math.PI / 2;
              claw.position.set(side * 0.12 + (c - 1) * 0.025, 0.02, 0.1);
              animal.add(claw);
            }
          });

          return animal;
        }

        // ===== VINYL PANDA BUILDER =====
        function createPandaVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor); // White
          const secondaryMat = createStyledMaterial(secondaryColor); // Black

          // Chubby round body (white)
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.52, 32, 32),
            primaryMat
          );
          body.scale.set(1.05, 1.0, 0.98);
          body.position.y = 0.55;
          body.castShadow = true;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly highlight
          const belly = new THREE.Mesh(
            new THREE.SphereGeometry(0.38, 24, 24),
            primaryMat
          );
          belly.scale.set(0.9, 1.0, 0.5);
          belly.position.set(0, 0.52, 0.26);
          animal.add(belly);

          // Head (white, slightly larger)
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.45, 32, 32),
            primaryMat
          );
          head.scale.set(1.08, 1.0, 1.0);
          head.position.y = 1.18;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheek puffs
          [-1, 1].forEach((side) => {
            const cheek = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 16, 16),
              primaryMat
            );
            cheek.position.set(side * 0.32, 1.08, 0.22);
            animal.add(cheek);
          });

          // Tear-drop shaped eye patches (black) - signature panda look
          [-1, 1].forEach((side) => {
            const patchGroup = new THREE.Group();

            // Main eye patch
            const eyePatch = new THREE.Mesh(
              new THREE.SphereGeometry(0.17, 18, 18),
              secondaryMat
            );
            eyePatch.scale.set(1.25, 1.4, 0.52);
            patchGroup.add(eyePatch);

            // Tear-drop extension downward
            const tearDrop = new THREE.Mesh(
              new THREE.SphereGeometry(0.1, 14, 14),
              secondaryMat
            );
            tearDrop.scale.set(1.0, 1.3, 0.48);
            tearDrop.position.set(side * 0.04, -0.12, 0.02);
            patchGroup.add(tearDrop);

            patchGroup.position.set(side * 0.19, 1.2, 0.3);
            patchGroup.rotation.z = side * -0.15;
            animal.add(patchGroup);

            // Eye with highlights
            const eyeWhite = new THREE.Mesh(
              new THREE.SphereGeometry(0.065, 16, 16),
              getMaterial(0xffffff)
            );
            eyeWhite.position.set(side * 0.19, 1.2, 0.38);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              new THREE.SphereGeometry(0.045, 14, 14),
              getMaterial(0x1a1a1a)
            );
            iris.position.set(side * 0.19, 1.2, 0.42);
            animal.add(iris);

            // Double highlights
            const highlight1 = new THREE.Mesh(
              new THREE.SphereGeometry(0.018, 10, 10),
              getMaterial(0xffffff)
            );
            highlight1.position.set(side * 0.175, 1.22, 0.44);
            animal.add(highlight1);

            const highlight2 = new THREE.Mesh(
              new THREE.SphereGeometry(0.01, 8, 8),
              getMaterial(0xffffff)
            );
            highlight2.position.set(side * 0.2, 1.18, 0.44);
            animal.add(highlight2);
          });

          // Round black ears with inner detail
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const ear = new THREE.Mesh(
              new THREE.SphereGeometry(0.16, 18, 18),
              secondaryMat
            );
            ear.position.set(side * 0.34, 1.48, 0.02);
            earGroup.add(ear);

            // Inner ear highlight
            const innerEar = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              getMaterial(0x333333)
            );
            innerEar.position.set(side * 0.36, 1.48, 0.08);
            earGroup.add(innerEar);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Muzzle area
          const muzzle = new THREE.Mesh(
            new THREE.SphereGeometry(0.14, 16, 16),
            primaryMat
          );
          muzzle.scale.set(1.1, 0.8, 0.85);
          muzzle.position.set(0, 1.05, 0.38);
          animal.add(muzzle);

          // Black nose
          const nose = new THREE.Mesh(
            new THREE.SphereGeometry(0.065, 14, 14),
            secondaryMat
          );
          nose.scale.set(1.3, 0.9, 1.0);
          nose.position.set(0, 1.08, 0.48);
          animal.add(nose);

          // Mouth line hint
          const mouthLine = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.008, 0.06, 6, 8),
            secondaryMat
          );
          mouthLine.position.set(0, 1.0, 0.44);
          animal.add(mouthLine);

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.05, 16),
              new THREE.MeshPhysicalMaterial({
                color: 0xffb6c1,
                transparent: true,
                opacity: 0.3,
                roughness: 0.7,
              })
            );
            blush.position.set(side * 0.35, 1.02, 0.32);
            blush.rotation.y = side * 0.25;
            animal.add(blush);
          });

          // Arms (black) with paw detail
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.13, 0.28, 12, 16),
              secondaryMat
            );
            armGroup.add(arm);

            // Paw pad
            const paw = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              secondaryMat
            );
            paw.scale.set(1.2, 0.7, 1.0);
            paw.position.y = -0.18;
            armGroup.add(paw);

            armGroup.rotation.z = side * 0.5;
            armGroup.position.set(side * 0.48, 0.58, 0.12);
            animal.add(armGroup);
          });

          // Legs (black) with better proportions
          [-1, 1].forEach((side) => {
            const leg = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.14, 0.22, 12, 16),
              secondaryMat
            );
            leg.position.set(side * 0.24, 0.12, 0);
            animal.add(leg);

            // Foot pad
            const foot = new THREE.Mesh(
              new THREE.SphereGeometry(0.1, 12, 12),
              secondaryMat
            );
            foot.scale.set(1.15, 0.45, 1.2);
            foot.position.set(side * 0.24, 0.04, 0.02);
            animal.add(foot);
          });

          // Tiny tail
          const tail = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 12, 12),
            primaryMat
          );
          tail.position.set(0, 0.35, -0.48);
          animal.add(tail);

          return animal;
        }

        // ===== VINYL DUCK BUILDER =====
        function createDuckVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Plump round body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          body.scale.set(1.02, 0.88, 1.25);
          body.position.y = 0.42;
          body.castShadow = true;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Breast/chest highlight
          const breast = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 24, 24),
            secondaryMat
          );
          breast.scale.set(0.9, 0.85, 0.55);
          breast.position.set(0, 0.38, 0.24);
          animal.add(breast);

          // Neck transition
          const neck = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.14, 0.15, 16, 20),
            primaryMat
          );
          neck.position.set(0, 0.68, 0.08);
          animal.add(neck);

          // Head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 32, 32),
            primaryMat
          );
          head.scale.set(1.0, 0.95, 1.0);
          head.position.y = 0.9;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // White neck ring (collar)
          const collar = new THREE.Mesh(
            new THREE.TorusGeometry(0.15, 0.035, 12, 24),
            secondaryMat
          );
          collar.position.set(0, 0.72, 0.08);
          collar.rotation.x = Math.PI / 2;
          animal.add(collar);

          // Wide flat bill - two parts for realism
          const billTop = new THREE.Mesh(
            new THREE.SphereGeometry(0.14, 18, 18),
            accentMat
          );
          billTop.scale.set(1.1, 0.4, 1.5);
          billTop.position.set(0, 0.86, 0.36);
          animal.add(billTop);

          const billBottom = new THREE.Mesh(
            new THREE.SphereGeometry(0.12, 16, 16),
            accentMat
          );
          billBottom.scale.set(1.0, 0.3, 1.4);
          billBottom.position.set(0, 0.82, 0.35);
          animal.add(billBottom);

          // Bill tip detail
          const billTip = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 12, 12),
            accentMat
          );
          billTip.scale.set(1.2, 0.5, 1.8);
          billTip.position.set(0, 0.84, 0.48);
          animal.add(billTip);

          // Nostrils on bill
          [-1, 1].forEach((side) => {
            const nostril = new THREE.Mesh(
              new THREE.SphereGeometry(0.015, 8, 8),
              getMaterial(0x333333)
            );
            nostril.position.set(side * 0.05, 0.88, 0.42);
            animal.add(nostril);
          });

          // Eyes with white rings
          [-1, 1].forEach((side) => {
            // White eye ring
            const eyeRing = new THREE.Mesh(
              new THREE.SphereGeometry(0.065, 14, 14),
              getMaterial(0xffffff)
            );
            eyeRing.position.set(side * 0.15, 0.92, 0.22);
            animal.add(eyeRing);

            // Iris
            const iris = new THREE.Mesh(
              new THREE.SphereGeometry(0.04, 12, 12),
              getMaterial(0x1a1a1a)
            );
            iris.position.set(side * 0.15, 0.92, 0.27);
            animal.add(iris);

            // Highlight
            const highlight = new THREE.Mesh(
              new THREE.SphereGeometry(0.015, 8, 8),
              getMaterial(0xffffff)
            );
            highlight.position.set(side * 0.14, 0.94, 0.29);
            animal.add(highlight);
          });

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.04, 14),
              new THREE.MeshPhysicalMaterial({
                color: 0xffcccc,
                transparent: true,
                opacity: 0.3,
                roughness: 0.7,
              })
            );
            blush.position.set(side * 0.22, 0.86, 0.18);
            blush.rotation.y = side * 0.3;
            animal.add(blush);
          });

          // Wings with feather detail
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            // Main wing body
            const wing = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 18, 18),
              primaryMat
            );
            wing.scale.set(0.42, 0.85, 1.05);
            wingGroup.add(wing);

            // Feather tips
            for (let f = 0; f < 3; f++) {
              const feather = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.025, 0.08, 8, 10),
                primaryMat
              );
              feather.position.set(0, -0.12 - f * 0.06, -0.05 + f * 0.02);
              feather.rotation.x = 0.3;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.38, 0.42, -0.04);
            wingGroup.rotation.z = side * 0.15;
            animal.add(wingGroup);
          });

          // Tail feathers (tuft of multiple feathers)
          const tailGroup = new THREE.Group();
          for (let t = 0; t < 4; t++) {
            const tailFeather = new THREE.Mesh(
              new THREE.ConeGeometry(0.04 - t * 0.005, 0.12 + t * 0.02, 8),
              primaryMat
            );
            tailFeather.position.set((t - 1.5) * 0.025, 0, t * 0.015);
            tailFeather.rotation.x = Math.PI / 2 + 0.35;
            tailGroup.add(tailFeather);
          }
          tailGroup.position.set(0, 0.48, -0.48);
          animal.add(tailGroup);

          // Webbed feet with toes
          [-1, 1].forEach((side) => {
            const footGroup = new THREE.Group();

            // Main foot pad
            const foot = new THREE.Mesh(
              new THREE.SphereGeometry(0.09, 14, 14),
              accentMat
            );
            foot.scale.set(1.25, 0.32, 1.6);
            footGroup.add(foot);

            // Three webbed toes
            for (let toe = 0; toe < 3; toe++) {
              const toeMesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 10, 10),
                accentMat
              );
              toeMesh.scale.set(0.9, 0.4, 1.8);
              toeMesh.position.set((toe - 1) * 0.04, 0, 0.1);
              footGroup.add(toeMesh);
            }

            footGroup.position.set(side * 0.15, 0.04, 0.08);
            animal.add(footGroup);
          });

          return animal;
        }

        // ===== VINYL FROG BUILDER =====
        function createFrogVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);

          // Wide squat body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          body.scale.set(1.25, 0.72, 1.05);
          body.position.y = 0.32;
          body.castShadow = true;
          animal.add(body);

          // Belly with detail
          const belly = new THREE.Mesh(
            new THREE.SphereGeometry(0.34, 28, 28),
            secondaryMat
          );
          belly.scale.set(1.05, 0.62, 0.58);
          belly.position.set(0, 0.26, 0.2);
          animal.add(belly);

          // Wide head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.32, 32, 32),
            primaryMat
          );
          head.scale.set(1.35, 0.82, 1.02);
          head.position.set(0, 0.48, 0.15);
          animal.add(head);
          animal.userData.animationData.head = head;

          // LARGER bulging eyes
          [-1, 1].forEach((side) => {
            const eyeBulge = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 20, 20),
              primaryMat
            );
            eyeBulge.position.set(side * 0.22, 0.65, 0.18);
            animal.add(eyeBulge);

            const eye = createEye(1.15, false, { irisColor: 0xffd700 });
            eye.position.set(side * 0.22, 0.68, 0.28);
            animal.add(eye);
          });

          // Nostril hints
          [-1, 1].forEach((side) => {
            const nostril = new THREE.Mesh(
              new THREE.SphereGeometry(0.018, 8, 8),
              new THREE.MeshPhysicalMaterial({
                color: 0x2a3a2a,
                roughness: 0.8,
              })
            );
            nostril.position.set(side * 0.08, 0.52, 0.38);
            animal.add(nostril);
          });

          // Wide happy mouth
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.18, 0.022, 10, 28, Math.PI),
            secondaryMat
          );
          mouth.rotation.x = -Math.PI / 2;
          mouth.position.set(0, 0.38, 0.32);
          animal.add(mouth);

          // Front legs with fingers
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.055, 0.16, 10, 12),
              primaryMat
            );
            armGroup.add(arm);

            // Fingers
            for (let f = 0; f < 4; f++) {
              const finger = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.015, 0.05, 6, 8),
                primaryMat
              );
              finger.position.set((f - 1.5) * 0.022, -0.1, 0.02);
              finger.rotation.x = 0.25;
              armGroup.add(finger);
            }

            armGroup.rotation.z = side * 0.75;
            armGroup.position.set(side * 0.38, 0.16, 0.16);
            animal.add(armGroup);
          });

          // Powerful back legs with webbed feet
          [-1, 1].forEach((side) => {
            const thigh = new THREE.Mesh(
              new THREE.SphereGeometry(0.13, 14, 14),
              primaryMat
            );
            thigh.scale.set(0.85, 1.25, 1.0);
            thigh.position.set(side * 0.38, 0.22, -0.14);
            animal.add(thigh);

            const calf = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.065, 0.22, 10, 12),
              primaryMat
            );
            calf.rotation.x = 0.75;
            calf.position.set(side * 0.42, 0.09, -0.26);
            animal.add(calf);

            // Webbed foot
            const foot = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 14, 14),
              primaryMat
            );
            foot.scale.set(1.3, 0.45, 1.8);
            foot.position.set(side * 0.45, 0.04, -0.32);
            animal.add(foot);

            // Toe webbing
            for (let t = 0; t < 3; t++) {
              const toe = new THREE.Mesh(
                new THREE.SphereGeometry(0.022, 8, 8),
                primaryMat
              );
              toe.scale.set(0.8, 0.45, 2.0);
              toe.position.set(side * 0.45 + (t - 1) * 0.028, 0.03, -0.4);
              animal.add(toe);
            }
          });

          return animal;
        }

        // ===== VINYL ELEPHANT BUILDER =====
        function createElephantVinyl(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "vinyl";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);

          // Large barrel body
          const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.56, 36, 36),
            primaryMat
          );
          body.scale.set(1.22, 0.92, 1.02);
          body.position.y = 0.62;
          body.castShadow = true;
          animal.add(body);

          // Round head
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.42, 32, 32),
            primaryMat
          );
          head.scale.set(1.02, 1.0, 0.98);
          head.position.y = 1.12;
          head.castShadow = true;
          animal.add(head);
          animal.userData.animationData.head = head;

          // SEGMENTED trunk
          const trunkGroup = new THREE.Group();
          for (let s = 0; s < 5; s++) {
            const segSize = 0.1 - s * 0.012;
            const seg = new THREE.Mesh(
              new THREE.SphereGeometry(segSize, 14, 14),
              primaryMat
            );
            seg.scale.set(1.0, 0.85, 1.0);
            seg.position.y = -s * 0.08;
            trunkGroup.add(seg);
          }
          const trunkTip = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 12, 12),
            secondaryMat
          );
          trunkTip.position.set(0, -0.42, 0.04);
          trunkGroup.add(trunkTip);

          trunkGroup.position.set(0, 0.95, 0.42);
          trunkGroup.rotation.x = 0.35;
          animal.add(trunkGroup);
          animal.userData.animationData.trunk = trunkGroup;

          // Enhanced fan-shaped ears
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 24, 24),
              primaryMat
            );
            ear.scale.set(0.16, 1.05, 0.85);
            earGroup.add(ear);

            const innerEar = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 20, 20),
              secondaryMat
            );
            innerEar.scale.set(0.14, 0.82, 0.65);
            innerEar.position.z = 0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.42, 1.02, -0.04);
            earGroup.rotation.y = side * 0.12;
            animal.add(earGroup);
          });

          // Eyes with expressiveness
          [-1, 1].forEach((side) => {
            const eye = createEye(0.7, false, { irisColor: 0x4a3020 });
            eye.position.set(side * 0.2, 1.18, 0.34);
            animal.add(eye);
          });

          // Curved tusks
          [-1, 1].forEach((side) => {
            const tusk = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.032, 0.2, 10, 14),
              getMaterial(0xfffff0)
            );
            tusk.rotation.z = side * 0.28;
            tusk.rotation.x = -0.25;
            tusk.position.set(side * 0.18, 0.88, 0.4);
            animal.add(tusk);
          });

          // Thick legs with toenails
          const legPositions = [
            { x: -0.32, z: 0.2 },
            { x: 0.32, z: 0.2 },
            { x: -0.28, z: -0.22 },
            { x: 0.28, z: -0.22 },
          ];

          legPositions.forEach((pos) => {
            const leg = new THREE.Mesh(
              new THREE.CylinderGeometry(0.14, 0.16, 0.46, 18),
              primaryMat
            );
            leg.position.set(pos.x, 0.23, pos.z);
            animal.add(leg);

            const foot = new THREE.Mesh(
              new THREE.SphereGeometry(0.13, 14, 14),
              secondaryMat
            );
            foot.scale.set(1.22, 0.42, 1.25);
            foot.position.set(pos.x, 0.045, pos.z);
            animal.add(foot);

            // Toenails
            for (let t = 0; t < 3; t++) {
              const nail = new THREE.Mesh(
                new THREE.SphereGeometry(0.022, 8, 8),
                getMaterial(0xe8e8d8)
              );
              nail.scale.set(0.85, 0.6, 1.1);
              nail.position.set(pos.x + (t - 1) * 0.038, 0.04, pos.z + 0.1);
              animal.add(nail);
            }
          });

          // Tail with tuft
          const tailGroup = new THREE.Group();
          const tailBody = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.025, 0.22, 10, 12),
            primaryMat
          );
          tailGroup.add(tailBody);

          const tailTuft = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 10, 10),
            new THREE.MeshPhysicalMaterial({ color: 0x3a3a3a, roughness: 0.8 })
          );
          tailTuft.scale.set(1.0, 1.5, 1.0);
          tailTuft.position.y = -0.14;
          tailGroup.add(tailTuft);

          tailGroup.rotation.x = 0.75;
          tailGroup.position.set(0, 0.52, -0.56);
          animal.add(tailGroup);

          return animal;
        }

        // Register vinyl builders
        const VINYL_BUILDERS = {
          bunny: createBunnyVinyl,
          bear: createBearVinyl,
          penguin: createPenguinVinyl,
          fox: createFoxVinyl,
          cat: createCatVinyl,
          owl: createOwlVinyl,
          panda: createPandaVinyl,
          duck: createDuckVinyl,
          frog: createFrogVinyl,
          elephant: createElephantVinyl,
        };

        // Register the vinyl style
        MODEL_STYLE_BUILDERS.vinyl = VINYL_BUILDERS;
        console.log(
          "[Registration] Vinyl builders registered:",
          Object.keys(VINYL_BUILDERS).join(", ")
        );

        // ==========================================
        // CEL-SHADED/COMIC STYLE BUILDERS (Phase 3)
        // ==========================================

        // Comic style constants
        const COMIC_SEGMENTS = 8; // Angular, low-poly look
        const OUTLINE_SCALE = 1.06; // Outline thickness

        // Helper: Create comic mesh with outline (respects art style)
        function createComicMesh(geometry, baseColor) {
          const group = new THREE.Group();

          // Apply art style saturation adjustment to color
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);
          const hsl = {};
          color.getHSL(hsl);
          color.setHSL(hsl.h, hsl.s * (style ? style.saturation : 1.0), hsl.l);

          // Use art-style-aware material for the comic mesh
          // For cel-shaded look, we use MeshPhysicalMaterial with art style properties
          // The angular geometry gives it the comic feel
          let material;
          if (currentArtStyle === "vinyl") {
            // Default: use toon material for classic cel-shaded look
            material = createToonMaterial(color);
          } else {
            // Apply art style material properties with the comic colors
            material = new THREE.MeshPhysicalMaterial({
              color: color,
              roughness: style.roughness,
              metalness: style.metalness,
              clearcoat: style.clearcoat,
              clearcoatRoughness: style.clearcoatRoughness,
              sheen: style.sheen,
              sheenRoughness: style.sheenRoughness,
              sheenColor: color.clone().offsetHSL(0, -0.1, 0.2),
              envMapIntensity: style.envMapIntensity,
              side: THREE.DoubleSide,
            });
          }

          // Main mesh
          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          group.add(mesh);

          // Black outline (always present for comic look)
          const outline = new THREE.Mesh(geometry.clone(), outlineMaterial);
          outline.scale.multiplyScalar(OUTLINE_SCALE);
          group.add(outline);

          return group;
        }

        // Helper: Comic sphere (angular)
        function comicSphere(radius) {
          return new THREE.SphereGeometry(
            radius,
            COMIC_SEGMENTS,
            COMIC_SEGMENTS
          );
        }

        // Helper: Comic cylinder
        function comicCylinder(rTop, rBot, height) {
          return new THREE.CylinderGeometry(rTop, rBot, height, COMIC_SEGMENTS);
        }

        // ===== CEL-SHADED BUNNY =====
        function createBunnyCelShaded(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Angular body
          const body = createComicMesh(comicSphere(0.45), primaryColor);
          body.scale.set(0.9, 1.15, 1.0);
          body.position.y = 0.5;
          animal.add(body);

          // Hindquarters (angular)
          const hind = createComicMesh(comicSphere(0.38), primaryColor);
          hind.position.set(0, 0.3, -0.15);
          animal.add(hind);

          // Angular head (bigger for comic style)
          const head = createComicMesh(comicSphere(0.45), primaryColor);
          head.scale.set(1.15, 1.0, 1.0);
          head.position.y = 1.1;
          animal.add(head);

          // BIG expressive eyes (comic style)
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.12), 0xffffff);
            eyeWhite.scale.set(1, 1.2, 0.8);
            eyeWhite.position.set(side * 0.2, 1.15, 0.38);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 1.15, 0.48);
            animal.add(pupil);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.18, 1.18, 0.5);
            animal.add(highlight);
          });

          // Angular ears (tall, pointed)
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const ear = createComicMesh(
              new THREE.ConeGeometry(0.12, 0.8, 6),
              primaryColor
            );
            ear.position.set(side * 0.2, 1.65, -0.05);
            ear.rotation.z = side * -0.15;
            earGroup.add(ear);

            // Inner ear
            const inner = new THREE.Mesh(
              new THREE.ConeGeometry(0.06, 0.5, 6),
              createToonMaterial(secondaryColor)
            );
            inner.position.set(side * 0.2, 1.6, 0);
            inner.rotation.z = side * -0.15;
            earGroup.add(inner);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Bold nose
          const nose = createComicMesh(comicSphere(0.06), 0xffb6c1);
          nose.scale.set(1.3, 0.8, 1);
          nose.position.set(0, 1.02, 0.48);
          animal.add(nose);

          // Fluffy angular tail
          const tail = createComicMesh(comicSphere(0.15), primaryColor);
          tail.position.set(0, 0.5, -0.4);
          animal.add(tail);

          // Angular legs
          [-1, 1].forEach((side) => {
            const frontLeg = createComicMesh(
              comicCylinder(0.08, 0.06, 0.25),
              primaryColor
            );
            frontLeg.position.set(side * 0.22, 0.12, 0.2);
            animal.add(frontLeg);

            const backLeg = createComicMesh(comicSphere(0.14), primaryColor);
            backLeg.position.set(side * 0.25, 0.2, -0.12);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== CEL-SHADED BEAR =====
        function createBearCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Massive angular body
          const body = createComicMesh(comicSphere(0.6), primaryColor);
          body.scale.set(1.3, 1.0, 1.1);
          body.position.y = 0.6;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Shoulder hump
          const hump = createComicMesh(comicSphere(0.35), primaryColor);
          hump.position.set(0, 0.95, -0.1);
          animal.add(hump);

          // Angular belly patch
          const belly = createComicMesh(comicSphere(0.42), secondaryColor);
          belly.scale.set(1, 1.1, 0.5);
          belly.position.set(0, 0.5, 0.3);
          animal.add(belly);

          // Blocky head
          const head = createComicMesh(comicSphere(0.5), primaryColor);
          head.scale.set(1.1, 1.0, 1.0);
          head.position.y = 1.25;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Muzzle
          const muzzle = createComicMesh(comicSphere(0.2), secondaryColor);
          muzzle.scale.set(1.1, 0.8, 0.9);
          muzzle.position.set(0, 1.12, 0.45);
          animal.add(muzzle);

          // Big nose
          const nose = createComicMesh(comicSphere(0.1), accentColor);
          nose.scale.set(1.3, 0.9, 1);
          nose.position.set(0, 1.18, 0.62);
          animal.add(nose);

          // Small round ears
          [-1, 1].forEach((side) => {
            const ear = createComicMesh(comicSphere(0.15), primaryColor);
            ear.position.set(side * 0.35, 1.55, 0);
            animal.add(ear);
          });

          // Comic eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.1), 0xffffff);
            eyeWhite.position.set(side * 0.22, 1.3, 0.4);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.22, 1.3, 0.48);
            animal.add(pupil);
          });

          // Chunky legs
          const legPositions = [
            { x: -0.4, z: 0.2 },
            { x: 0.4, z: 0.2 },
            { x: -0.35, z: -0.25 },
            { x: 0.35, z: -0.25 },
          ];
          legPositions.forEach((pos) => {
            const leg = createComicMesh(
              comicCylinder(0.16, 0.18, 0.4),
              primaryColor
            );
            leg.position.set(pos.x, 0.2, pos.z);
            animal.add(leg);
          });

          return animal;
        }

        // ===== CEL-SHADED PENGUIN =====
        function createPenguinCelShaded(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Egg body
          const body = createComicMesh(comicSphere(0.55), primaryColor);
          body.scale.set(1, 1.15, 0.95);
          body.position.y = 0.6;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Bold white belly
          const belly = createComicMesh(comicSphere(0.45), secondaryColor);
          belly.scale.set(0.95, 1.0, 0.5);
          belly.position.set(0, 0.6, 0.25);
          animal.add(belly);

          // Round head
          const head = createComicMesh(comicSphere(0.4), primaryColor);
          head.position.y = 1.15;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face patch
          const face = createComicMesh(comicSphere(0.28), secondaryColor);
          face.scale.set(1, 1, 0.4);
          face.position.set(0, 1.12, 0.3);
          animal.add(face);

          // Big comic eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.11), 0xffffff);
            eyeWhite.scale.set(1, 1.2, 0.7);
            eyeWhite.position.set(side * 0.14, 1.15, 0.35);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.14, 1.15, 0.42);
            animal.add(pupil);
          });

          // Angular beak
          const beak = createComicMesh(
            new THREE.ConeGeometry(0.1, 0.2, 6),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.3;
          beak.position.set(0, 1.02, 0.45);
          animal.add(beak);

          // Flippers
          [-1, 1].forEach((side) => {
            const flipper = createComicMesh(
              new THREE.ConeGeometry(0.1, 0.4, 6),
              primaryColor
            );
            flipper.rotation.z = side * 0.5 + Math.PI;
            flipper.position.set(side * 0.5, 0.55, 0);
            animal.add(flipper);
          });

          // Feet
          [-1, 1].forEach((side) => {
            const foot = createComicMesh(comicSphere(0.12), accentColor);
            foot.scale.set(1.2, 0.4, 1.5);
            foot.position.set(side * 0.18, 0.04, 0.1);
            animal.add(foot);
          });

          return animal;
        }

        // ===== CEL-SHADED FOX =====
        function createFoxCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek angular body
          const body = createComicMesh(comicSphere(0.42), primaryColor);
          body.scale.set(1, 0.88, 1.32);
          body.position.y = 0.46;
          animal.add(body);

          // White chest bib
          const chest = createComicMesh(comicSphere(0.3), secondaryColor);
          chest.scale.set(0.82, 1.05, 0.58);
          chest.position.set(0, 0.52, 0.24);
          animal.add(chest);

          // Pointed angular head
          const head = createComicMesh(comicSphere(0.34), primaryColor);
          head.scale.set(1.12, 0.98, 1.02);
          head.position.y = 0.98;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Sharp snout (more angular)
          const snout = createComicMesh(
            new THREE.ConeGeometry(0.12, 0.35, 4),
            secondaryColor
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.9, 0.4);
          animal.add(snout);

          // Black nose
          const nose = createComicMesh(comicSphere(0.055), accentColor);
          nose.position.set(0, 0.9, 0.56);
          animal.add(nose);

          // Big triangular ears with BLACK TIPS
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createComicMesh(
              new THREE.ConeGeometry(0.14, 0.32, 4),
              primaryColor
            );
            earGroup.add(ear);

            // Black ear tip
            const tip = createComicMesh(
              new THREE.ConeGeometry(0.07, 0.12, 4),
              0x1a1a1a
            );
            tip.position.y = 0.12;
            earGroup.add(tip);

            // Inner ear
            const inner = new THREE.Mesh(
              new THREE.ConeGeometry(0.07, 0.2, 4),
              createToonMaterial(secondaryColor)
            );
            inner.position.set(0, -0.04, 0.02);
            earGroup.add(inner);

            earGroup.position.set(side * 0.24, 1.32, -0.04);
            earGroup.rotation.z = side * -0.22;
            animal.add(earGroup);
          });

          // Sharp sly eyes with highlight
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.1), 0xffffff);
            eyeWhite.scale.set(1.25, 0.82, 0.72);
            eyeWhite.position.set(side * 0.17, 1.0, 0.3);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.045),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.17, 1.0, 0.36);
            animal.add(pupil);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.018),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.155, 1.03, 0.37);
            animal.add(highlight);
          });

          // SEGMENTED dramatic fluffy tail (more angular)
          const tailGroup = new THREE.Group();
          for (let s = 0; s < 4; s++) {
            const segSize = 0.14 - s * 0.02;
            const tailSeg = createComicMesh(
              new THREE.ConeGeometry(segSize, 0.18, 4),
              primaryColor
            );
            tailSeg.position.y = s * 0.14;
            tailSeg.rotation.x = Math.PI;
            tailGroup.add(tailSeg);
          }

          // White tail tip
          const tailTip = createComicMesh(comicSphere(0.13), secondaryColor);
          tailTip.position.y = 0.55;
          tailGroup.add(tailTip);

          tailGroup.rotation.x = 0.7;
          tailGroup.position.set(0, 0.42, -0.52);
          animal.add(tailGroup);

          // Slim angular legs
          [-1, 1].forEach((side) => {
            const frontLeg = createComicMesh(
              comicCylinder(0.065, 0.055, 0.24),
              primaryColor
            );
            frontLeg.position.set(side * 0.18, 0.12, 0.22);
            animal.add(frontLeg);

            const frontPaw = createComicMesh(comicSphere(0.055), accentColor);
            frontPaw.scale.set(0.9, 0.55, 1.1);
            frontPaw.position.set(side * 0.18, 0.04, 0.24);
            animal.add(frontPaw);

            const backLeg = createComicMesh(
              comicCylinder(0.072, 0.062, 0.26),
              primaryColor
            );
            backLeg.position.set(side * 0.18, 0.13, -0.2);
            animal.add(backLeg);

            const backPaw = createComicMesh(comicSphere(0.055), accentColor);
            backPaw.scale.set(0.85, 0.52, 1.05);
            backPaw.position.set(side * 0.18, 0.04, -0.18);
            animal.add(backPaw);
          });

          return animal;
        }

        // ===== CEL-SHADED CAT =====
        function createCatCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek body
          const body = createComicMesh(comicSphere(0.35), primaryColor);
          body.scale.set(0.9, 0.85, 1.2);
          body.position.y = 0.4;
          animal.add(body);

          // Angular head
          const head = createComicMesh(comicSphere(0.32), primaryColor);
          head.scale.set(1.1, 1, 0.95);
          head.position.y = 0.88;
          animal.add(head);

          // Muzzle
          const muzzle = createComicMesh(comicSphere(0.12), secondaryColor);
          muzzle.scale.set(1, 0.7, 0.8);
          muzzle.position.set(0, 0.8, 0.28);
          animal.add(muzzle);

          // Pink nose
          const nose = createComicMesh(comicSphere(0.04), 0xffb6c1);
          nose.position.set(0, 0.84, 0.35);
          animal.add(nose);

          // Sharp triangle ears
          [-1, 1].forEach((side) => {
            const ear = createComicMesh(
              new THREE.ConeGeometry(0.1, 0.22, 4),
              primaryColor
            );
            ear.position.set(side * 0.2, 1.15, -0.05);
            ear.rotation.z = side * -0.15;
            animal.add(ear);
          });

          // Almond eyes (cat-like)
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.09), 0xffffff);
            eyeWhite.scale.set(1.3, 0.85, 0.7);
            eyeWhite.position.set(side * 0.14, 0.9, 0.26);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.03),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.scale.set(0.8, 1.5, 0.8); // Vertical slit
            pupil.position.set(side * 0.14, 0.9, 0.32);
            animal.add(pupil);
          });

          // Curved tail
          const tail = createComicMesh(
            comicCylinder(0.05, 0.04, 0.5),
            primaryColor
          );
          tail.rotation.x = 1.2;
          tail.rotation.z = 0.3;
          tail.position.set(0, 0.42, -0.48);
          animal.add(tail);

          // Slim legs
          [-1, 1].forEach((side) => {
            const frontLeg = createComicMesh(
              comicCylinder(0.05, 0.04, 0.2),
              primaryColor
            );
            frontLeg.position.set(side * 0.15, 0.1, 0.15);
            animal.add(frontLeg);

            const backLeg = createComicMesh(
              comicCylinder(0.06, 0.05, 0.22),
              primaryColor
            );
            backLeg.position.set(side * 0.15, 0.11, -0.18);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== CEL-SHADED OWL =====
        function createOwlCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round angular body
          const body = createComicMesh(comicSphere(0.44), primaryColor);
          body.scale.set(1.02, 1.12, 0.92);
          body.position.y = 0.5;
          animal.add(body);

          // Layered chest feathers
          const chest = createComicMesh(comicSphere(0.34), secondaryColor);
          chest.scale.set(0.92, 1.05, 0.52);
          chest.position.set(0, 0.44, 0.24);
          animal.add(chest);

          // Feather rows
          for (let r = 0; r < 3; r++) {
            const row = createComicMesh(
              comicSphere(0.2 - r * 0.04),
              r % 2 === 0 ? secondaryColor : primaryColor
            );
            row.scale.set(1.1, 0.32, 0.38);
            row.position.set(0, 0.3 + r * 0.1, 0.24);
            animal.add(row);
          }

          // Big round head
          const head = createComicMesh(comicSphere(0.42), primaryColor);
          head.position.y = 1.02;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Enhanced facial disc
          const disc = createComicMesh(comicSphere(0.34), secondaryColor);
          disc.scale.set(1.02, 1.0, 0.42);
          disc.position.set(0, 1.0, 0.26);
          animal.add(disc);

          // HUGE owl eyes with BOLDER double rings
          [-1, 1].forEach((side) => {
            // Outer bold ring
            const outerRing = createComicMesh(
              new THREE.TorusGeometry(0.15, 0.035, 6, 14),
              primaryColor
            );
            outerRing.position.set(side * 0.16, 1.02, 0.34);
            animal.add(outerRing);

            // Inner ring
            const innerRing = createComicMesh(
              new THREE.TorusGeometry(0.11, 0.025, 6, 12),
              secondaryColor
            );
            innerRing.position.set(side * 0.16, 1.02, 0.38);
            animal.add(innerRing);

            // Bigger eye white
            const eyeWhite = createComicMesh(comicSphere(0.12), 0xffffff);
            eyeWhite.position.set(side * 0.16, 1.02, 0.4);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.16, 1.02, 0.48);
            animal.add(pupil);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.022),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.14, 1.05, 0.49);
            animal.add(highlight);
          });

          // Sharp angular beak
          const beak = createComicMesh(
            new THREE.ConeGeometry(0.065, 0.14, 4),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.45;
          beak.position.set(0, 0.9, 0.42);
          animal.add(beak);

          // Enhanced multi-feather ear tufts
          [-1, 1].forEach((side) => {
            const tuftGroup = new THREE.Group();
            for (let i = 0; i < 3; i++) {
              const tuft = createComicMesh(
                new THREE.ConeGeometry(0.055 - i * 0.012, 0.16 - i * 0.02, 4),
                primaryColor
              );
              tuft.position.set((i - 1) * side * 0.02, i * 0.025, 0);
              tuftGroup.add(tuft);
            }
            tuftGroup.position.set(side * 0.3, 1.35, -0.04);
            tuftGroup.rotation.z = side * -0.28;
            animal.add(tuftGroup);
          });

          // Layered angular wings
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wingBase = createComicMesh(comicSphere(0.24), primaryColor);
            wingBase.scale.set(0.42, 1.08, 0.88);
            wingGroup.add(wingBase);

            // Feather tips
            for (let f = 0; f < 4; f++) {
              const feather = createComicMesh(
                new THREE.ConeGeometry(0.04, 0.12, 4),
                primaryColor
              );
              feather.position.set(0, -0.16 - f * 0.065, 0.02);
              feather.rotation.x = 0.45;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.42, 0.5, -0.04);
            animal.add(wingGroup);
          });

          // Detailed talons with claws
          [-1, 1].forEach((side) => {
            const footBase = createComicMesh(comicSphere(0.075), accentColor);
            footBase.scale.set(1.22, 0.55, 1.45);
            footBase.position.set(side * 0.12, 0.045, 0.06);
            animal.add(footBase);

            // Claws
            for (let c = 0; c < 3; c++) {
              const claw = createComicMesh(
                new THREE.ConeGeometry(0.018, 0.055, 4),
                0x2a2a2a
              );
              claw.rotation.x = Math.PI / 2;
              claw.position.set(side * 0.12 + (c - 1) * 0.028, 0.02, 0.12);
              animal.add(claw);
            }
          });

          return animal;
        }

        // ===== CEL-SHADED PANDA =====
        function createPandaCelShaded(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Angular round body (white)
          const body = createComicMesh(comicSphere(0.54), primaryColor);
          body.scale.set(1.05, 1.0, 0.98);
          body.position.y = 0.58;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly highlight
          const belly = createComicMesh(comicSphere(0.4), primaryColor);
          belly.scale.set(0.9, 1.0, 0.52);
          belly.position.set(0, 0.55, 0.26);
          animal.add(belly);

          // Head (white, angular)
          const head = createComicMesh(comicSphere(0.46), primaryColor);
          head.scale.set(1.06, 1.0, 1.0);
          head.position.y = 1.2;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheek puffs
          [-1, 1].forEach((side) => {
            const cheek = createComicMesh(comicSphere(0.14), primaryColor);
            cheek.position.set(side * 0.34, 1.1, 0.22);
            animal.add(cheek);
          });

          // Angular tear-drop eye patches (black)
          [-1, 1].forEach((side) => {
            const patchGroup = new THREE.Group();

            const patch = createComicMesh(comicSphere(0.18), secondaryColor);
            patch.scale.set(1.3, 1.4, 0.52);
            patchGroup.add(patch);

            // Tear-drop extension
            const tearDrop = createComicMesh(comicSphere(0.1), secondaryColor);
            tearDrop.scale.set(1.0, 1.3, 0.48);
            tearDrop.position.set(side * 0.04, -0.12, 0.02);
            patchGroup.add(tearDrop);

            patchGroup.position.set(side * 0.2, 1.22, 0.32);
            patchGroup.rotation.z = side * -0.15;
            animal.add(patchGroup);

            // Eye white
            const eyeWhite = createComicMesh(comicSphere(0.085), 0xffffff);
            eyeWhite.position.set(side * 0.2, 1.22, 0.42);
            animal.add(eyeWhite);

            // Pupil
            const pupil = new THREE.Mesh(
              comicSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 1.22, 0.48);
            animal.add(pupil);

            // Double highlights
            const highlight1 = new THREE.Mesh(
              comicSphere(0.02),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight1.position.set(side * 0.185, 1.24, 0.5);
            animal.add(highlight1);

            const highlight2 = new THREE.Mesh(
              comicSphere(0.012),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight2.position.set(side * 0.215, 1.2, 0.5);
            animal.add(highlight2);
          });

          // Angular black ears with inner detail
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const ear = createComicMesh(comicSphere(0.16), secondaryColor);
            ear.position.set(side * 0.36, 1.52, 0.02);
            earGroup.add(ear);

            const innerEar = createComicMesh(comicSphere(0.08), 0x333333);
            innerEar.position.set(side * 0.38, 1.52, 0.08);
            earGroup.add(innerEar);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Muzzle
          const muzzle = createComicMesh(comicSphere(0.15), primaryColor);
          muzzle.scale.set(1.1, 0.8, 0.85);
          muzzle.position.set(0, 1.07, 0.4);
          animal.add(muzzle);

          // Black angular nose
          const nose = createComicMesh(comicSphere(0.07), secondaryColor);
          nose.scale.set(1.3, 0.9, 1.0);
          nose.position.set(0, 1.1, 0.52);
          animal.add(nose);

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.05, 8),
              createToonMaterial(0xffb6c1)
            );
            blush.position.set(side * 0.36, 1.04, 0.34);
            blush.rotation.y = side * 0.25;
            animal.add(blush);
          });

          // Bold black arms with angular paws
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = createComicMesh(
              comicCylinder(0.14, 0.13, 0.32),
              secondaryColor
            );
            armGroup.add(arm);

            const paw = createComicMesh(comicSphere(0.09), secondaryColor);
            paw.scale.set(1.2, 0.7, 1.0);
            paw.position.y = -0.2;
            armGroup.add(paw);

            armGroup.rotation.z = side * 0.5;
            armGroup.position.set(side * 0.5, 0.6, 0.12);
            animal.add(armGroup);
          });

          // Black legs with feet
          [-1, 1].forEach((side) => {
            const leg = createComicMesh(
              comicCylinder(0.15, 0.16, 0.28),
              secondaryColor
            );
            leg.position.set(side * 0.26, 0.12, 0);
            animal.add(leg);

            const foot = createComicMesh(comicSphere(0.11), secondaryColor);
            foot.scale.set(1.15, 0.45, 1.2);
            foot.position.set(side * 0.26, 0.04, 0.02);
            animal.add(foot);
          });

          // Tiny tail
          const tail = createComicMesh(comicSphere(0.06), primaryColor);
          tail.position.set(0, 0.38, -0.5);
          animal.add(tail);

          return animal;
        }

        // ===== CEL-SHADED DUCK =====
        function createDuckCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Angular plump body
          const body = createComicMesh(comicSphere(0.44), primaryColor);
          body.scale.set(1.02, 0.88, 1.25);
          body.position.y = 0.44;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Chest/breast
          const chest = createComicMesh(comicSphere(0.34), secondaryColor);
          chest.scale.set(0.9, 0.85, 0.55);
          chest.position.set(0, 0.4, 0.24);
          animal.add(chest);

          // Neck
          const neck = createComicMesh(
            comicCylinder(0.14, 0.12, 0.16),
            primaryColor
          );
          neck.position.set(0, 0.7, 0.1);
          animal.add(neck);

          // Angular head
          const head = createComicMesh(comicSphere(0.32), primaryColor);
          head.position.y = 0.92;
          animal.add(head);
          animal.userData.animationData.head = head;

          // White neck ring
          const collar = new THREE.Mesh(
            new THREE.TorusGeometry(0.15, 0.035, 8, 16),
            createToonMaterial(secondaryColor)
          );
          collar.position.set(0, 0.74, 0.1);
          collar.rotation.x = Math.PI / 2;
          animal.add(collar);

          // Wide angular bill - two parts
          const billTop = createComicMesh(comicSphere(0.15), accentColor);
          billTop.scale.set(1.15, 0.42, 1.55);
          billTop.position.set(0, 0.88, 0.38);
          animal.add(billTop);

          const billBottom = createComicMesh(comicSphere(0.13), accentColor);
          billBottom.scale.set(1.0, 0.32, 1.45);
          billBottom.position.set(0, 0.84, 0.36);
          animal.add(billBottom);

          // Nostrils
          [-1, 1].forEach((side) => {
            const nostril = new THREE.Mesh(
              comicSphere(0.015),
              new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            nostril.position.set(side * 0.05, 0.9, 0.44);
            animal.add(nostril);
          });

          // Bold angular eyes with highlights
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.1), 0xffffff);
            eyeWhite.position.set(side * 0.15, 0.94, 0.24);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              comicSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            iris.position.set(side * 0.15, 0.94, 0.3);
            animal.add(iris);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.018),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.14, 0.96, 0.32);
            animal.add(highlight);
          });

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.04, 8),
              createToonMaterial(0xffcccc)
            );
            blush.position.set(side * 0.23, 0.88, 0.2);
            blush.rotation.y = side * 0.3;
            animal.add(blush);
          });

          // Angular wings with feather tips
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wing = createComicMesh(comicSphere(0.22), primaryColor);
            wing.scale.set(0.44, 0.88, 1.08);
            wingGroup.add(wing);

            // Feather tips
            for (let f = 0; f < 3; f++) {
              const feather = createComicMesh(
                comicCylinder(0.025, 0.02, 0.1),
                primaryColor
              );
              feather.position.set(0, -0.14 - f * 0.07, -0.04 + f * 0.02);
              feather.rotation.x = 0.35;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.4, 0.44, -0.04);
            wingGroup.rotation.z = side * 0.15;
            animal.add(wingGroup);
          });

          // Angular tail feathers
          const tailGroup = new THREE.Group();
          for (let t = 0; t < 4; t++) {
            const tailFeather = createComicMesh(
              new THREE.ConeGeometry(0.045 - t * 0.006, 0.14 + t * 0.02, 5),
              primaryColor
            );
            tailFeather.position.set((t - 1.5) * 0.028, 0, t * 0.015);
            tailFeather.rotation.x = Math.PI / 2 + 0.38;
            tailGroup.add(tailFeather);
          }
          tailGroup.position.set(0, 0.5, -0.5);
          animal.add(tailGroup);

          // Webbed feet with toes
          [-1, 1].forEach((side) => {
            const footGroup = new THREE.Group();

            const foot = createComicMesh(comicSphere(0.1), accentColor);
            foot.scale.set(1.28, 0.34, 1.65);
            footGroup.add(foot);

            // Three toes
            for (let toe = 0; toe < 3; toe++) {
              const toeMesh = createComicMesh(comicSphere(0.032), accentColor);
              toeMesh.scale.set(0.9, 0.4, 1.9);
              toeMesh.position.set((toe - 1) * 0.045, 0, 0.1);
              footGroup.add(toeMesh);
            }

            footGroup.position.set(side * 0.16, 0.04, 0.08);
            animal.add(footGroup);
          });

          return animal;
        }

        // ===== CEL-SHADED FROG =====
        function createFrogCelShaded(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Angular squat body
          const body = createComicMesh(comicSphere(0.44), primaryColor);
          body.scale.set(1.25, 0.72, 1.05);
          body.position.y = 0.32;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly with detail
          const belly = createComicMesh(comicSphere(0.36), secondaryColor);
          belly.scale.set(1.05, 0.62, 0.58);
          belly.position.set(0, 0.28, 0.22);
          animal.add(belly);

          // Wide angular head
          const head = createComicMesh(comicSphere(0.34), primaryColor);
          head.scale.set(1.42, 0.82, 1.02);
          head.position.set(0, 0.48, 0.16);
          animal.add(head);
          animal.userData.animationData.head = head;

          // HUGE bulging eyes with highlights
          [-1, 1].forEach((side) => {
            const eyeBulge = createComicMesh(comicSphere(0.15), primaryColor);
            eyeBulge.position.set(side * 0.24, 0.68, 0.18);
            animal.add(eyeBulge);

            const eyeWhite = createComicMesh(comicSphere(0.12), 0xffffff);
            eyeWhite.position.set(side * 0.24, 0.7, 0.26);
            animal.add(eyeWhite);

            // Golden iris
            const iris = new THREE.Mesh(
              comicSphere(0.07),
              new THREE.MeshBasicMaterial({ color: 0xffd700 })
            );
            iris.position.set(side * 0.24, 0.7, 0.32);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              comicSphere(0.04),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.24, 0.7, 0.36);
            animal.add(pupil);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.02),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.22, 0.72, 0.38);
            animal.add(highlight);
          });

          // Nostril dots
          [-1, 1].forEach((side) => {
            const nostril = new THREE.Mesh(
              comicSphere(0.02),
              new THREE.MeshBasicMaterial({ color: 0x2a3a2a })
            );
            nostril.position.set(side * 0.09, 0.52, 0.4);
            animal.add(nostril);
          });

          // Wide happy mouth
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.025, 6, 14, Math.PI),
            createToonMaterial(accentColor)
          );
          mouth.rotation.x = -Math.PI / 2;
          mouth.position.set(0, 0.38, 0.34);
          animal.add(mouth);

          // Front legs with 4 fingers
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = createComicMesh(
              comicCylinder(0.065, 0.055, 0.2),
              primaryColor
            );
            armGroup.add(arm);

            // 4 fingers
            for (let f = 0; f < 4; f++) {
              const finger = createComicMesh(
                comicCylinder(0.018, 0.012, 0.06),
                primaryColor
              );
              finger.position.set((f - 1.5) * 0.024, -0.12, 0.02);
              finger.rotation.x = 0.3;
              armGroup.add(finger);
            }

            armGroup.rotation.z = side * 0.8;
            armGroup.position.set(side * 0.4, 0.16, 0.16);
            animal.add(armGroup);
          });

          // Powerful back legs with webbed feet
          [-1, 1].forEach((side) => {
            const thigh = createComicMesh(comicSphere(0.15), primaryColor);
            thigh.scale.set(0.82, 1.25, 1.02);
            thigh.position.set(side * 0.4, 0.24, -0.16);
            animal.add(thigh);

            const calf = createComicMesh(
              comicCylinder(0.075, 0.065, 0.25),
              primaryColor
            );
            calf.rotation.x = 0.85;
            calf.position.set(side * 0.44, 0.08, -0.3);
            animal.add(calf);

            // Webbed foot
            const footGroup = new THREE.Group();
            const foot = createComicMesh(comicSphere(0.08), primaryColor);
            foot.scale.set(1.3, 0.4, 1.8);
            footGroup.add(foot);

            // 3 webbed toes
            for (let t = 0; t < 3; t++) {
              const toe = createComicMesh(comicSphere(0.025), primaryColor);
              toe.scale.set(0.85, 0.45, 2.0);
              toe.position.set((t - 1) * 0.04, 0, 0.08);
              footGroup.add(toe);
            }

            footGroup.position.set(side * 0.44, 0.04, -0.15);
            animal.add(footGroup);
          });

          return animal;
        }

        // ===== CEL-SHADED ELEPHANT =====
        function createElephantCelShaded(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "celshaded";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Massive angular body
          const body = createComicMesh(comicSphere(0.6), primaryColor);
          body.scale.set(1.22, 0.92, 1.02);
          body.position.y = 0.64;
          animal.add(body);

          // Head
          const head = createComicMesh(comicSphere(0.44), primaryColor);
          head.scale.set(1.02, 1.0, 0.98);
          head.position.y = 1.15;
          animal.add(head);
          animal.userData.animationData.head = head;

          // SEGMENTED angular trunk
          const trunkGroup = new THREE.Group();
          for (let s = 0; s < 5; s++) {
            const seg = createComicMesh(
              comicCylinder(0.1 - s * 0.012, 0.09 - s * 0.012, 0.1),
              primaryColor
            );
            seg.position.y = -s * 0.09;
            trunkGroup.add(seg);
          }
          const trunkTip = createComicMesh(comicSphere(0.05), secondaryColor);
          trunkTip.position.set(0, -0.48, 0.04);
          trunkGroup.add(trunkTip);

          trunkGroup.rotation.x = 0.4;
          trunkGroup.position.set(0, 0.98, 0.48);
          animal.add(trunkGroup);
          animal.userData.animationData.trunk = trunkGroup;

          // HUGE angular flapping ears
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createComicMesh(comicSphere(0.42), primaryColor);
            ear.scale.set(0.16, 1.08, 0.88);
            earGroup.add(ear);

            const innerEar = createComicMesh(comicSphere(0.32), secondaryColor);
            innerEar.scale.set(0.14, 0.85, 0.68);
            innerEar.position.z = 0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.45, 1.05, -0.04);
            earGroup.rotation.y = side * 0.12;
            animal.add(earGroup);
          });

          // Bigger expressive eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createComicMesh(comicSphere(0.095), 0xffffff);
            eyeWhite.position.set(side * 0.2, 1.2, 0.38);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              comicSphere(0.048),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 1.2, 0.44);
            animal.add(pupil);

            // Highlight
            const highlight = new THREE.Mesh(
              comicSphere(0.018),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.18, 1.23, 0.45);
            animal.add(highlight);
          });

          // Curved tusks
          [-1, 1].forEach((side) => {
            const tusk = createComicMesh(
              comicCylinder(0.045, 0.025, 0.3),
              0xfffff0
            );
            tusk.rotation.z = side * 0.28;
            tusk.rotation.x = -0.28;
            tusk.position.set(side * 0.22, 0.92, 0.44);
            animal.add(tusk);
          });

          // Chunky legs with toenails
          const legPositions = [
            { x: -0.36, z: 0.2 },
            { x: 0.36, z: 0.2 },
            { x: -0.32, z: -0.22 },
            { x: 0.32, z: -0.22 },
          ];
          legPositions.forEach((pos) => {
            const leg = createComicMesh(
              comicCylinder(0.16, 0.18, 0.5),
              primaryColor
            );
            leg.position.set(pos.x, 0.26, pos.z);
            animal.add(leg);

            const foot = createComicMesh(comicSphere(0.14), secondaryColor);
            foot.scale.set(1.2, 0.42, 1.25);
            foot.position.set(pos.x, 0.048, pos.z);
            animal.add(foot);

            // Toenails
            for (let t = 0; t < 3; t++) {
              const nail = createComicMesh(comicSphere(0.025), 0xe8e8d8);
              nail.scale.set(0.85, 0.58, 1.1);
              nail.position.set(pos.x + (t - 1) * 0.042, 0.045, pos.z + 0.11);
              animal.add(nail);
            }
          });

          // Tail with tuft
          const tailGroup = new THREE.Group();
          const tailBody = createComicMesh(
            comicCylinder(0.035, 0.045, 0.34),
            primaryColor
          );
          tailGroup.add(tailBody);

          const tailTuft = createComicMesh(comicSphere(0.045), 0x3a3a3a);
          tailTuft.scale.set(1.0, 1.5, 1.0);
          tailTuft.position.y = -0.2;
          tailGroup.add(tailTuft);

          tailGroup.rotation.x = 0.75;
          tailGroup.position.set(0, 0.55, -0.6);
          animal.add(tailGroup);

          return animal;
        }

        // Register cel-shaded builders
        const CEL_SHADED_BUILDERS = {
          bunny: createBunnyCelShaded,
          bear: createBearCelShaded,
          penguin: createPenguinCelShaded,
          fox: createFoxCelShaded,
          cat: createCatCelShaded,
          owl: createOwlCelShaded,
          panda: createPandaCelShaded,
          duck: createDuckCelShaded,
          frog: createFrogCelShaded,
          elephant: createElephantCelShaded,
        };

        // Register the cel-shaded style
        MODEL_STYLE_BUILDERS.celshaded = CEL_SHADED_BUILDERS;
        console.log(
          "[Registration] Cel-shaded builders registered:",
          Object.keys(CEL_SHADED_BUILDERS).join(", ")
        );

        // ==========================================
        // LOW-POLY STYLE BUILDERS (Phase 4)
        // ==========================================

        const LOWPOLY_SEGMENTS = 5; // Very low for crystalline look

        // Helper: Create low-poly mesh with flat shading
        function createLowPolyMesh(geometry, baseColor) {
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);
          const hsl = {};
          color.getHSL(hsl);
          color.setHSL(hsl.h, hsl.s * (style ? style.saturation : 1.0), hsl.l);

          // Apply flat shading for crystalline look
          geometry.computeVertexNormals();

          const material = new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: Math.max(0.3, style.roughness),
            metalness: style.metalness,
            clearcoat: style.clearcoat * 0.5,
            clearcoatRoughness: style.clearcoatRoughness,
            flatShading: true, // Key for low-poly look
            side: THREE.DoubleSide,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          return mesh;
        }

        // Helper: Low-poly geometries
        function lowPolySphere(radius) {
          return new THREE.IcosahedronGeometry(radius, 1); // Icosahedron for geometric look
        }

        function lowPolyCylinder(rTop, rBot, height) {
          return new THREE.CylinderGeometry(
            rTop,
            rBot,
            height,
            LOWPOLY_SEGMENTS
          );
        }

        // ===== LOW-POLY BUNNY =====
        function createBunnyLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Geometric body
          const body = createLowPolyMesh(lowPolySphere(0.4), primaryColor);
          body.scale.set(0.9, 1.1, 1.0);
          body.position.y = 0.5;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Angular head
          const head = createLowPolyMesh(lowPolySphere(0.38), primaryColor);
          head.position.y = 1.05;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Triangular ears (pyramids)
          [-1, 1].forEach((side) => {
            const ear = createLowPolyMesh(
              new THREE.ConeGeometry(0.1, 0.6, 4),
              primaryColor
            );
            ear.position.set(side * 0.18, 1.55, -0.05);
            ear.rotation.z = side * -0.1;
            animal.add(ear);
          });

          // Faceted eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              lowPolySphere(0.08),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.15, 1.1, 0.32);
            animal.add(eye);
          });

          // Geometric nose
          const nose = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.05),
            0xffb6c1
          );
          nose.position.set(0, 1.0, 0.38);
          animal.add(nose);

          // Tail
          const tail = createLowPolyMesh(lowPolySphere(0.12), primaryColor);
          tail.position.set(0, 0.45, -0.35);
          animal.add(tail);

          // Angular legs
          [-1, 1].forEach((side) => {
            const leg = createLowPolyMesh(
              lowPolyCylinder(0.06, 0.05, 0.2),
              primaryColor
            );
            leg.position.set(side * 0.18, 0.1, 0.15);
            animal.add(leg);
          });

          return animal;
        }

        // ===== LOW-POLY BEAR =====
        function createBearLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Massive geometric body
          const body = createLowPolyMesh(lowPolySphere(0.55), primaryColor);
          body.scale.set(1.2, 1.0, 1.0);
          body.position.y = 0.6;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createLowPolyMesh(lowPolySphere(0.35), secondaryColor);
          belly.scale.set(0.9, 1.0, 0.5);
          belly.position.set(0, 0.5, 0.28);
          animal.add(belly);

          // Blocky head
          const head = createLowPolyMesh(lowPolySphere(0.42), primaryColor);
          head.position.y = 1.2;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Muzzle
          const muzzle = createLowPolyMesh(lowPolySphere(0.18), secondaryColor);
          muzzle.scale.set(1.0, 0.8, 0.8);
          muzzle.position.set(0, 1.1, 0.38);
          animal.add(muzzle);

          // Nose
          const nose = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.08),
            accentColor
          );
          nose.position.set(0, 1.15, 0.52);
          animal.add(nose);

          // Round ears
          [-1, 1].forEach((side) => {
            const ear = createLowPolyMesh(lowPolySphere(0.12), primaryColor);
            ear.position.set(side * 0.32, 1.5, 0);
            animal.add(ear);
          });

          // Eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              lowPolySphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.18, 1.25, 0.35);
            animal.add(eye);
          });

          // Chunky legs
          const legPositions = [
            { x: -0.35, z: 0.18 },
            { x: 0.35, z: 0.18 },
            { x: -0.3, z: -0.2 },
            { x: 0.3, z: -0.2 },
          ];
          legPositions.forEach((pos) => {
            const leg = createLowPolyMesh(
              lowPolyCylinder(0.14, 0.15, 0.35),
              primaryColor
            );
            leg.position.set(pos.x, 0.18, pos.z);
            animal.add(leg);
          });

          return animal;
        }

        // ===== LOW-POLY PENGUIN =====
        function createPenguinLowPoly(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Geometric body
          const body = createLowPolyMesh(lowPolySphere(0.48), primaryColor);
          body.scale.set(1.0, 1.15, 0.9);
          body.position.y = 0.55;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createLowPolyMesh(lowPolySphere(0.38), secondaryColor);
          belly.scale.set(0.9, 1.0, 0.5);
          belly.position.set(0, 0.55, 0.2);
          animal.add(belly);

          // Head
          const head = createLowPolyMesh(lowPolySphere(0.35), primaryColor);
          head.position.y = 1.08;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face
          const face = createLowPolyMesh(lowPolySphere(0.22), secondaryColor);
          face.scale.set(1, 1, 0.4);
          face.position.set(0, 1.05, 0.25);
          animal.add(face);

          // Eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              lowPolySphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.12, 1.1, 0.3);
            animal.add(eye);
          });

          // Beak
          const beak = createLowPolyMesh(
            new THREE.ConeGeometry(0.08, 0.15, 4),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.3;
          beak.position.set(0, 1.0, 0.38);
          animal.add(beak);

          // Flippers
          [-1, 1].forEach((side) => {
            const flipper = createLowPolyMesh(
              new THREE.ConeGeometry(0.08, 0.35, 4),
              primaryColor
            );
            flipper.rotation.z = side * 0.5 + Math.PI;
            flipper.position.set(side * 0.42, 0.55, 0);
            animal.add(flipper);
          });

          // Feet
          [-1, 1].forEach((side) => {
            const foot = createLowPolyMesh(lowPolySphere(0.08), accentColor);
            foot.scale.set(1.2, 0.4, 1.5);
            foot.position.set(side * 0.15, 0.04, 0.08);
            animal.add(foot);
          });

          return animal;
        }

        // ===== LOW-POLY FOX =====
        function createFoxLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek angular body (lower segments for more facets)
          const body = createLowPolyMesh(lowPolySphere(0.36), primaryColor);
          body.scale.set(1.02, 0.88, 1.32);
          body.position.y = 0.44;
          animal.add(body);

          // Chest (faceted)
          const chest = createLowPolyMesh(lowPolySphere(0.26), secondaryColor);
          chest.scale.set(0.82, 0.92, 0.52);
          chest.position.set(0, 0.48, 0.2);
          animal.add(chest);

          // Pointed angular head
          const head = createLowPolyMesh(lowPolySphere(0.3), primaryColor);
          head.scale.set(1.05, 0.95, 1.0);
          head.position.y = 0.92;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Sharp angular snout (tetrahedron-like)
          const snout = createLowPolyMesh(
            new THREE.ConeGeometry(0.11, 0.28, 4),
            secondaryColor
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.88, 0.35);
          animal.add(snout);

          // Faceted nose
          const nose = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.045),
            accentColor
          );
          nose.position.set(0, 0.88, 0.5);
          animal.add(nose);

          // Big triangular ears with BLACK TIPS
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createLowPolyMesh(
              new THREE.ConeGeometry(0.11, 0.28, 3),
              primaryColor
            );
            earGroup.add(ear);

            // Black ear tip
            const tip = createLowPolyMesh(
              new THREE.ConeGeometry(0.06, 0.1, 3),
              0x1a1a1a
            );
            tip.position.y = 0.1;
            earGroup.add(tip);

            earGroup.position.set(side * 0.22, 1.22, -0.04);
            earGroup.rotation.z = side * -0.2;
            animal.add(earGroup);
          });

          // Faceted gem-like eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              new THREE.OctahedronGeometry(0.045),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.15, 0.95, 0.26);
            animal.add(eye);
          });

          // Segmented fluffy tail
          const tailGroup = new THREE.Group();
          for (let s = 0; s < 3; s++) {
            const tailSeg = createLowPolyMesh(
              new THREE.ConeGeometry(0.11 - s * 0.025, 0.18, 4),
              primaryColor
            );
            tailSeg.position.y = s * 0.14;
            tailSeg.rotation.x = Math.PI;
            tailGroup.add(tailSeg);
          }
          const tailTip = createLowPolyMesh(lowPolySphere(0.1), secondaryColor);
          tailTip.position.y = 0.42;
          tailGroup.add(tailTip);

          tailGroup.rotation.x = 0.7;
          tailGroup.position.set(0, 0.4, -0.48);
          animal.add(tailGroup);

          // Angular legs with paws
          [-1, 1].forEach((side) => {
            const frontLeg = createLowPolyMesh(
              lowPolyCylinder(0.055, 0.045, 0.2),
              primaryColor
            );
            frontLeg.position.set(side * 0.16, 0.1, 0.18);
            animal.add(frontLeg);

            const frontPaw = createLowPolyMesh(
              new THREE.TetrahedronGeometry(0.04),
              accentColor
            );
            frontPaw.position.set(side * 0.16, 0.03, 0.2);
            animal.add(frontPaw);

            const backLeg = createLowPolyMesh(
              lowPolyCylinder(0.06, 0.05, 0.22),
              primaryColor
            );
            backLeg.position.set(side * 0.16, 0.11, -0.18);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== LOW-POLY CAT =====
        function createCatLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek body
          const body = createLowPolyMesh(lowPolySphere(0.32), primaryColor);
          body.scale.set(0.9, 0.85, 1.2);
          body.position.y = 0.38;
          animal.add(body);

          // Head
          const head = createLowPolyMesh(lowPolySphere(0.28), primaryColor);
          head.position.y = 0.82;
          animal.add(head);

          // Muzzle
          const muzzle = createLowPolyMesh(lowPolySphere(0.1), secondaryColor);
          muzzle.position.set(0, 0.76, 0.24);
          animal.add(muzzle);

          // Nose
          const nose = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.03),
            0xffb6c1
          );
          nose.position.set(0, 0.8, 0.3);
          animal.add(nose);

          // Triangle ears
          [-1, 1].forEach((side) => {
            const ear = createLowPolyMesh(
              new THREE.ConeGeometry(0.08, 0.18, 3),
              primaryColor
            );
            ear.position.set(side * 0.18, 1.08, -0.05);
            ear.rotation.z = side * -0.15;
            animal.add(ear);
          });

          // Cat eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              lowPolySphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x7cfc00 })
            );
            eye.position.set(side * 0.12, 0.85, 0.22);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              new THREE.BoxGeometry(0.01, 0.04, 0.01),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.12, 0.85, 0.26);
            animal.add(pupil);
          });

          // Tail
          const tail = createLowPolyMesh(
            lowPolyCylinder(0.04, 0.03, 0.4),
            primaryColor
          );
          tail.rotation.x = 1.0;
          tail.position.set(0, 0.4, -0.42);
          animal.add(tail);

          // Legs (front and back)
          [-1, 1].forEach((side) => {
            const frontLeg = createLowPolyMesh(
              lowPolyCylinder(0.04, 0.035, 0.16),
              primaryColor
            );
            frontLeg.position.set(side * 0.12, 0.08, 0.12);
            animal.add(frontLeg);

            const backLeg = createLowPolyMesh(
              lowPolyCylinder(0.045, 0.04, 0.18),
              primaryColor
            );
            backLeg.position.set(side * 0.11, 0.09, -0.14);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== LOW-POLY OWL =====
        function createOwlLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round faceted body
          const body = createLowPolyMesh(lowPolySphere(0.4), primaryColor);
          body.scale.set(1.02, 1.12, 0.92);
          body.position.y = 0.48;
          animal.add(body);

          // Layered chest (faceted feather rows)
          const chest = createLowPolyMesh(lowPolySphere(0.3), secondaryColor);
          chest.scale.set(0.82, 0.95, 0.52);
          chest.position.set(0, 0.42, 0.2);
          animal.add(chest);

          // Feather facet rows
          for (let r = 0; r < 2; r++) {
            const row = createLowPolyMesh(
              new THREE.OctahedronGeometry(0.12 - r * 0.03),
              r % 2 === 0 ? secondaryColor : primaryColor
            );
            row.scale.set(1.5, 0.5, 0.6);
            row.position.set(0, 0.28 + r * 0.12, 0.22);
            animal.add(row);
          }

          // Large faceted head
          const head = createLowPolyMesh(lowPolySphere(0.38), primaryColor);
          head.position.y = 0.98;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Facial disc
          const disc = createLowPolyMesh(lowPolySphere(0.28), secondaryColor);
          disc.scale.set(1.02, 1.0, 0.42);
          disc.position.set(0, 0.96, 0.22);
          animal.add(disc);

          // Big gem-like eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              new THREE.OctahedronGeometry(0.08),
              new THREE.MeshBasicMaterial({ color: 0xffa500 })
            );
            eye.position.set(side * 0.13, 0.98, 0.34);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              new THREE.TetrahedronGeometry(0.04),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.13, 0.98, 0.42);
            animal.add(pupil);
          });

          // Sharp angular beak
          const beak = createLowPolyMesh(
            new THREE.ConeGeometry(0.055, 0.12, 4),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.42;
          beak.position.set(0, 0.9, 0.36);
          animal.add(beak);

          // Multi-spike ear tufts
          [-1, 1].forEach((side) => {
            const tuftGroup = new THREE.Group();
            for (let i = 0; i < 2; i++) {
              const tuft = createLowPolyMesh(
                new THREE.ConeGeometry(0.05 - i * 0.012, 0.14 - i * 0.02, 3),
                primaryColor
              );
              tuft.position.set(i * side * 0.02, i * 0.02, 0);
              tuftGroup.add(tuft);
            }
            tuftGroup.position.set(side * 0.27, 1.28, -0.04);
            tuftGroup.rotation.z = side * -0.28;
            animal.add(tuftGroup);
          });

          // Faceted wings with feather tips
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wingBase = createLowPolyMesh(
              lowPolySphere(0.2),
              primaryColor
            );
            wingBase.scale.set(0.42, 1.0, 0.78);
            wingGroup.add(wingBase);

            // Feather tips (triangles)
            for (let f = 0; f < 3; f++) {
              const feather = createLowPolyMesh(
                new THREE.ConeGeometry(0.035, 0.1, 3),
                primaryColor
              );
              feather.position.set(0, -0.14 - f * 0.06, 0.02);
              feather.rotation.x = 0.4;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.38, 0.48, -0.04);
            animal.add(wingGroup);
          });

          // Faceted talons
          [-1, 1].forEach((side) => {
            const foot = createLowPolyMesh(
              new THREE.TetrahedronGeometry(0.055),
              accentColor
            );
            foot.scale.set(1.2, 0.55, 1.45);
            foot.position.set(side * 0.11, 0.045, 0.06);
            animal.add(foot);
          });

          return animal;
        }

        // ===== LOW-POLY PANDA =====
        function createPandaLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Faceted body (white)
          const body = createLowPolyMesh(lowPolySphere(0.5), primaryColor);
          body.scale.set(1.05, 1.0, 0.98);
          body.position.y = 0.56;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly highlight
          const belly = createLowPolyMesh(lowPolySphere(0.38), primaryColor);
          belly.scale.set(0.9, 1.0, 0.52);
          belly.position.set(0, 0.52, 0.24);
          animal.add(belly);

          // Faceted head (white)
          const head = createLowPolyMesh(lowPolySphere(0.42), primaryColor);
          head.scale.set(1.06, 1.0, 1.0);
          head.position.y = 1.15;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheek puffs
          [-1, 1].forEach((side) => {
            const cheek = createLowPolyMesh(lowPolySphere(0.12), primaryColor);
            cheek.position.set(side * 0.3, 1.05, 0.2);
            animal.add(cheek);
          });

          // Faceted tear-drop eye patches (black)
          [-1, 1].forEach((side) => {
            const patchGroup = new THREE.Group();

            const patch = createLowPolyMesh(
              lowPolySphere(0.16),
              secondaryColor
            );
            patch.scale.set(1.25, 1.35, 0.52);
            patchGroup.add(patch);

            // Tear-drop extension
            const tearDrop = createLowPolyMesh(
              lowPolySphere(0.09),
              secondaryColor
            );
            tearDrop.scale.set(1.0, 1.25, 0.48);
            tearDrop.position.set(side * 0.03, -0.1, 0.02);
            patchGroup.add(tearDrop);

            patchGroup.position.set(side * 0.18, 1.18, 0.3);
            patchGroup.rotation.z = side * -0.12;
            animal.add(patchGroup);

            // Gem-like eye
            const eye = new THREE.Mesh(
              new THREE.OctahedronGeometry(0.055),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            eye.position.set(side * 0.18, 1.18, 0.4);
            animal.add(eye);

            // Pupil gem
            const pupil = new THREE.Mesh(
              new THREE.TetrahedronGeometry(0.03),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.18, 1.18, 0.44);
            animal.add(pupil);
          });

          // Faceted black ears with inner detail
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const ear = createLowPolyMesh(lowPolySphere(0.14), secondaryColor);
            ear.position.set(side * 0.32, 1.45, 0.02);
            earGroup.add(ear);

            const innerEar = createLowPolyMesh(lowPolySphere(0.07), 0x333333);
            innerEar.position.set(side * 0.34, 1.45, 0.07);
            earGroup.add(innerEar);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Muzzle
          const muzzle = createLowPolyMesh(lowPolySphere(0.13), primaryColor);
          muzzle.scale.set(1.08, 0.78, 0.82);
          muzzle.position.set(0, 1.04, 0.36);
          animal.add(muzzle);

          // Faceted nose
          const nose = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.055),
            secondaryColor
          );
          nose.scale.set(1.3, 0.9, 1.0);
          nose.position.set(0, 1.07, 0.46);
          animal.add(nose);

          // Arms (black) with paws
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = createLowPolyMesh(
              lowPolyCylinder(0.12, 0.11, 0.28),
              secondaryColor
            );
            armGroup.add(arm);

            const paw = createLowPolyMesh(lowPolySphere(0.08), secondaryColor);
            paw.scale.set(1.15, 0.65, 0.95);
            paw.position.y = -0.18;
            armGroup.add(paw);

            armGroup.rotation.z = side * 0.5;
            armGroup.position.set(side * 0.45, 0.56, 0.1);
            animal.add(armGroup);
          });

          // Legs (black) with feet
          [-1, 1].forEach((side) => {
            const leg = createLowPolyMesh(
              lowPolyCylinder(0.13, 0.14, 0.24),
              secondaryColor
            );
            leg.position.set(side * 0.22, 0.12, 0);
            animal.add(leg);

            const foot = createLowPolyMesh(lowPolySphere(0.09), secondaryColor);
            foot.scale.set(1.1, 0.42, 1.15);
            foot.position.set(side * 0.22, 0.04, 0.02);
            animal.add(foot);
          });

          // Tiny tail
          const tail = createLowPolyMesh(lowPolySphere(0.05), primaryColor);
          tail.position.set(0, 0.36, -0.46);
          animal.add(tail);

          return animal;
        }

        // ===== LOW-POLY DUCK =====
        function createDuckLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Faceted plump body
          const body = createLowPolyMesh(lowPolySphere(0.4), primaryColor);
          body.scale.set(1.02, 0.86, 1.22);
          body.position.y = 0.42;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Breast highlight
          const breast = createLowPolyMesh(lowPolySphere(0.3), secondaryColor);
          breast.scale.set(0.88, 0.82, 0.52);
          breast.position.set(0, 0.38, 0.22);
          animal.add(breast);

          // Neck
          const neck = createLowPolyMesh(
            lowPolyCylinder(0.12, 0.1, 0.14),
            primaryColor
          );
          neck.position.set(0, 0.68, 0.08);
          animal.add(neck);

          // Faceted head
          const head = createLowPolyMesh(lowPolySphere(0.28), primaryColor);
          head.position.y = 0.88;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Faceted 2-part bill
          const billTop = createLowPolyMesh(
            new THREE.BoxGeometry(0.2, 0.055, 0.24),
            accentColor
          );
          billTop.position.set(0, 0.85, 0.35);
          animal.add(billTop);

          const billBottom = createLowPolyMesh(
            new THREE.BoxGeometry(0.17, 0.04, 0.22),
            accentColor
          );
          billBottom.position.set(0, 0.81, 0.34);
          animal.add(billBottom);

          // Gem-like eyes with highlights
          [-1, 1].forEach((side) => {
            const eyeWhite = new THREE.Mesh(
              new THREE.OctahedronGeometry(0.055),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            eyeWhite.position.set(side * 0.13, 0.9, 0.2);
            animal.add(eyeWhite);

            const pupil = new THREE.Mesh(
              new THREE.TetrahedronGeometry(0.03),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.13, 0.9, 0.24);
            animal.add(pupil);
          });

          // Faceted wings with feather tips
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wing = createLowPolyMesh(lowPolySphere(0.18), primaryColor);
            wing.scale.set(0.42, 0.82, 0.95);
            wingGroup.add(wing);

            // Feather tips
            for (let f = 0; f < 3; f++) {
              const feather = createLowPolyMesh(
                lowPolyCylinder(0.022, 0.018, 0.08),
                primaryColor
              );
              feather.position.set(0, -0.12 - f * 0.06, -0.03 + f * 0.02);
              feather.rotation.x = 0.3;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.36, 0.42, -0.04);
            wingGroup.rotation.z = side * 0.12;
            animal.add(wingGroup);
          });

          // Faceted tail feathers
          const tailGroup = new THREE.Group();
          for (let t = 0; t < 3; t++) {
            const tailFeather = createLowPolyMesh(
              new THREE.ConeGeometry(0.04 - t * 0.005, 0.12 + t * 0.02, 4),
              primaryColor
            );
            tailFeather.position.set((t - 1) * 0.025, 0, t * 0.012);
            tailFeather.rotation.x = Math.PI / 2 + 0.35;
            tailGroup.add(tailFeather);
          }
          tailGroup.position.set(0, 0.46, -0.45);
          animal.add(tailGroup);

          // Webbed feet with toes
          [-1, 1].forEach((side) => {
            const footGroup = new THREE.Group();

            const foot = createLowPolyMesh(lowPolySphere(0.085), accentColor);
            foot.scale.set(1.22, 0.32, 1.55);
            footGroup.add(foot);

            // Three toes
            for (let toe = 0; toe < 3; toe++) {
              const toeMesh = createLowPolyMesh(
                lowPolySphere(0.028),
                accentColor
              );
              toeMesh.scale.set(0.85, 0.38, 1.75);
              toeMesh.position.set((toe - 1) * 0.04, 0, 0.08);
              footGroup.add(toeMesh);
            }

            footGroup.position.set(side * 0.14, 0.04, 0.06);
            animal.add(footGroup);
          });

          return animal;
        }

        // ===== LOW-POLY FROG =====
        function createFrogLowPoly(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Squat body
          const body = createLowPolyMesh(lowPolySphere(0.38), primaryColor);
          body.scale.set(1.2, 0.7, 1.0);
          body.position.y = 0.3;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createLowPolyMesh(lowPolySphere(0.3), secondaryColor);
          belly.scale.set(1.0, 0.6, 0.5);
          belly.position.set(0, 0.25, 0.15);
          animal.add(belly);

          // Wide head
          const head = createLowPolyMesh(lowPolySphere(0.28), primaryColor);
          head.scale.set(1.3, 0.8, 1.0);
          head.position.set(0, 0.45, 0.12);
          animal.add(head);

          // Bulging eyes
          [-1, 1].forEach((side) => {
            const eyeBulge = createLowPolyMesh(
              lowPolySphere(0.12),
              primaryColor
            );
            eyeBulge.position.set(side * 0.2, 0.58, 0.15);
            animal.add(eyeBulge);

            const eye = new THREE.Mesh(
              lowPolySphere(0.08),
              new THREE.MeshBasicMaterial({ color: 0xffd700 })
            );
            eye.position.set(side * 0.2, 0.6, 0.22);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              lowPolySphere(0.04),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 0.6, 0.28);
            animal.add(pupil);
          });

          // Front legs
          [-1, 1].forEach((side) => {
            const arm = createLowPolyMesh(
              lowPolyCylinder(0.05, 0.04, 0.15),
              primaryColor
            );
            arm.rotation.z = side * 0.8;
            arm.position.set(side * 0.32, 0.12, 0.12);
            animal.add(arm);
          });

          // Back legs
          [-1, 1].forEach((side) => {
            const thigh = createLowPolyMesh(lowPolySphere(0.12), primaryColor);
            thigh.scale.set(0.8, 1.1, 1.0);
            thigh.position.set(side * 0.32, 0.18, -0.12);
            animal.add(thigh);

            const calf = createLowPolyMesh(
              lowPolyCylinder(0.05, 0.05, 0.18),
              primaryColor
            );
            calf.rotation.x = 0.8;
            calf.position.set(side * 0.38, 0.06, -0.22);
            animal.add(calf);
          });

          return animal;
        }

        // ===== LOW-POLY ELEPHANT =====
        function createElephantLowPoly(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "lowpoly";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Massive faceted body
          const body = createLowPolyMesh(lowPolySphere(0.54), primaryColor);
          body.scale.set(1.22, 0.92, 1.02);
          body.position.y = 0.6;
          animal.add(body);

          // Faceted head
          const head = createLowPolyMesh(lowPolySphere(0.4), primaryColor);
          head.scale.set(1.02, 1.0, 0.98);
          head.position.y = 1.1;
          animal.add(head);
          animal.userData.animationData.head = head;

          // SEGMENTED trunk (faceted)
          const trunkGroup = new THREE.Group();
          for (let s = 0; s < 4; s++) {
            const seg = createLowPolyMesh(
              lowPolyCylinder(0.09 - s * 0.015, 0.08 - s * 0.015, 0.1),
              primaryColor
            );
            seg.position.y = -s * 0.09;
            trunkGroup.add(seg);
          }
          const trunkTip = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.04),
            secondaryColor
          );
          trunkTip.position.set(0, -0.38, 0.03);
          trunkGroup.add(trunkTip);

          trunkGroup.rotation.x = 0.42;
          trunkGroup.position.set(0, 0.92, 0.44);
          animal.add(trunkGroup);
          animal.userData.animationData.trunk = trunkGroup;

          // Large faceted ears with inner detail
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createLowPolyMesh(lowPolySphere(0.35), primaryColor);
            ear.scale.set(0.16, 0.95, 0.78);
            earGroup.add(ear);

            const innerEar = createLowPolyMesh(
              lowPolySphere(0.25),
              secondaryColor
            );
            innerEar.scale.set(0.14, 0.75, 0.58);
            innerEar.position.z = 0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.4, 1.0, -0.04);
            earGroup.rotation.y = side * 0.12;
            animal.add(earGroup);
          });

          // Gem-like eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              new THREE.OctahedronGeometry(0.05),
              new THREE.MeshBasicMaterial({ color: 0x4a3020 })
            );
            eye.position.set(side * 0.18, 1.14, 0.34);
            animal.add(eye);
          });

          // Angular tusks
          [-1, 1].forEach((side) => {
            const tusk = createLowPolyMesh(
              new THREE.ConeGeometry(0.035, 0.24, 4),
              0xfffff0
            );
            tusk.rotation.z = side * 0.28;
            tusk.rotation.x = -0.28;
            tusk.position.set(side * 0.18, 0.85, 0.38);
            animal.add(tusk);
          });

          // Chunky faceted legs with toenails
          const legPositions = [
            { x: -0.34, z: 0.18 },
            { x: 0.34, z: 0.18 },
            { x: -0.3, z: -0.2 },
            { x: 0.3, z: -0.2 },
          ];
          legPositions.forEach((pos) => {
            const leg = createLowPolyMesh(
              lowPolyCylinder(0.14, 0.16, 0.44),
              primaryColor
            );
            leg.position.set(pos.x, 0.22, pos.z);
            animal.add(leg);

            const foot = createLowPolyMesh(lowPolySphere(0.11), secondaryColor);
            foot.scale.set(1.2, 0.42, 1.22);
            foot.position.set(pos.x, 0.045, pos.z);
            animal.add(foot);

            // Toenails
            for (let t = 0; t < 3; t++) {
              const nail = createLowPolyMesh(
                new THREE.TetrahedronGeometry(0.022),
                0xe8e8d8
              );
              nail.position.set(pos.x + (t - 1) * 0.035, 0.04, pos.z + 0.1);
              animal.add(nail);
            }
          });

          // Tail with tuft
          const tailGroup = new THREE.Group();
          const tailBody = createLowPolyMesh(
            lowPolyCylinder(0.025, 0.035, 0.26),
            primaryColor
          );
          tailGroup.add(tailBody);

          const tailTuft = createLowPolyMesh(
            new THREE.TetrahedronGeometry(0.04),
            0x3a3a3a
          );
          tailTuft.scale.set(1.0, 1.5, 1.0);
          tailTuft.position.y = -0.16;
          tailGroup.add(tailTuft);

          tailGroup.rotation.x = 0.72;
          tailGroup.position.set(0, 0.5, -0.54);
          animal.add(tailGroup);

          return animal;
        }

        // Register low-poly builders
        const LOW_POLY_BUILDERS = {
          bunny: createBunnyLowPoly,
          bear: createBearLowPoly,
          penguin: createPenguinLowPoly,
          fox: createFoxLowPoly,
          cat: createCatLowPoly,
          owl: createOwlLowPoly,
          panda: createPandaLowPoly,
          duck: createDuckLowPoly,
          frog: createFrogLowPoly,
          elephant: createElephantLowPoly,
        };

        // Register the low-poly style
        MODEL_STYLE_BUILDERS.lowpoly = LOW_POLY_BUILDERS;
        console.log(
          "[Registration] Low-poly builders registered:",
          Object.keys(LOW_POLY_BUILDERS).join(", ")
        );

        // ==========================================
        // GHIBLI/WATERCOLOR STYLE BUILDERS (Phase 5)
        // ==========================================

        const GHIBLI_SEGMENTS = 48; // Very smooth, soft look

        // Helper: Create Ghibli-style mesh with soft watercolor material
        function createGhibliMesh(geometry, baseColor) {
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);

          // Shift colors to be softer/more pastel with warm undertones
          const hsl = {};
          color.getHSL(hsl);
          // Reduce saturation, slightly warm the hue, lighten
          color.setHSL(
            hsl.h + 0.02, // Slight warm shift
            hsl.s * 0.75 * (style ? style.saturation : 1.0), // Softer saturation
            Math.min(0.85, hsl.l * 1.1) // Lighter
          );

          const material = new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: 0.6, // Soft, matte look
            metalness: 0.0,
            clearcoat: 0.1,
            clearcoatRoughness: 0.8,
            sheen: 0.4,
            sheenRoughness: 0.8,
            sheenColor: color.clone().offsetHSL(0.05, -0.2, 0.1),
            envMapIntensity: 0.3,
            side: THREE.DoubleSide,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          return mesh;
        }

        // Helper: Ghibli geometries (very smooth)
        function ghibliSphere(radius) {
          return new THREE.SphereGeometry(
            radius,
            GHIBLI_SEGMENTS,
            GHIBLI_SEGMENTS
          );
        }

        function ghibliCylinder(rTop, rBot, height) {
          return new THREE.CylinderGeometry(rTop, rBot, height, 24);
        }

        // ===== GHIBLI BUNNY =====
        function createBunnyGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft, round body
          const body = createGhibliMesh(ghibliSphere(0.42), primaryColor);
          body.scale.set(0.9, 1.1, 1.0);
          body.position.y = 0.5;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Gentle rounded head
          const head = createGhibliMesh(ghibliSphere(0.4), primaryColor);
          head.scale.set(1.1, 1.0, 1.0);
          head.position.y = 1.08;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft floppy ears
          [-1, 1].forEach((side) => {
            const ear = createGhibliMesh(
              new THREE.CapsuleGeometry(0.08, 0.5, 16, 24),
              primaryColor
            );
            ear.position.set(side * 0.2, 1.55, -0.05);
            ear.rotation.z = side * -0.15;
            ear.rotation.x = 0.1;
            animal.add(ear);

            const innerEar = createGhibliMesh(
              new THREE.CapsuleGeometry(0.04, 0.35, 12, 16),
              secondaryColor
            );
            innerEar.position.set(side * 0.2, 1.52, 0);
            innerEar.rotation.z = side * -0.15;
            innerEar.rotation.x = 0.1;
            animal.add(innerEar);
          });

          // Large, gentle eyes (Ghibli signature)
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.1), 0xffffff);
            eyeWhite.scale.set(1, 1.15, 0.7);
            eyeWhite.position.set(side * 0.18, 1.12, 0.34);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x4a3728 })
            );
            iris.position.set(side * 0.18, 1.12, 0.4);
            animal.add(iris);

            // Gentle highlight
            const highlight = new THREE.Mesh(
              ghibliSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.16, 1.14, 0.42);
            animal.add(highlight);
          });

          // Soft pink nose
          const nose = createGhibliMesh(ghibliSphere(0.05), 0xffb6c1);
          nose.scale.set(1.2, 0.8, 0.9);
          nose.position.set(0, 1.02, 0.42);
          animal.add(nose);

          // Fluffy tail
          const tail = createGhibliMesh(ghibliSphere(0.14), primaryColor);
          tail.position.set(0, 0.48, -0.35);
          animal.add(tail);

          // Soft rounded legs
          [-1, 1].forEach((side) => {
            const leg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.06, 0.12, 12, 16),
              primaryColor
            );
            leg.position.set(side * 0.18, 0.08, 0.15);
            animal.add(leg);
          });

          return animal;
        }

        // ===== GHIBLI BEAR =====
        function createBearGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft round body
          const body = createGhibliMesh(ghibliSphere(0.55), primaryColor);
          body.scale.set(1.2, 1.0, 1.05);
          body.position.y = 0.58;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Soft belly
          const belly = createGhibliMesh(ghibliSphere(0.4), secondaryColor);
          belly.scale.set(0.95, 1.05, 0.5);
          belly.position.set(0, 0.5, 0.28);
          animal.add(belly);

          // Rounded head
          const head = createGhibliMesh(ghibliSphere(0.45), primaryColor);
          head.position.y = 1.2;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft muzzle
          const muzzle = createGhibliMesh(ghibliSphere(0.18), secondaryColor);
          muzzle.scale.set(1.0, 0.8, 0.85);
          muzzle.position.set(0, 1.1, 0.4);
          animal.add(muzzle);

          // Gentle nose
          const nose = createGhibliMesh(ghibliSphere(0.08), accentColor);
          nose.position.set(0, 1.15, 0.55);
          animal.add(nose);

          // Round soft ears
          [-1, 1].forEach((side) => {
            const ear = createGhibliMesh(ghibliSphere(0.14), primaryColor);
            ear.position.set(side * 0.32, 1.52, 0);
            animal.add(ear);
          });

          // Large gentle eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.08), 0xffffff);
            eyeWhite.position.set(side * 0.2, 1.25, 0.38);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x3a2a1a })
            );
            iris.position.set(side * 0.2, 1.25, 0.44);
            animal.add(iris);
          });

          // Soft legs
          const legPositions = [
            { x: -0.35, z: 0.18 },
            { x: 0.35, z: 0.18 },
            { x: -0.3, z: -0.2 },
            { x: 0.3, z: -0.2 },
          ];
          legPositions.forEach((pos) => {
            const leg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.12, 0.18, 12, 16),
              primaryColor
            );
            leg.position.set(pos.x, 0.12, pos.z);
            animal.add(leg);
          });

          return animal;
        }

        // ===== GHIBLI PENGUIN =====
        function createPenguinGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft egg body
          const body = createGhibliMesh(ghibliSphere(0.5), primaryColor);
          body.scale.set(1.0, 1.15, 0.92);
          body.position.y = 0.55;
          animal.add(body);
          animal.userData.animationData.body = body;

          // White belly
          const belly = createGhibliMesh(ghibliSphere(0.42), secondaryColor);
          belly.scale.set(0.92, 1.0, 0.5);
          belly.position.set(0, 0.55, 0.22);
          animal.add(belly);

          // Soft head
          const head = createGhibliMesh(ghibliSphere(0.38), primaryColor);
          head.position.y = 1.1;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face patch
          const face = createGhibliMesh(ghibliSphere(0.25), secondaryColor);
          face.scale.set(1, 1, 0.4);
          face.position.set(0, 1.08, 0.28);
          animal.add(face);

          // Gentle eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.08), 0xffffff);
            eyeWhite.scale.set(1, 1.1, 0.7);
            eyeWhite.position.set(side * 0.12, 1.12, 0.32);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x1a1a2e })
            );
            iris.position.set(side * 0.12, 1.12, 0.36);
            animal.add(iris);
          });

          // Soft beak
          const beak = createGhibliMesh(
            new THREE.ConeGeometry(0.07, 0.14, 16),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.3;
          beak.position.set(0, 1.02, 0.4);
          animal.add(beak);

          // Soft flippers
          [-1, 1].forEach((side) => {
            const flipper = createGhibliMesh(
              new THREE.CapsuleGeometry(0.06, 0.28, 12, 16),
              primaryColor
            );
            flipper.rotation.z = side * 0.4;
            flipper.position.set(side * 0.45, 0.55, 0);
            animal.add(flipper);
          });

          // Feet
          [-1, 1].forEach((side) => {
            const foot = createGhibliMesh(ghibliSphere(0.09), accentColor);
            foot.scale.set(1.2, 0.4, 1.4);
            foot.position.set(side * 0.15, 0.04, 0.08);
            animal.add(foot);
          });

          return animal;
        }

        // ===== GHIBLI FOX =====
        function createFoxGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft sleek body
          const body = createGhibliMesh(ghibliSphere(0.4), primaryColor);
          body.scale.set(1.02, 0.88, 1.28);
          body.position.y = 0.46;
          animal.add(body);

          // White fluffy chest
          const chest = createGhibliMesh(ghibliSphere(0.28), secondaryColor);
          chest.scale.set(0.82, 1.0, 0.58);
          chest.position.set(0, 0.5, 0.22);
          animal.add(chest);

          // Soft rounded head
          const head = createGhibliMesh(ghibliSphere(0.32), primaryColor);
          head.scale.set(1.1, 0.97, 1.02);
          head.position.y = 0.95;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Gentle snout
          const snout = createGhibliMesh(
            new THREE.CapsuleGeometry(0.08, 0.12, 16, 20),
            secondaryColor
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.88, 0.35);
          animal.add(snout);

          // Little pink nose
          const nose = createGhibliMesh(ghibliSphere(0.045), accentColor);
          nose.position.set(0, 0.88, 0.48);
          animal.add(nose);

          // Soft triangular ears with pink inner
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createGhibliMesh(
              new THREE.ConeGeometry(0.11, 0.24, 20),
              primaryColor
            );
            earGroup.add(ear);

            // Inner ear pink
            const inner = createGhibliMesh(
              new THREE.ConeGeometry(0.06, 0.16, 16),
              0xffb6c1
            );
            inner.position.set(0, -0.02, 0.02);
            earGroup.add(inner);

            earGroup.position.set(side * 0.22, 1.22, -0.04);
            earGroup.rotation.z = side * -0.2;
            animal.add(earGroup);
          });

          // Dreamy gentle eyes with highlights
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.08), 0xffffff);
            eyeWhite.scale.set(1.15, 0.92, 0.72);
            eyeWhite.position.set(side * 0.16, 0.98, 0.28);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.045),
              new THREE.MeshBasicMaterial({ color: 0xd4a574 })
            );
            iris.position.set(side * 0.16, 0.98, 0.34);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              ghibliSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0x2a2020 })
            );
            pupil.position.set(side * 0.16, 0.98, 0.36);
            animal.add(pupil);

            // Dreamy highlight
            const highlight = new THREE.Mesh(
              ghibliSphere(0.015),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.145, 1.0, 0.37);
            animal.add(highlight);
          });

          // Cheek blush (Ghibli signature)
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              ghibliSphere(0.06),
              new THREE.MeshPhysicalMaterial({
                color: 0xffb6c1,
                transparent: true,
                opacity: 0.35,
                roughness: 0.8,
              })
            );
            blush.scale.set(1.3, 0.8, 0.4);
            blush.position.set(side * 0.25, 0.92, 0.28);
            animal.add(blush);
          });

          // Fluffy dreamy tail
          const tailGroup = new THREE.Group();
          const tailBase = createGhibliMesh(
            new THREE.CapsuleGeometry(0.12, 0.35, 20, 28),
            primaryColor
          );
          tailGroup.add(tailBase);

          const tailTip = createGhibliMesh(ghibliSphere(0.12), secondaryColor);
          tailTip.position.y = 0.25;
          tailGroup.add(tailTip);

          tailGroup.rotation.x = 0.65;
          tailGroup.position.set(0, 0.4, -0.48);
          animal.add(tailGroup);

          // Soft little legs
          [-1, 1].forEach((side) => {
            const frontLeg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.055, 0.14, 14, 18),
              primaryColor
            );
            frontLeg.position.set(side * 0.17, 0.09, 0.18);
            animal.add(frontLeg);

            const backLeg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.06, 0.15, 14, 18),
              primaryColor
            );
            backLeg.position.set(side * 0.17, 0.1, -0.16);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== GHIBLI CAT =====
        function createCatGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft sleek body
          const body = createGhibliMesh(ghibliSphere(0.34), primaryColor);
          body.scale.set(0.9, 0.85, 1.18);
          body.position.y = 0.4;
          animal.add(body);

          // Soft head
          const head = createGhibliMesh(ghibliSphere(0.3), primaryColor);
          head.scale.set(1.08, 1.0, 0.95);
          head.position.y = 0.85;
          animal.add(head);

          // Soft muzzle
          const muzzle = createGhibliMesh(ghibliSphere(0.11), secondaryColor);
          muzzle.scale.set(1.0, 0.7, 0.8);
          muzzle.position.set(0, 0.78, 0.26);
          animal.add(muzzle);

          // Pink nose
          const nose = createGhibliMesh(ghibliSphere(0.03), 0xffb6c1);
          nose.position.set(0, 0.82, 0.32);
          animal.add(nose);

          // Soft triangle ears
          [-1, 1].forEach((side) => {
            const ear = createGhibliMesh(
              new THREE.ConeGeometry(0.08, 0.18, 16),
              primaryColor
            );
            ear.position.set(side * 0.18, 1.1, -0.05);
            ear.rotation.z = side * -0.15;
            animal.add(ear);
          });

          // Gentle cat eyes (slightly almond)
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.07), 0xffffff);
            eyeWhite.scale.set(1.2, 0.9, 0.7);
            eyeWhite.position.set(side * 0.12, 0.88, 0.24);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.04),
              new THREE.MeshBasicMaterial({ color: 0x7cfc00 })
            );
            iris.position.set(side * 0.12, 0.88, 0.28);
            animal.add(iris);
          });

          // Soft curved tail
          const tail = createGhibliMesh(
            new THREE.CapsuleGeometry(0.04, 0.38, 12, 16),
            primaryColor
          );
          tail.rotation.x = 1.1;
          tail.rotation.z = 0.25;
          tail.position.set(0, 0.42, -0.42);
          animal.add(tail);

          // Soft legs (front and back)
          [-1, 1].forEach((side) => {
            const frontLeg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.04, 0.1, 12, 16),
              primaryColor
            );
            frontLeg.position.set(side * 0.14, 0.08, 0.12);
            animal.add(frontLeg);

            const backLeg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.045, 0.12, 12, 16),
              primaryColor
            );
            backLeg.position.set(side * 0.13, 0.09, -0.14);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== GHIBLI OWL =====
        function createOwlGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft round fluffy body
          const body = createGhibliMesh(ghibliSphere(0.42), primaryColor);
          body.scale.set(1.02, 1.12, 0.92);
          body.position.y = 0.48;
          animal.add(body);

          // Soft feathered chest
          const chest = createGhibliMesh(ghibliSphere(0.32), secondaryColor);
          chest.scale.set(0.9, 1.0, 0.52);
          chest.position.set(0, 0.44, 0.22);
          animal.add(chest);

          // Large soft head
          const head = createGhibliMesh(ghibliSphere(0.4), primaryColor);
          head.position.y = 1.0;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft facial disc
          const disc = createGhibliMesh(ghibliSphere(0.3), secondaryColor);
          disc.scale.set(1.02, 1.0, 0.42);
          disc.position.set(0, 0.98, 0.24);
          animal.add(disc);

          // Large dreamy eyes (signature Ghibli) with glow
          [-1, 1].forEach((side) => {
            // Eye glow
            const eyeGlow = new THREE.Mesh(
              ghibliSphere(0.13),
              new THREE.MeshPhysicalMaterial({
                color: 0xffd080,
                transparent: true,
                opacity: 0.3,
                emissive: 0xffa500,
                emissiveIntensity: 0.1,
              })
            );
            eyeGlow.position.set(side * 0.15, 1.0, 0.34);
            animal.add(eyeGlow);

            const eyeWhite = createGhibliMesh(ghibliSphere(0.11), 0xffffff);
            eyeWhite.position.set(side * 0.15, 1.0, 0.35);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.065),
              new THREE.MeshBasicMaterial({ color: 0xffa500 })
            );
            iris.position.set(side * 0.15, 1.0, 0.42);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              ghibliSphere(0.035),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.15, 1.0, 0.46);
            animal.add(pupil);

            // Sparkle highlights
            const highlight1 = new THREE.Mesh(
              ghibliSphere(0.018),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight1.position.set(side * 0.135, 1.03, 0.47);
            animal.add(highlight1);

            const highlight2 = new THREE.Mesh(
              ghibliSphere(0.01),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight2.position.set(side * 0.16, 0.98, 0.47);
            animal.add(highlight2);
          });

          // Small soft beak
          const beak = createGhibliMesh(
            new THREE.ConeGeometry(0.045, 0.1, 14),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.42;
          beak.position.set(0, 0.92, 0.38);
          animal.add(beak);

          // Soft fluffy ear tufts
          [-1, 1].forEach((side) => {
            const tuftGroup = new THREE.Group();
            for (let i = 0; i < 2; i++) {
              const tuft = createGhibliMesh(
                new THREE.ConeGeometry(0.05 - i * 0.012, 0.13 - i * 0.02, 14),
                primaryColor
              );
              tuft.position.set(i * side * 0.015, i * 0.02, 0);
              tuftGroup.add(tuft);
            }
            tuftGroup.position.set(side * 0.28, 1.32, -0.04);
            tuftGroup.rotation.z = side * -0.26;
            animal.add(tuftGroup);
          });

          // Soft layered wings
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wingBase = createGhibliMesh(ghibliSphere(0.22), primaryColor);
            wingBase.scale.set(0.42, 1.0, 0.78);
            wingGroup.add(wingBase);

            // Soft feather tips
            for (let f = 0; f < 3; f++) {
              const feather = createGhibliMesh(
                new THREE.CapsuleGeometry(0.025, 0.06, 10, 12),
                primaryColor
              );
              feather.position.set(0, -0.14 - f * 0.055, 0.02);
              feather.rotation.x = 0.35;
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.4, 0.48, -0.04);
            animal.add(wingGroup);
          });

          // Little soft feet
          [-1, 1].forEach((side) => {
            const foot = createGhibliMesh(ghibliSphere(0.055), accentColor);
            foot.scale.set(1.22, 0.52, 1.45);
            foot.position.set(side * 0.11, 0.045, 0.06);
            animal.add(foot);
          });

          return animal;
        }

        // ===== GHIBLI PANDA =====
        function createPandaGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft round body
          const body = createGhibliMesh(ghibliSphere(0.52), primaryColor);
          body.scale.set(1.04, 1.0, 0.98);
          body.position.y = 0.56;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Soft belly
          const belly = createGhibliMesh(ghibliSphere(0.38), primaryColor);
          belly.scale.set(0.88, 0.95, 0.5);
          belly.position.set(0, 0.52, 0.22);
          animal.add(belly);

          // Soft round head
          const head = createGhibliMesh(ghibliSphere(0.44), primaryColor);
          head.scale.set(1.04, 1.0, 1.0);
          head.position.y = 1.16;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft cheek puffs
          [-1, 1].forEach((side) => {
            const cheek = createGhibliMesh(ghibliSphere(0.12), primaryColor);
            cheek.position.set(side * 0.32, 1.06, 0.18);
            animal.add(cheek);
          });

          // Soft tear-drop eye patches
          [-1, 1].forEach((side) => {
            const patchGroup = new THREE.Group();

            const patch = createGhibliMesh(ghibliSphere(0.16), secondaryColor);
            patch.scale.set(1.22, 1.35, 0.52);
            patchGroup.add(patch);

            // Tear-drop extension
            const tearDrop = createGhibliMesh(
              ghibliSphere(0.09),
              secondaryColor
            );
            tearDrop.scale.set(1.0, 1.22, 0.48);
            tearDrop.position.set(side * 0.03, -0.1, 0.02);
            patchGroup.add(tearDrop);

            patchGroup.position.set(side * 0.18, 1.18, 0.3);
            patchGroup.rotation.z = side * -0.12;
            animal.add(patchGroup);

            // Gentle white eyes
            const eyeWhite = createGhibliMesh(ghibliSphere(0.07), 0xffffff);
            eyeWhite.position.set(side * 0.18, 1.18, 0.38);
            animal.add(eyeWhite);

            // Soft iris
            const iris = new THREE.Mesh(
              ghibliSphere(0.045),
              new THREE.MeshBasicMaterial({ color: 0x1a1a2e })
            );
            iris.position.set(side * 0.18, 1.18, 0.42);
            animal.add(iris);

            // Dreamy highlight
            const highlight = new THREE.Mesh(
              ghibliSphere(0.018),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.17, 1.2, 0.44);
            animal.add(highlight);
          });

          // Cheek blush
          [-1, 1].forEach((side) => {
            const blush = new THREE.Mesh(
              new THREE.CircleGeometry(0.045, 16),
              new THREE.MeshPhysicalMaterial({
                color: 0xffcccc,
                transparent: true,
                opacity: 0.28,
                roughness: 0.8,
              })
            );
            blush.position.set(side * 0.34, 1.02, 0.3);
            blush.rotation.y = side * 0.25;
            animal.add(blush);
          });

          // Soft round ears with inner detail
          const earGroup = new THREE.Group();
          [-1, 1].forEach((side) => {
            const ear = createGhibliMesh(ghibliSphere(0.14), secondaryColor);
            ear.position.set(side * 0.34, 1.5, 0.02);
            earGroup.add(ear);

            const innerEar = createGhibliMesh(ghibliSphere(0.07), 0x333333);
            innerEar.position.set(side * 0.36, 1.5, 0.06);
            earGroup.add(innerEar);
          });
          animal.userData.animationData.ears = earGroup;
          animal.add(earGroup);

          // Soft muzzle
          const muzzle = createGhibliMesh(ghibliSphere(0.13), primaryColor);
          muzzle.scale.set(1.06, 0.75, 0.8);
          muzzle.position.set(0, 1.05, 0.36);
          animal.add(muzzle);

          // Soft nose
          const nose = createGhibliMesh(ghibliSphere(0.06), secondaryColor);
          nose.scale.set(1.2, 0.85, 1.0);
          nose.position.set(0, 1.08, 0.45);
          animal.add(nose);

          // Soft arms with paws
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = createGhibliMesh(
              new THREE.CapsuleGeometry(0.11, 0.2, 14, 18),
              secondaryColor
            );
            armGroup.add(arm);

            const paw = createGhibliMesh(ghibliSphere(0.08), secondaryColor);
            paw.scale.set(1.12, 0.62, 0.92);
            paw.position.y = -0.16;
            armGroup.add(paw);

            armGroup.rotation.z = side * 0.48;
            armGroup.position.set(side * 0.46, 0.56, 0.1);
            animal.add(armGroup);
          });

          // Soft legs with feet
          [-1, 1].forEach((side) => {
            const leg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.12, 0.14, 14, 18),
              secondaryColor
            );
            leg.position.set(side * 0.22, 0.1, 0);
            animal.add(leg);

            const foot = createGhibliMesh(ghibliSphere(0.085), secondaryColor);
            foot.scale.set(1.08, 0.4, 1.12);
            foot.position.set(side * 0.22, 0.04, 0.02);
            animal.add(foot);
          });

          // Tiny tail
          const tail = createGhibliMesh(ghibliSphere(0.05), primaryColor);
          tail.position.set(0, 0.36, -0.48);
          animal.add(tail);

          return animal;
        }

        // ===== GHIBLI DUCK =====
        function createDuckGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft round body
          const body = createGhibliMesh(ghibliSphere(0.4), primaryColor);
          body.scale.set(1.0, 0.85, 1.18);
          body.position.y = 0.42;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Soft head
          const head = createGhibliMesh(ghibliSphere(0.28), primaryColor);
          head.position.y = 0.86;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft bill
          const bill = createGhibliMesh(ghibliSphere(0.11), accentColor);
          bill.scale.set(1.0, 0.5, 1.3);
          bill.position.set(0, 0.82, 0.32);
          animal.add(bill);

          // Gentle eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.06), 0xffffff);
            eyeWhite.position.set(side * 0.12, 0.88, 0.2);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.035),
              new THREE.MeshBasicMaterial({ color: 0x1a1a2e })
            );
            iris.position.set(side * 0.12, 0.88, 0.24);
            animal.add(iris);
          });

          // Soft wings
          [-1, 1].forEach((side) => {
            const wing = createGhibliMesh(ghibliSphere(0.17), primaryColor);
            wing.scale.set(0.4, 0.8, 0.95);
            wing.position.set(side * 0.34, 0.42, -0.05);
            animal.add(wing);
          });

          // Soft tail
          const tail = createGhibliMesh(
            new THREE.ConeGeometry(0.09, 0.14, 16),
            primaryColor
          );
          tail.rotation.x = Math.PI / 2 + 0.4;
          tail.position.set(0, 0.46, -0.44);
          animal.add(tail);

          // Little feet
          [-1, 1].forEach((side) => {
            const foot = createGhibliMesh(ghibliSphere(0.08), accentColor);
            foot.scale.set(1.2, 0.35, 1.4);
            foot.position.set(side * 0.12, 0.04, 0.05);
            animal.add(foot);
          });

          return animal;
        }

        // ===== GHIBLI FROG =====
        function createFrogGhibli(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft squat body
          const body = createGhibliMesh(ghibliSphere(0.4), primaryColor);
          body.scale.set(1.18, 0.7, 1.0);
          body.position.y = 0.32;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Soft belly
          const belly = createGhibliMesh(ghibliSphere(0.32), secondaryColor);
          belly.scale.set(1.0, 0.6, 0.55);
          belly.position.set(0, 0.28, 0.16);
          animal.add(belly);

          // Soft wide head
          const head = createGhibliMesh(ghibliSphere(0.3), primaryColor);
          head.scale.set(1.25, 0.8, 1.0);
          head.position.set(0, 0.46, 0.14);
          animal.add(head);
          animal.userData.animationData.head = head;

          // Large gentle bulging eyes
          [-1, 1].forEach((side) => {
            const eyeBulge = createGhibliMesh(ghibliSphere(0.12), primaryColor);
            eyeBulge.position.set(side * 0.2, 0.6, 0.16);
            animal.add(eyeBulge);

            const eyeWhite = createGhibliMesh(ghibliSphere(0.09), 0xffffff);
            eyeWhite.position.set(side * 0.2, 0.62, 0.23);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0xffd700 })
            );
            iris.position.set(side * 0.2, 0.62, 0.28);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              ghibliSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 0.62, 0.32);
            animal.add(pupil);
          });

          // Soft front legs
          [-1, 1].forEach((side) => {
            const arm = createGhibliMesh(
              new THREE.CapsuleGeometry(0.04, 0.1, 12, 16),
              primaryColor
            );
            arm.rotation.z = side * 0.75;
            arm.position.set(side * 0.34, 0.14, 0.12);
            animal.add(arm);
          });

          // Soft back legs
          [-1, 1].forEach((side) => {
            const thigh = createGhibliMesh(ghibliSphere(0.12), primaryColor);
            thigh.scale.set(0.8, 1.1, 1.0);
            thigh.position.set(side * 0.34, 0.2, -0.12);
            animal.add(thigh);

            const calf = createGhibliMesh(
              new THREE.CapsuleGeometry(0.05, 0.12, 12, 16),
              primaryColor
            );
            calf.rotation.x = 0.75;
            calf.position.set(side * 0.38, 0.08, -0.22);
            animal.add(calf);
          });

          return animal;
        }

        // ===== GHIBLI ELEPHANT =====
        function createElephantGhibli(
          type,
          colorOverride = null,
          options = {}
        ) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "ghibli";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Soft massive body
          const body = createGhibliMesh(ghibliSphere(0.56), primaryColor);
          body.scale.set(1.2, 0.92, 1.02);
          body.position.y = 0.62;
          animal.add(body);

          // Soft rounded head
          const head = createGhibliMesh(ghibliSphere(0.42), primaryColor);
          head.scale.set(1.02, 1.0, 0.98);
          head.position.y = 1.12;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Soft curling trunk
          const trunkGroup = new THREE.Group();
          for (let s = 0; s < 4; s++) {
            const seg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.075 - s * 0.012, 0.08, 14, 18),
              primaryColor
            );
            seg.position.y = -s * 0.09;
            trunkGroup.add(seg);
          }
          const trunkTip = createGhibliMesh(
            ghibliSphere(0.055),
            secondaryColor
          );
          trunkTip.position.set(0, -0.38, 0.04);
          trunkGroup.add(trunkTip);

          trunkGroup.rotation.x = 0.38;
          trunkGroup.position.set(0, 0.94, 0.44);
          animal.add(trunkGroup);
          animal.userData.animationData.trunk = trunkGroup;

          // Large soft ears with pink inner
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createGhibliMesh(ghibliSphere(0.36), primaryColor);
            ear.scale.set(0.16, 1.0, 0.82);
            earGroup.add(ear);

            const innerEar = createGhibliMesh(ghibliSphere(0.26), 0xffb6c1);
            innerEar.scale.set(0.14, 0.78, 0.62);
            innerEar.position.z = 0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.42, 1.02, -0.04);
            earGroup.rotation.y = side * 0.1;
            animal.add(earGroup);
          });

          // Gentle dreamy eyes
          [-1, 1].forEach((side) => {
            const eyeWhite = createGhibliMesh(ghibliSphere(0.07), 0xffffff);
            eyeWhite.position.set(side * 0.2, 1.16, 0.36);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              ghibliSphere(0.04),
              new THREE.MeshBasicMaterial({ color: 0x4a3020 })
            );
            iris.position.set(side * 0.2, 1.16, 0.4);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              ghibliSphere(0.022),
              new THREE.MeshBasicMaterial({ color: 0x1a1a1a })
            );
            pupil.position.set(side * 0.2, 1.16, 0.42);
            animal.add(pupil);

            // Dreamy highlight
            const highlight = new THREE.Mesh(
              ghibliSphere(0.012),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.185, 1.18, 0.43);
            animal.add(highlight);
          });

          // Soft curved tusks
          [-1, 1].forEach((side) => {
            const tusk = createGhibliMesh(
              new THREE.CapsuleGeometry(0.028, 0.16, 12, 16),
              0xfffff0
            );
            tusk.rotation.z = side * 0.26;
            tusk.rotation.x = -0.26;
            tusk.position.set(side * 0.18, 0.88, 0.4);
            animal.add(tusk);
          });

          // Soft chunky legs with round feet
          const legPositions = [
            { x: -0.34, z: 0.18 },
            { x: 0.34, z: 0.18 },
            { x: -0.3, z: -0.2 },
            { x: 0.3, z: -0.2 },
          ];
          legPositions.forEach((pos) => {
            const leg = createGhibliMesh(
              new THREE.CapsuleGeometry(0.13, 0.22, 18, 22),
              primaryColor
            );
            leg.position.set(pos.x, 0.14, pos.z);
            animal.add(leg);

            const foot = createGhibliMesh(ghibliSphere(0.11), secondaryColor);
            foot.scale.set(1.2, 0.42, 1.2);
            foot.position.set(pos.x, 0.045, pos.z);
            animal.add(foot);
          });

          // Soft tail with tuft
          const tailGroup = new THREE.Group();
          const tailBody = createGhibliMesh(
            new THREE.CapsuleGeometry(0.025, 0.18, 10, 14),
            primaryColor
          );
          tailGroup.add(tailBody);

          const tailTuft = createGhibliMesh(ghibliSphere(0.04), 0x4a4a4a);
          tailTuft.scale.set(1.0, 1.5, 1.0);
          tailTuft.position.y = -0.12;
          tailGroup.add(tailTuft);

          tailGroup.rotation.x = 0.72;
          tailGroup.position.set(0, 0.52, -0.54);
          animal.add(tailGroup);

          return animal;
        }

        // Register Ghibli builders
        const GHIBLI_BUILDERS = {
          bunny: createBunnyGhibli,
          bear: createBearGhibli,
          penguin: createPenguinGhibli,
          fox: createFoxGhibli,
          cat: createCatGhibli,
          owl: createOwlGhibli,
          panda: createPandaGhibli,
          duck: createDuckGhibli,
          frog: createFrogGhibli,
          elephant: createElephantGhibli,
        };

        // Register the Ghibli style
        MODEL_STYLE_BUILDERS.ghibli = GHIBLI_BUILDERS;
        console.log(
          "[Registration] Ghibli builders registered:",
          Object.keys(GHIBLI_BUILDERS).join(", ")
        );

        // ==========================================
        // CHIBI STYLE BUILDERS (Phase 6)
        // ==========================================

        const CHIBI_SEGMENTS = 32; // Smooth for cute look

        // Helper: Create chibi mesh with cute material
        function createChibiMesh(geometry, baseColor) {
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);
          const hsl = {};
          color.getHSL(hsl);
          // Brighten and saturate for kawaii look
          color.setHSL(
            hsl.h,
            Math.min(1.0, hsl.s * 1.15 * (style ? style.saturation : 1.0)),
            Math.min(0.9, hsl.l * 1.1)
          );

          const material = new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: style ? Math.max(0.2, style.roughness) : 0.3,
            metalness: style ? style.metalness : 0.0,
            clearcoat: style ? style.clearcoat * 0.8 : 0.5,
            clearcoatRoughness: style ? style.clearcoatRoughness : 0.2,
            sheen: 0.6,
            sheenRoughness: 0.4,
            sheenColor: color.clone().offsetHSL(0, 0.1, 0.2),
            envMapIntensity: 0.5,
            side: THREE.DoubleSide,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          return mesh;
        }

        // Helper: Chibi geometries
        function chibiSphere(radius) {
          return new THREE.SphereGeometry(
            radius,
            CHIBI_SEGMENTS,
            CHIBI_SEGMENTS
          );
        }

        // Helper: Create big sparkly chibi eyes
        function createChibiEyes(animal, side, yPos, zPos) {
          // Large white eye
          const eyeWhite = createChibiMesh(chibiSphere(0.15), 0xffffff);
          eyeWhite.scale.set(1.1, 1.2, 0.7);
          eyeWhite.position.set(side * 0.2, yPos, zPos);
          animal.add(eyeWhite);

          // Big iris
          const iris = new THREE.Mesh(
            chibiSphere(0.1),
            new THREE.MeshBasicMaterial({ color: 0x4a3728 })
          );
          iris.position.set(side * 0.2, yPos, zPos + 0.08);
          animal.add(iris);

          // Pupil
          const pupil = new THREE.Mesh(
            chibiSphere(0.05),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
          );
          pupil.position.set(side * 0.2, yPos, zPos + 0.12);
          animal.add(pupil);

          // Sparkle highlights (kawaii!)
          const spark1 = new THREE.Mesh(
            chibiSphere(0.04),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
          );
          spark1.position.set(side * 0.17, yPos + 0.05, zPos + 0.13);
          animal.add(spark1);

          const spark2 = new THREE.Mesh(
            chibiSphere(0.02),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
          );
          spark2.position.set(side * 0.23, yPos - 0.03, zPos + 0.11);
          animal.add(spark2);
        }

        // ===== CHIBI BUNNY =====
        function createBunnyChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Tiny round body
          const body = createChibiMesh(chibiSphere(0.28), primaryColor);
          body.scale.set(1.0, 0.9, 0.95);
          body.position.y = 0.28;
          animal.add(body);
          animal.userData.animationData.body = body;

          // HUGE head (signature chibi)
          const head = createChibiMesh(chibiSphere(0.55), primaryColor);
          head.position.y = 0.85;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Cheeks (blush)
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.08), 0xffcccc);
            cheek.scale.set(1.2, 0.8, 0.5);
            cheek.position.set(side * 0.4, 0.72, 0.32);
            animal.add(cheek);
          });

          // Long floppy ears
          [-1, 1].forEach((side) => {
            const ear = createChibiMesh(
              new THREE.CapsuleGeometry(0.1, 0.6, 16, 24),
              primaryColor
            );
            ear.position.set(side * 0.25, 1.55, -0.1);
            ear.rotation.z = side * -0.2;
            ear.rotation.x = 0.15;
            animal.add(ear);

            const innerEar = createChibiMesh(
              new THREE.CapsuleGeometry(0.05, 0.4, 12, 16),
              secondaryColor
            );
            innerEar.position.set(side * 0.25, 1.52, -0.05);
            innerEar.rotation.z = side * -0.2;
            innerEar.rotation.x = 0.15;
            animal.add(innerEar);
          });

          // Big sparkly eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.88, 0.42));

          // Tiny nose
          const nose = createChibiMesh(chibiSphere(0.04), 0xffb6c1);
          nose.position.set(0, 0.72, 0.52);
          animal.add(nose);

          // Little mouth (w shape)
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.04, 0.015, 8, 12, Math.PI),
            new THREE.MeshBasicMaterial({ color: 0x333333 })
          );
          mouth.rotation.x = Math.PI;
          mouth.position.set(0, 0.65, 0.5);
          animal.add(mouth);

          // Fluffy tail
          const tail = createChibiMesh(chibiSphere(0.12), primaryColor);
          tail.position.set(0, 0.25, -0.28);
          animal.add(tail);

          // Tiny stubby legs
          [-1, 1].forEach((side) => {
            const leg = createChibiMesh(chibiSphere(0.08), primaryColor);
            leg.scale.set(1, 0.8, 1);
            leg.position.set(side * 0.12, 0.06, 0.05);
            animal.add(leg);
          });

          return animal;
        }

        // ===== CHIBI BEAR =====
        function createBearChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small chubby body
          const body = createChibiMesh(chibiSphere(0.35), primaryColor);
          body.scale.set(1.1, 0.9, 1.0);
          body.position.y = 0.35;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Tummy
          const tummy = createChibiMesh(chibiSphere(0.22), secondaryColor);
          tummy.scale.set(1, 0.9, 0.5);
          tummy.position.set(0, 0.3, 0.18);
          animal.add(tummy);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.55), primaryColor);
          head.position.y = 0.95;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Muzzle
          const muzzle = createChibiMesh(chibiSphere(0.18), secondaryColor);
          muzzle.scale.set(1.0, 0.75, 0.8);
          muzzle.position.set(0, 0.82, 0.48);
          animal.add(muzzle);

          // Nose
          const nose = createChibiMesh(chibiSphere(0.07), accentColor);
          nose.position.set(0, 0.88, 0.62);
          animal.add(nose);

          // Round ears
          [-1, 1].forEach((side) => {
            const ear = createChibiMesh(chibiSphere(0.15), primaryColor);
            ear.position.set(side * 0.38, 1.38, 0);
            animal.add(ear);
          });

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.08), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.42, 0.78, 0.35);
            animal.add(cheek);
          });

          // Big eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.98, 0.42));

          // Tiny arms
          [-1, 1].forEach((side) => {
            const arm = createChibiMesh(chibiSphere(0.1), primaryColor);
            arm.scale.set(0.9, 1.2, 0.9);
            arm.position.set(side * 0.35, 0.35, 0.1);
            animal.add(arm);
          });

          // Tiny legs
          [-1, 1].forEach((side) => {
            const leg = createChibiMesh(chibiSphere(0.1), primaryColor);
            leg.position.set(side * 0.15, 0.08, 0);
            animal.add(leg);
          });

          return animal;
        }

        // ===== CHIBI PENGUIN =====
        function createPenguinChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small egg body
          const body = createChibiMesh(chibiSphere(0.32), primaryColor);
          body.scale.set(1.0, 0.95, 0.9);
          body.position.y = 0.32;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createChibiMesh(chibiSphere(0.25), secondaryColor);
          belly.scale.set(0.9, 0.9, 0.5);
          belly.position.set(0, 0.32, 0.15);
          animal.add(belly);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.52), primaryColor);
          head.position.y = 0.88;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face
          const face = createChibiMesh(chibiSphere(0.35), secondaryColor);
          face.scale.set(1, 1, 0.4);
          face.position.set(0, 0.85, 0.35);
          animal.add(face);

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.07), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.38, 0.75, 0.32);
            animal.add(cheek);
          });

          // Big eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.9, 0.4));

          // Tiny beak
          const beak = createChibiMesh(
            new THREE.ConeGeometry(0.06, 0.1, 12),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.3;
          beak.position.set(0, 0.75, 0.48);
          animal.add(beak);

          // Tiny flippers
          [-1, 1].forEach((side) => {
            const flipper = createChibiMesh(chibiSphere(0.1), primaryColor);
            flipper.scale.set(0.5, 1.0, 0.8);
            flipper.position.set(side * 0.35, 0.32, 0);
            animal.add(flipper);
          });

          // Little feet
          [-1, 1].forEach((side) => {
            const foot = createChibiMesh(chibiSphere(0.07), accentColor);
            foot.scale.set(1.2, 0.4, 1.3);
            foot.position.set(side * 0.12, 0.03, 0.05);
            animal.add(foot);
          });

          return animal;
        }

        // ===== CHIBI FOX =====
        function createFoxChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Tiny cute body
          const body = createChibiMesh(chibiSphere(0.26), primaryColor);
          body.scale.set(1.02, 0.88, 1.12);
          body.position.y = 0.26;
          animal.add(body);

          // Fluffy chest tuft
          const chest = createChibiMesh(chibiSphere(0.19), secondaryColor);
          chest.scale.set(0.82, 0.92, 0.52);
          chest.position.set(0, 0.29, 0.13);
          animal.add(chest);

          // HUGE adorable head
          const head = createChibiMesh(chibiSphere(0.52), primaryColor);
          head.position.y = 0.8;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Snout
          const snout = createChibiMesh(
            new THREE.ConeGeometry(0.13, 0.22, 18),
            secondaryColor
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.7, 0.48);
          animal.add(snout);

          // Pink nose
          const nose = createChibiMesh(chibiSphere(0.045), accentColor);
          nose.position.set(0, 0.7, 0.58);
          animal.add(nose);

          // Big triangle ears with pink inner
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createChibiMesh(
              new THREE.ConeGeometry(0.14, 0.3, 14),
              primaryColor
            );
            earGroup.add(ear);

            // Pink inner ear
            const inner = createChibiMesh(
              new THREE.ConeGeometry(0.08, 0.2, 12),
              0xffb6c1
            );
            inner.position.set(0, -0.02, 0.02);
            earGroup.add(inner);

            earGroup.position.set(side * 0.34, 1.22, -0.06);
            earGroup.rotation.z = side * -0.22;
            animal.add(earGroup);
          });

          // Blushy cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.075), 0xffcccc);
            cheek.scale.set(1.15, 0.72, 0.42);
            cheek.position.set(side * 0.4, 0.67, 0.34);
            animal.add(cheek);
          });

          // Big sparkly eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.84, 0.4));

          // Segmented fluffy tail
          const tailGroup = new THREE.Group();
          for (let s = 0; s < 3; s++) {
            const tailSeg = createChibiMesh(
              chibiSphere(0.16 - s * 0.03),
              primaryColor
            );
            tailSeg.scale.set(1.0, 0.9, 1.2 + s * 0.2);
            tailSeg.position.set(0, s * 0.05, -s * 0.14);
            tailGroup.add(tailSeg);
          }
          const tailTip = createChibiMesh(chibiSphere(0.11), secondaryColor);
          tailTip.position.set(0, 0.08, -0.45);
          tailGroup.add(tailTip);

          tailGroup.position.set(0, 0.28, -0.2);
          animal.add(tailGroup);

          // Tiny stubby legs
          [-1, 1].forEach((side) => {
            const frontLeg = createChibiMesh(chibiSphere(0.065), primaryColor);
            frontLeg.position.set(side * 0.11, 0.055, 0.06);
            animal.add(frontLeg);

            const backLeg = createChibiMesh(chibiSphere(0.065), primaryColor);
            backLeg.position.set(side * 0.1, 0.055, -0.06);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== CHIBI CAT =====
        function createCatChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Tiny body
          const body = createChibiMesh(chibiSphere(0.22), primaryColor);
          body.scale.set(0.95, 0.85, 1.05);
          body.position.y = 0.22;
          animal.add(body);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.48), primaryColor);
          head.position.y = 0.72;
          animal.add(head);

          // Muzzle
          const muzzle = createChibiMesh(chibiSphere(0.1), secondaryColor);
          muzzle.scale.set(1.0, 0.6, 0.7);
          muzzle.position.set(0, 0.62, 0.42);
          animal.add(muzzle);

          // Nose
          const nose = createChibiMesh(chibiSphere(0.025), 0xffb6c1);
          nose.position.set(0, 0.66, 0.46);
          animal.add(nose);

          // Triangle ears
          [-1, 1].forEach((side) => {
            const ear = createChibiMesh(
              new THREE.ConeGeometry(0.1, 0.2, 12),
              primaryColor
            );
            ear.position.set(side * 0.3, 1.1, -0.08);
            ear.rotation.z = side * -0.15;
            animal.add(ear);
          });

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.06), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.35, 0.6, 0.3);
            animal.add(cheek);
          });

          // Cat eyes (green with vertical pupils)
          [-1, 1].forEach((side) => {
            const eyeWhite = createChibiMesh(chibiSphere(0.12), 0xffffff);
            eyeWhite.scale.set(1.1, 1.15, 0.7);
            eyeWhite.position.set(side * 0.18, 0.76, 0.38);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              chibiSphere(0.08),
              new THREE.MeshBasicMaterial({ color: 0x7cfc00 })
            );
            iris.position.set(side * 0.18, 0.76, 0.44);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, 0.08, 0.01),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.18, 0.76, 0.48);
            animal.add(pupil);

            // Sparkle
            const spark = new THREE.Mesh(
              chibiSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            spark.position.set(side * 0.15, 0.8, 0.46);
            animal.add(spark);
          });

          // Curvy tail
          const tail = createChibiMesh(
            new THREE.CapsuleGeometry(0.04, 0.3, 12, 16),
            primaryColor
          );
          tail.rotation.x = 1.2;
          tail.rotation.z = 0.3;
          tail.position.set(0, 0.28, -0.25);
          animal.add(tail);

          // Tiny legs (front and back)
          [-1, 1].forEach((side) => {
            const frontLeg = createChibiMesh(chibiSphere(0.055), primaryColor);
            frontLeg.position.set(side * 0.1, 0.045, 0.05);
            animal.add(frontLeg);

            const backLeg = createChibiMesh(chibiSphere(0.055), primaryColor);
            backLeg.position.set(side * 0.09, 0.045, -0.06);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== CHIBI OWL =====
        function createOwlChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small round body
          const body = createChibiMesh(chibiSphere(0.28), primaryColor);
          body.scale.set(1.0, 0.95, 0.9);
          body.position.y = 0.28;
          animal.add(body);

          // Chest
          const chest = createChibiMesh(chibiSphere(0.2), secondaryColor);
          chest.scale.set(0.85, 0.9, 0.5);
          chest.position.set(0, 0.26, 0.12);
          animal.add(chest);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.55), primaryColor);
          head.position.y = 0.85;
          animal.add(head);

          // Facial disc
          const disc = createChibiMesh(chibiSphere(0.42), secondaryColor);
          disc.scale.set(1, 1, 0.4);
          disc.position.set(0, 0.82, 0.32);
          animal.add(disc);

          // SUPER big eyes (owls have the biggest!)
          [-1, 1].forEach((side) => {
            const eyeWhite = createChibiMesh(chibiSphere(0.18), 0xffffff);
            eyeWhite.scale.set(1.0, 1.1, 0.7);
            eyeWhite.position.set(side * 0.2, 0.88, 0.42);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              chibiSphere(0.12),
              new THREE.MeshBasicMaterial({ color: 0xffa500 })
            );
            iris.position.set(side * 0.2, 0.88, 0.5);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              chibiSphere(0.06),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 0.88, 0.56);
            animal.add(pupil);

            // Double sparkles
            const spark1 = new THREE.Mesh(
              chibiSphere(0.04),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            spark1.position.set(side * 0.16, 0.94, 0.55);
            animal.add(spark1);

            const spark2 = new THREE.Mesh(
              chibiSphere(0.025),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            spark2.position.set(side * 0.24, 0.85, 0.54);
            animal.add(spark2);
          });

          // Tiny beak
          const beak = createChibiMesh(
            new THREE.ConeGeometry(0.04, 0.08, 10),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.4;
          beak.position.set(0, 0.75, 0.48);
          animal.add(beak);

          // Ear tufts
          [-1, 1].forEach((side) => {
            const tuft = createChibiMesh(
              new THREE.ConeGeometry(0.08, 0.18, 10),
              primaryColor
            );
            tuft.position.set(side * 0.35, 1.28, -0.08);
            tuft.rotation.z = side * -0.3;
            animal.add(tuft);
          });

          // Tiny wings
          [-1, 1].forEach((side) => {
            const wing = createChibiMesh(chibiSphere(0.12), primaryColor);
            wing.scale.set(0.5, 0.9, 0.7);
            wing.position.set(side * 0.32, 0.28, -0.02);
            animal.add(wing);
          });

          // Tiny feet
          [-1, 1].forEach((side) => {
            const foot = createChibiMesh(chibiSphere(0.04), accentColor);
            foot.scale.set(1.2, 0.5, 1.4);
            foot.position.set(side * 0.08, 0.03, 0.04);
            animal.add(foot);
          });

          return animal;
        }

        // ===== CHIBI PANDA =====
        function createPandaChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small round body
          const body = createChibiMesh(chibiSphere(0.32), primaryColor);
          body.position.y = 0.32;
          animal.add(body);
          animal.userData.animationData.body = body;

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.55), primaryColor);
          head.position.y = 0.9;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Large eye patches
          [-1, 1].forEach((side) => {
            const patch = createChibiMesh(chibiSphere(0.18), secondaryColor);
            patch.scale.set(1.2, 1.0, 0.5);
            patch.position.set(side * 0.22, 0.95, 0.38);
            animal.add(patch);
          });

          // Big eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.95, 0.45));

          // Round ears
          [-1, 1].forEach((side) => {
            const ear = createChibiMesh(chibiSphere(0.15), secondaryColor);
            ear.position.set(side * 0.38, 1.32, 0);
            animal.add(ear);
          });

          // Nose
          const nose = createChibiMesh(chibiSphere(0.05), secondaryColor);
          nose.position.set(0, 0.8, 0.52);
          animal.add(nose);

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.06), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.4, 0.78, 0.35);
            animal.add(cheek);
          });

          // Tiny arms
          [-1, 1].forEach((side) => {
            const arm = createChibiMesh(chibiSphere(0.1), secondaryColor);
            arm.scale.set(0.9, 1.1, 0.9);
            arm.position.set(side * 0.32, 0.32, 0.08);
            animal.add(arm);
          });

          // Tiny legs
          [-1, 1].forEach((side) => {
            const leg = createChibiMesh(chibiSphere(0.09), secondaryColor);
            leg.position.set(side * 0.14, 0.07, 0);
            animal.add(leg);
          });

          return animal;
        }

        // ===== CHIBI DUCK =====
        function createDuckChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small round body
          const body = createChibiMesh(chibiSphere(0.28), primaryColor);
          body.scale.set(1.0, 0.85, 1.1);
          body.position.y = 0.28;
          animal.add(body);
          animal.userData.animationData.body = body;

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.48), primaryColor);
          head.position.y = 0.78;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Bill
          const bill = createChibiMesh(chibiSphere(0.12), accentColor);
          bill.scale.set(1.0, 0.5, 1.3);
          bill.position.set(0, 0.68, 0.45);
          animal.add(bill);

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.06), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.35, 0.68, 0.32);
            animal.add(cheek);
          });

          // Big eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.82, 0.38));

          // Tiny wings
          [-1, 1].forEach((side) => {
            const wing = createChibiMesh(chibiSphere(0.12), primaryColor);
            wing.scale.set(0.5, 0.85, 0.9);
            wing.position.set(side * 0.28, 0.28, -0.02);
            animal.add(wing);
          });

          // Little tail
          const tail = createChibiMesh(
            new THREE.ConeGeometry(0.06, 0.1, 10),
            primaryColor
          );
          tail.rotation.x = Math.PI / 2 + 0.4;
          tail.position.set(0, 0.32, -0.28);
          animal.add(tail);

          // Tiny feet
          [-1, 1].forEach((side) => {
            const foot = createChibiMesh(chibiSphere(0.06), accentColor);
            foot.scale.set(1.2, 0.35, 1.3);
            foot.position.set(side * 0.1, 0.03, 0.04);
            animal.add(foot);
          });

          return animal;
        }

        // ===== CHIBI FROG =====
        function createFrogChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small squat body
          const body = createChibiMesh(chibiSphere(0.28), primaryColor);
          body.scale.set(1.15, 0.7, 1.0);
          body.position.y = 0.2;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createChibiMesh(chibiSphere(0.22), secondaryColor);
          belly.scale.set(1.0, 0.6, 0.5);
          belly.position.set(0, 0.18, 0.1);
          animal.add(belly);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.5), primaryColor);
          head.scale.set(1.15, 0.9, 1.0);
          head.position.y = 0.58;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Big bulging eyes on top
          [-1, 1].forEach((side) => {
            const eyeBulge = createChibiMesh(chibiSphere(0.18), primaryColor);
            eyeBulge.position.set(side * 0.25, 0.82, 0.15);
            animal.add(eyeBulge);

            const eyeWhite = createChibiMesh(chibiSphere(0.14), 0xffffff);
            eyeWhite.position.set(side * 0.25, 0.85, 0.25);
            animal.add(eyeWhite);

            const iris = new THREE.Mesh(
              chibiSphere(0.09),
              new THREE.MeshBasicMaterial({ color: 0xffd700 })
            );
            iris.position.set(side * 0.25, 0.85, 0.32);
            animal.add(iris);

            const pupil = new THREE.Mesh(
              chibiSphere(0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.25, 0.85, 0.38);
            animal.add(pupil);

            // Sparkle
            const spark = new THREE.Mesh(
              chibiSphere(0.035),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            spark.position.set(side * 0.22, 0.9, 0.36);
            animal.add(spark);
          });

          // Smile
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.1, 0.02, 8, 16, Math.PI),
            new THREE.MeshBasicMaterial({ color: 0x333333 })
          );
          mouth.rotation.x = Math.PI;
          mouth.position.set(0, 0.45, 0.38);
          animal.add(mouth);

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.06), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.38, 0.48, 0.28);
            animal.add(cheek);
          });

          // Tiny front legs
          [-1, 1].forEach((side) => {
            const arm = createChibiMesh(chibiSphere(0.05), primaryColor);
            arm.position.set(side * 0.28, 0.1, 0.1);
            animal.add(arm);
          });

          // Tiny back legs
          [-1, 1].forEach((side) => {
            const leg = createChibiMesh(chibiSphere(0.08), primaryColor);
            leg.scale.set(0.9, 1.1, 1.0);
            leg.position.set(side * 0.28, 0.1, -0.1);
            animal.add(leg);
          });

          return animal;
        }

        // ===== CHIBI ELEPHANT =====
        function createElephantChibi(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "chibi";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Small round body
          const body = createChibiMesh(chibiSphere(0.35), primaryColor);
          body.scale.set(1.1, 0.85, 1.0);
          body.position.y = 0.35;
          animal.add(body);

          // HUGE head
          const head = createChibiMesh(chibiSphere(0.55), primaryColor);
          head.position.y = 0.92;
          animal.add(head);

          // Trunk
          const trunk = createChibiMesh(
            new THREE.CapsuleGeometry(0.08, 0.28, 12, 16),
            primaryColor
          );
          trunk.rotation.x = 0.5;
          trunk.position.set(0, 0.72, 0.48);
          animal.add(trunk);

          // Large floppy ears
          [-1, 1].forEach((side) => {
            const ear = createChibiMesh(chibiSphere(0.35), primaryColor);
            ear.scale.set(0.15, 0.9, 0.75);
            ear.position.set(side * 0.5, 0.88, -0.05);
            animal.add(ear);

            const innerEar = createChibiMesh(chibiSphere(0.24), secondaryColor);
            innerEar.scale.set(0.15, 0.7, 0.55);
            innerEar.position.set(side * 0.52, 0.88, 0);
            animal.add(innerEar);
          });

          // Big eyes
          [-1, 1].forEach((side) => createChibiEyes(animal, side, 0.95, 0.42));

          // Cheeks
          [-1, 1].forEach((side) => {
            const cheek = createChibiMesh(chibiSphere(0.06), 0xffcccc);
            cheek.scale.set(1.1, 0.7, 0.4);
            cheek.position.set(side * 0.38, 0.78, 0.35);
            animal.add(cheek);
          });

          // Tiny tusks
          [-1, 1].forEach((side) => {
            const tusk = createChibiMesh(
              new THREE.ConeGeometry(0.025, 0.12, 10),
              0xfffff0
            );
            tusk.rotation.z = side * 0.3;
            tusk.rotation.x = -0.25;
            tusk.position.set(side * 0.15, 0.68, 0.42);
            animal.add(tusk);
          });

          // Tiny legs
          const legPositions = [
            { x: -0.18, z: 0.08 },
            { x: 0.18, z: 0.08 },
            { x: -0.15, z: -0.1 },
            { x: 0.15, z: -0.1 },
          ];
          legPositions.forEach((pos) => {
            const leg = createChibiMesh(chibiSphere(0.09), primaryColor);
            leg.position.set(pos.x, 0.08, pos.z);
            animal.add(leg);
          });

          // Tiny tail
          const tail = createChibiMesh(
            new THREE.CapsuleGeometry(0.02, 0.12, 8, 10),
            primaryColor
          );
          tail.rotation.x = 0.7;
          tail.position.set(0, 0.32, -0.32);
          animal.add(tail);

          return animal;
        }

        // Register Chibi builders
        const CHIBI_BUILDERS = {
          bunny: createBunnyChibi,
          bear: createBearChibi,
          penguin: createPenguinChibi,
          fox: createFoxChibi,
          cat: createCatChibi,
          owl: createOwlChibi,
          panda: createPandaChibi,
          duck: createDuckChibi,
          frog: createFrogChibi,
          elephant: createElephantChibi,
        };

        // Register the Chibi style
        MODEL_STYLE_BUILDERS.chibi = CHIBI_BUILDERS;
        console.log(
          "[Registration] Chibi builders registered:",
          Object.keys(CHIBI_BUILDERS).join(", ")
        );

        // ==========================================
        // VOXEL STYLE BUILDERS (Phase 7)
        // ==========================================

        // Helper: Create voxel mesh with blocky material
        function createVoxelMesh(geometry, baseColor) {
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);
          const hsl = {};
          color.getHSL(hsl);
          color.setHSL(hsl.h, hsl.s * (style ? style.saturation : 1.0), hsl.l);

          const material = new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: style ? Math.max(0.4, style.roughness) : 0.5,
            metalness: style ? style.metalness : 0.0,
            clearcoat: style ? style.clearcoat * 0.3 : 0.2,
            clearcoatRoughness: 0.5,
            flatShading: true, // Sharp edges
            side: THREE.DoubleSide,
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          return mesh;
        }

        // Helper: Voxel geometries (all boxes!)
        function voxelBox(w, h, d) {
          return new THREE.BoxGeometry(w, h, d);
        }

        // ===== VOXEL BUNNY =====
        function createBunnyVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(voxelBox(0.5, 0.6, 0.55), primaryColor);
          body.position.y = 0.35;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.6, 0.55, 0.55), primaryColor);
          head.position.y = 0.92;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Tall rectangular ears
          [-1, 1].forEach((side) => {
            const ear = createVoxelMesh(
              voxelBox(0.12, 0.55, 0.1),
              primaryColor
            );
            ear.position.set(side * 0.18, 1.45, 0);
            animal.add(ear);

            const innerEar = createVoxelMesh(
              voxelBox(0.06, 0.4, 0.05),
              secondaryColor
            );
            innerEar.position.set(side * 0.18, 1.42, 0.03);
            animal.add(innerEar);
          });

          // Square eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.12, 0.12, 0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.15, 0.95, 0.28);
            animal.add(eye);
          });

          // Square nose
          const nose = createVoxelMesh(voxelBox(0.1, 0.08, 0.06), 0xffb6c1);
          nose.position.set(0, 0.82, 0.28);
          animal.add(nose);

          // Blocky tail
          const tail = createVoxelMesh(
            voxelBox(0.15, 0.15, 0.12),
            primaryColor
          );
          tail.position.set(0, 0.28, -0.32);
          animal.add(tail);

          // Blocky feet
          [-1, 1].forEach((side) => {
            const foot = createVoxelMesh(
              voxelBox(0.15, 0.12, 0.18),
              primaryColor
            );
            foot.position.set(side * 0.15, 0.06, 0.05);
            animal.add(foot);
          });

          return animal;
        }

        // ===== VOXEL BEAR =====
        function createBearVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Big blocky body
          const body = createVoxelMesh(voxelBox(0.75, 0.7, 0.65), primaryColor);
          body.position.y = 0.4;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly patch
          const belly = createVoxelMesh(
            voxelBox(0.5, 0.45, 0.1),
            secondaryColor
          );
          belly.position.set(0, 0.35, 0.33);
          animal.add(belly);

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.65, 0.6, 0.58), primaryColor);
          head.position.y = 1.05;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Muzzle
          const muzzle = createVoxelMesh(
            voxelBox(0.3, 0.22, 0.2),
            secondaryColor
          );
          muzzle.position.set(0, 0.92, 0.35);
          animal.add(muzzle);

          // Nose
          const nose = createVoxelMesh(voxelBox(0.12, 0.1, 0.08), accentColor);
          nose.position.set(0, 0.98, 0.42);
          animal.add(nose);

          // Square ears
          [-1, 1].forEach((side) => {
            const ear = createVoxelMesh(
              voxelBox(0.18, 0.18, 0.12),
              primaryColor
            );
            ear.position.set(side * 0.28, 1.42, 0);
            animal.add(ear);
          });

          // Square eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.1, 0.1, 0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.18, 1.1, 0.3);
            animal.add(eye);
          });

          // Blocky legs
          const legPositions = [
            { x: -0.25, z: 0.15 },
            { x: 0.25, z: 0.15 },
            { x: -0.22, z: -0.18 },
            { x: 0.22, z: -0.18 },
          ];
          legPositions.forEach((pos) => {
            const leg = createVoxelMesh(
              voxelBox(0.18, 0.28, 0.18),
              primaryColor
            );
            leg.position.set(pos.x, 0.14, pos.z);
            animal.add(leg);
          });

          return animal;
        }

        // ===== VOXEL PENGUIN =====
        function createPenguinVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(voxelBox(0.55, 0.7, 0.5), primaryColor);
          body.position.y = 0.4;
          animal.add(body);
          animal.userData.animationData.body = body;

          // White belly
          const belly = createVoxelMesh(
            voxelBox(0.4, 0.5, 0.1),
            secondaryColor
          );
          belly.position.set(0, 0.38, 0.26);
          animal.add(belly);

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.5, 0.45, 0.45), primaryColor);
          head.position.y = 0.97;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Face
          const face = createVoxelMesh(
            voxelBox(0.35, 0.3, 0.1),
            secondaryColor
          );
          face.position.set(0, 0.95, 0.23);
          animal.add(face);

          // Square eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.08, 0.08, 0.05),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.1, 0.98, 0.26);
            animal.add(eye);
          });

          // Triangular beak (as a rotated box)
          const beak = createVoxelMesh(voxelBox(0.12, 0.08, 0.18), accentColor);
          beak.position.set(0, 0.88, 0.32);
          animal.add(beak);

          // Blocky flippers
          [-1, 1].forEach((side) => {
            const flipper = createVoxelMesh(
              voxelBox(0.12, 0.35, 0.15),
              primaryColor
            );
            flipper.rotation.z = side * 0.3;
            flipper.position.set(side * 0.35, 0.4, 0);
            animal.add(flipper);
          });

          // Blocky feet
          [-1, 1].forEach((side) => {
            const foot = createVoxelMesh(
              voxelBox(0.15, 0.08, 0.2),
              accentColor
            );
            foot.position.set(side * 0.12, 0.04, 0.05);
            animal.add(foot);
          });

          return animal;
        }

        // ===== VOXEL FOX =====
        function createFoxVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(
            voxelBox(0.46, 0.42, 0.62),
            primaryColor
          );
          body.position.y = 0.34;
          animal.add(body);

          // White blocky chest
          const chest = createVoxelMesh(
            voxelBox(0.32, 0.3, 0.12),
            secondaryColor
          );
          chest.position.set(0, 0.36, 0.34);
          animal.add(chest);

          // Blocky head
          const head = createVoxelMesh(
            voxelBox(0.52, 0.44, 0.47),
            primaryColor
          );
          head.position.y = 0.78;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Snout
          const snout = createVoxelMesh(
            voxelBox(0.22, 0.16, 0.28),
            secondaryColor
          );
          snout.position.set(0, 0.7, 0.35);
          animal.add(snout);

          // Nose (pixel block)
          const nose = createVoxelMesh(voxelBox(0.1, 0.07, 0.07), accentColor);
          nose.position.set(0, 0.72, 0.48);
          animal.add(nose);

          // Pointy ears with BLACK TIPS
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createVoxelMesh(
              voxelBox(0.15, 0.28, 0.11),
              primaryColor
            );
            earGroup.add(ear);

            // Black tip
            const tip = createVoxelMesh(voxelBox(0.1, 0.1, 0.08), 0x1a1a1a);
            tip.position.y = 0.15;
            earGroup.add(tip);

            earGroup.position.set(side * 0.2, 1.12, -0.04);
            animal.add(earGroup);
          });

          // Pixel eyes with highlight
          [-1, 1].forEach((side) => {
            const eyeBg = new THREE.Mesh(
              voxelBox(0.1, 0.1, 0.05),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            eyeBg.position.set(side * 0.13, 0.8, 0.24);
            animal.add(eyeBg);

            const eye = new THREE.Mesh(
              voxelBox(0.08, 0.08, 0.04),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.13, 0.8, 0.26);
            animal.add(eye);

            // Pixel highlight
            const highlight = new THREE.Mesh(
              voxelBox(0.03, 0.03, 0.02),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            highlight.position.set(side * 0.11, 0.82, 0.27);
            animal.add(highlight);
          });

          // Pixel cheek blush
          [-1, 1].forEach((side) => {
            const blush = createVoxelMesh(voxelBox(0.08, 0.05, 0.03), 0xffcccc);
            blush.position.set(side * 0.22, 0.72, 0.24);
            animal.add(blush);
          });

          // Segmented blocky tail
          const tailGroup = new THREE.Group();
          for (let s = 0; s < 3; s++) {
            const tailSeg = createVoxelMesh(
              voxelBox(0.18 - s * 0.03, 0.18 - s * 0.03, 0.16),
              primaryColor
            );
            tailSeg.position.z = -s * 0.15;
            tailGroup.add(tailSeg);
          }
          const tailTip = createVoxelMesh(
            voxelBox(0.14, 0.14, 0.14),
            secondaryColor
          );
          tailTip.position.z = -0.48;
          tailGroup.add(tailTip);

          tailGroup.rotation.x = 0.35;
          tailGroup.position.set(0, 0.38, -0.4);
          animal.add(tailGroup);

          // Blocky legs
          [-1, 1].forEach((side) => {
            const frontLeg = createVoxelMesh(
              voxelBox(0.13, 0.22, 0.13),
              primaryColor
            );
            frontLeg.position.set(side * 0.15, 0.11, 0.14);
            animal.add(frontLeg);

            const backLeg = createVoxelMesh(
              voxelBox(0.13, 0.22, 0.13),
              primaryColor
            );
            backLeg.position.set(side * 0.14, 0.11, -0.14);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== VOXEL CAT =====
        function createCatVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(voxelBox(0.4, 0.35, 0.55), primaryColor);
          body.position.y = 0.28;
          animal.add(body);

          // Blocky head
          const head = createVoxelMesh(
            voxelBox(0.48, 0.42, 0.42),
            primaryColor
          );
          head.position.y = 0.68;
          animal.add(head);

          // Muzzle
          const muzzle = createVoxelMesh(
            voxelBox(0.18, 0.12, 0.12),
            secondaryColor
          );
          muzzle.position.set(0, 0.58, 0.22);
          animal.add(muzzle);

          // Nose
          const nose = createVoxelMesh(voxelBox(0.06, 0.05, 0.04), 0xffb6c1);
          nose.position.set(0, 0.62, 0.26);
          animal.add(nose);

          // Pointy ears
          [-1, 1].forEach((side) => {
            const ear = createVoxelMesh(
              voxelBox(0.12, 0.18, 0.08),
              primaryColor
            );
            ear.position.set(side * 0.16, 0.98, -0.02);
            animal.add(ear);
          });

          // Cat eyes (green squares)
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.1, 0.1, 0.05),
              new THREE.MeshBasicMaterial({ color: 0x7cfc00 })
            );
            eye.position.set(side * 0.12, 0.72, 0.22);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              voxelBox(0.03, 0.08, 0.02),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.12, 0.72, 0.24);
            animal.add(pupil);
          });

          // Blocky tail (segmented)
          const tail1 = createVoxelMesh(
            voxelBox(0.08, 0.08, 0.2),
            primaryColor
          );
          tail1.position.set(0, 0.28, -0.35);
          animal.add(tail1);

          const tail2 = createVoxelMesh(
            voxelBox(0.08, 0.2, 0.08),
            primaryColor
          );
          tail2.position.set(0, 0.38, -0.42);
          animal.add(tail2);

          // Blocky legs (front and back)
          [-1, 1].forEach((side) => {
            const frontLeg = createVoxelMesh(
              voxelBox(0.1, 0.18, 0.1),
              primaryColor
            );
            frontLeg.position.set(side * 0.12, 0.09, 0.1);
            animal.add(frontLeg);

            const backLeg = createVoxelMesh(
              voxelBox(0.1, 0.18, 0.1),
              primaryColor
            );
            backLeg.position.set(side * 0.11, 0.09, -0.12);
            animal.add(backLeg);
          });

          return animal;
        }

        // ===== VOXEL OWL =====
        function createOwlVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(voxelBox(0.5, 0.55, 0.45), primaryColor);
          body.position.y = 0.32;
          animal.add(body);

          // Chest
          const chest = createVoxelMesh(
            voxelBox(0.35, 0.4, 0.1),
            secondaryColor
          );
          chest.position.set(0, 0.3, 0.23);
          animal.add(chest);

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.55, 0.5, 0.48), primaryColor);
          head.position.y = 0.82;
          animal.add(head);

          // Facial disc
          const disc = createVoxelMesh(
            voxelBox(0.42, 0.38, 0.1),
            secondaryColor
          );
          disc.position.set(0, 0.8, 0.25);
          animal.add(disc);

          // Big square eyes
          [-1, 1].forEach((side) => {
            const eyeBg = createVoxelMesh(voxelBox(0.14, 0.14, 0.05), 0xffffff);
            eyeBg.position.set(side * 0.12, 0.85, 0.28);
            animal.add(eyeBg);

            const eye = new THREE.Mesh(
              voxelBox(0.1, 0.1, 0.03),
              new THREE.MeshBasicMaterial({ color: 0xffa500 })
            );
            eye.position.set(side * 0.12, 0.85, 0.3);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              voxelBox(0.05, 0.05, 0.02),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.12, 0.85, 0.32);
            animal.add(pupil);
          });

          // Beak
          const beak = createVoxelMesh(voxelBox(0.08, 0.1, 0.1), accentColor);
          beak.position.set(0, 0.72, 0.3);
          animal.add(beak);

          // Ear tufts
          [-1, 1].forEach((side) => {
            const tuft = createVoxelMesh(
              voxelBox(0.1, 0.15, 0.08),
              primaryColor
            );
            tuft.position.set(side * 0.22, 1.12, -0.02);
            animal.add(tuft);
          });

          // Blocky wings
          [-1, 1].forEach((side) => {
            const wing = createVoxelMesh(
              voxelBox(0.12, 0.35, 0.2),
              primaryColor
            );
            wing.position.set(side * 0.32, 0.32, -0.02);
            animal.add(wing);
          });

          // Blocky feet
          [-1, 1].forEach((side) => {
            const foot = createVoxelMesh(
              voxelBox(0.1, 0.06, 0.12),
              accentColor
            );
            foot.position.set(side * 0.1, 0.03, 0.04);
            animal.add(foot);
          });

          return animal;
        }

        // ===== VOXEL PANDA =====
        function createPandaVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body (white)
          const body = createVoxelMesh(voxelBox(0.6, 0.6, 0.55), primaryColor);
          body.position.y = 0.35;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Blocky head (white)
          const head = createVoxelMesh(voxelBox(0.6, 0.55, 0.52), primaryColor);
          head.position.y = 0.92;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Eye patches (black)
          [-1, 1].forEach((side) => {
            const patch = createVoxelMesh(
              voxelBox(0.18, 0.18, 0.1),
              secondaryColor
            );
            patch.position.set(side * 0.15, 0.95, 0.27);
            animal.add(patch);

            const eye = new THREE.Mesh(
              voxelBox(0.08, 0.08, 0.05),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            eye.position.set(side * 0.15, 0.95, 0.32);
            animal.add(eye);
          });

          // Ears (black)
          [-1, 1].forEach((side) => {
            const ear = createVoxelMesh(
              voxelBox(0.16, 0.16, 0.12),
              secondaryColor
            );
            ear.position.set(side * 0.26, 1.25, 0);
            animal.add(ear);
          });

          // Nose
          const nose = createVoxelMesh(
            voxelBox(0.1, 0.08, 0.08),
            secondaryColor
          );
          nose.position.set(0, 0.85, 0.28);
          animal.add(nose);

          // Arms (black)
          [-1, 1].forEach((side) => {
            const arm = createVoxelMesh(
              voxelBox(0.16, 0.28, 0.16),
              secondaryColor
            );
            arm.position.set(side * 0.38, 0.35, 0.05);
            animal.add(arm);
          });

          // Legs (black)
          [-1, 1].forEach((side) => {
            const leg = createVoxelMesh(
              voxelBox(0.18, 0.22, 0.18),
              secondaryColor
            );
            leg.position.set(side * 0.18, 0.11, 0);
            animal.add(leg);
          });

          return animal;
        }

        // ===== VOXEL DUCK =====
        function createDuckVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Blocky body
          const body = createVoxelMesh(voxelBox(0.45, 0.4, 0.55), primaryColor);
          body.position.y = 0.28;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.4, 0.38, 0.38), primaryColor);
          head.position.y = 0.68;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Flat bill
          const bill = createVoxelMesh(voxelBox(0.22, 0.1, 0.25), accentColor);
          bill.position.set(0, 0.62, 0.28);
          animal.add(bill);

          // Square eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.07, 0.07, 0.04),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            eye.position.set(side * 0.1, 0.72, 0.2);
            animal.add(eye);
          });

          // Blocky wings
          [-1, 1].forEach((side) => {
            const wing = createVoxelMesh(
              voxelBox(0.1, 0.25, 0.22),
              primaryColor
            );
            wing.position.set(side * 0.28, 0.28, -0.02);
            animal.add(wing);
          });

          // Tail
          const tail = createVoxelMesh(
            voxelBox(0.12, 0.12, 0.15),
            primaryColor
          );
          tail.rotation.x = 0.4;
          tail.position.set(0, 0.35, -0.32);
          animal.add(tail);

          // Blocky feet
          [-1, 1].forEach((side) => {
            const foot = createVoxelMesh(
              voxelBox(0.14, 0.06, 0.18),
              accentColor
            );
            foot.position.set(side * 0.1, 0.03, 0.04);
            animal.add(foot);
          });

          return animal;
        }

        // ===== VOXEL FROG =====
        function createFrogVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Wide blocky body
          const body = createVoxelMesh(voxelBox(0.6, 0.35, 0.5), primaryColor);
          body.position.y = 0.22;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createVoxelMesh(
            voxelBox(0.45, 0.25, 0.1),
            secondaryColor
          );
          belly.position.set(0, 0.2, 0.26);
          animal.add(belly);

          // Wide blocky head
          const head = createVoxelMesh(voxelBox(0.55, 0.3, 0.45), primaryColor);
          head.position.y = 0.48;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Bulging eyes on top
          [-1, 1].forEach((side) => {
            const eyeBase = createVoxelMesh(
              voxelBox(0.18, 0.15, 0.15),
              primaryColor
            );
            eyeBase.position.set(side * 0.2, 0.68, 0.1);
            animal.add(eyeBase);

            const eyeWhite = createVoxelMesh(
              voxelBox(0.14, 0.12, 0.08),
              0xffffff
            );
            eyeWhite.position.set(side * 0.2, 0.7, 0.15);
            animal.add(eyeWhite);

            const eye = new THREE.Mesh(
              voxelBox(0.08, 0.08, 0.04),
              new THREE.MeshBasicMaterial({ color: 0xffd700 })
            );
            eye.position.set(side * 0.2, 0.7, 0.18);
            animal.add(eye);

            const pupil = new THREE.Mesh(
              voxelBox(0.04, 0.06, 0.02),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.set(side * 0.2, 0.7, 0.2);
            animal.add(pupil);
          });

          // Front legs
          [-1, 1].forEach((side) => {
            const arm = createVoxelMesh(
              voxelBox(0.12, 0.08, 0.15),
              primaryColor
            );
            arm.position.set(side * 0.32, 0.08, 0.15);
            animal.add(arm);
          });

          // Back legs (bent)
          [-1, 1].forEach((side) => {
            const thigh = createVoxelMesh(
              voxelBox(0.15, 0.2, 0.15),
              primaryColor
            );
            thigh.position.set(side * 0.3, 0.15, -0.12);
            animal.add(thigh);

            const calf = createVoxelMesh(
              voxelBox(0.12, 0.08, 0.2),
              primaryColor
            );
            calf.position.set(side * 0.35, 0.06, -0.22);
            animal.add(calf);
          });

          return animal;
        }

        // ===== VOXEL ELEPHANT =====
        function createElephantVoxel(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "voxel";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Big blocky body
          const body = createVoxelMesh(voxelBox(0.7, 0.55, 0.6), primaryColor);
          body.position.y = 0.48;
          animal.add(body);

          // Blocky head
          const head = createVoxelMesh(voxelBox(0.55, 0.5, 0.48), primaryColor);
          head.position.y = 1.0;
          animal.add(head);

          // Trunk (segmented boxes)
          const trunk1 = createVoxelMesh(
            voxelBox(0.18, 0.18, 0.2),
            primaryColor
          );
          trunk1.position.set(0, 0.85, 0.32);
          animal.add(trunk1);

          const trunk2 = createVoxelMesh(
            voxelBox(0.15, 0.15, 0.18),
            primaryColor
          );
          trunk2.position.set(0, 0.7, 0.42);
          animal.add(trunk2);

          const trunk3 = createVoxelMesh(
            voxelBox(0.12, 0.12, 0.15),
            primaryColor
          );
          trunk3.position.set(0, 0.58, 0.48);
          animal.add(trunk3);

          // Large flat ears
          [-1, 1].forEach((side) => {
            const ear = createVoxelMesh(
              voxelBox(0.1, 0.45, 0.35),
              primaryColor
            );
            ear.position.set(side * 0.38, 0.95, -0.02);
            animal.add(ear);

            const innerEar = createVoxelMesh(
              voxelBox(0.05, 0.35, 0.25),
              secondaryColor
            );
            innerEar.position.set(side * 0.4, 0.95, 0);
            animal.add(innerEar);
          });

          // Square eyes
          [-1, 1].forEach((side) => {
            const eye = new THREE.Mesh(
              voxelBox(0.08, 0.08, 0.04),
              new THREE.MeshBasicMaterial({ color: 0x4a3020 })
            );
            eye.position.set(side * 0.15, 1.05, 0.25);
            animal.add(eye);
          });

          // Tusks (rectangular)
          [-1, 1].forEach((side) => {
            const tusk = createVoxelMesh(voxelBox(0.06, 0.2, 0.06), 0xfffff0);
            tusk.position.set(side * 0.15, 0.72, 0.28);
            animal.add(tusk);
          });

          // Chunky legs
          const legPositions = [
            { x: -0.25, z: 0.15 },
            { x: 0.25, z: 0.15 },
            { x: -0.22, z: -0.18 },
            { x: 0.22, z: -0.18 },
          ];
          legPositions.forEach((pos) => {
            const leg = createVoxelMesh(
              voxelBox(0.18, 0.4, 0.18),
              primaryColor
            );
            leg.position.set(pos.x, 0.2, pos.z);
            animal.add(leg);
          });

          // Tail (small box)
          const tail = createVoxelMesh(
            voxelBox(0.06, 0.25, 0.06),
            primaryColor
          );
          tail.rotation.x = 0.4;
          tail.position.set(0, 0.42, -0.35);
          animal.add(tail);

          return animal;
        }

        // Register Voxel builders
        const VOXEL_BUILDERS = {
          bunny: createBunnyVoxel,
          bear: createBearVoxel,
          penguin: createPenguinVoxel,
          fox: createFoxVoxel,
          cat: createCatVoxel,
          owl: createOwlVoxel,
          panda: createPandaVoxel,
          duck: createDuckVoxel,
          frog: createFrogVoxel,
          elephant: createElephantVoxel,
        };

        // Register the Voxel style
        MODEL_STYLE_BUILDERS.voxel = VOXEL_BUILDERS;
        console.log(
          "[Registration] Voxel builders registered:",
          Object.keys(VOXEL_BUILDERS).join(", ")
        );

        // ==========================================
        // ANIME STYLE BUILDERS (Phase 1-6)
        // ==========================================

        const ANIME_SEGMENTS = 48; // Ultra-smooth for anime quality

        // ===== ANIME MATERIAL SYSTEM =====

        // Helper: Create soft anime material
        function createAnimeMaterial(baseColor, options = {}) {
          const style = ART_STYLES[currentArtStyle];
          const color = new THREE.Color(baseColor);
          const hsl = {};
          color.getHSL(hsl);
          // Slightly warmer, softer colors for anime
          color.setHSL(
            hsl.h + 0.01,
            hsl.s * 0.95 * (style ? style.saturation : 1.0),
            hsl.l
          );

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness || 0.45,
            metalness: 0.0,
            clearcoat: options.clearcoat || 0.15,
            clearcoatRoughness: 0.6,
            sheen: 0.5,
            sheenRoughness: 0.6,
            sheenColor: color.clone().offsetHSL(0.02, -0.1, 0.15),
            envMapIntensity: 0.4,
            side: THREE.DoubleSide,
            ...options.materialProps,
          });
        }

        // Helper: Create anime mesh with optional rim light
        function createAnimeMesh(geometry, baseColor, options = {}) {
          const mesh = new THREE.Mesh(
            geometry,
            createAnimeMaterial(baseColor, options)
          );
          mesh.castShadow = true;
          return mesh;
        }

        // Helper: Anime geometries
        function animeSphere(radius) {
          return new THREE.SphereGeometry(
            radius,
            ANIME_SEGMENTS,
            ANIME_SEGMENTS
          );
        }

        function animeCylinder(rTop, rBot, height) {
          return new THREE.CylinderGeometry(rTop, rBot, height, 32);
        }

        // ===== ANIME EYE SYSTEM =====

        // Create detailed multi-layered anime eye
        function createAnimeEye(params = {}) {
          const eyeGroup = new THREE.Group();

          const {
            size = 0.12,
            irisColor = 0x6b4423,
            irisColorInner = 0x8b6914,
            position = { x: 0, y: 0, z: 0 },
            scale = { x: 1, y: 1.15, z: 0.7 },
            pupilSize = 0.4,
            highlightIntensity = 1.0,
          } = params;

          // Layer 1: Sclera (white of eye) - slightly oval
          const sclera = new THREE.Mesh(
            animeSphere(size),
            new THREE.MeshPhysicalMaterial({
              color: 0xffffff,
              roughness: 0.2,
              metalness: 0.0,
              clearcoat: 0.8,
            })
          );
          sclera.scale.set(scale.x, scale.y, scale.z);
          eyeGroup.add(sclera);

          // Layer 2: Outer iris ring (darker shade)
          const outerIris = new THREE.Mesh(
            animeSphere(size * 0.75),
            new THREE.MeshBasicMaterial({ color: irisColor })
          );
          outerIris.scale.set(scale.x * 0.95, scale.y * 0.9, 0.3);
          outerIris.position.z = size * scale.z * 0.4;
          eyeGroup.add(outerIris);

          // Layer 3: Inner iris (vibrant gradient effect)
          const innerIris = new THREE.Mesh(
            animeSphere(size * 0.55),
            new THREE.MeshBasicMaterial({ color: irisColorInner })
          );
          innerIris.scale.set(scale.x * 0.9, scale.y * 0.85, 0.25);
          innerIris.position.z = size * scale.z * 0.5;
          eyeGroup.add(innerIris);

          // Layer 4: Pupil (large, expressive)
          const pupil = new THREE.Mesh(
            animeSphere(size * pupilSize),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
          );
          pupil.scale.set(scale.x * 0.85, scale.y * 0.85, 0.2);
          pupil.position.z = size * scale.z * 0.55;
          eyeGroup.add(pupil);

          // Layer 5: Primary highlight (top-left, large oval)
          const highlight1 = new THREE.Mesh(
            animeSphere(size * 0.32 * highlightIntensity),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
          );
          highlight1.scale.set(1.2, 1.4, 0.3);
          highlight1.position.set(
            -size * 0.2,
            size * 0.25,
            size * scale.z * 0.65
          );
          eyeGroup.add(highlight1);

          // Layer 6: Secondary highlight (bottom-right, small)
          const highlight2 = new THREE.Mesh(
            animeSphere(size * 0.15 * highlightIntensity),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
          );
          highlight2.position.set(
            size * 0.15,
            -size * 0.18,
            size * scale.z * 0.6
          );
          eyeGroup.add(highlight2);

          // Layer 7: Sparkle accents (tiny dots)
          const sparklePositions = [
            { x: -size * 0.08, y: size * 0.35, z: size * scale.z * 0.62 },
            { x: size * 0.22, y: size * 0.08, z: size * scale.z * 0.58 },
          ];
          sparklePositions.forEach((pos) => {
            const sparkle = new THREE.Mesh(
              animeSphere(size * 0.06),
              new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            sparkle.position.set(pos.x, pos.y, pos.z);
            eyeGroup.add(sparkle);
          });

          eyeGroup.position.set(position.x, position.y, position.z);
          return eyeGroup;
        }

        // ===== ANIME DETAIL HELPERS =====

        // Create whisker
        function createWhisker(length, thickness = 0.005) {
          const whiskerGeo = new THREE.CylinderGeometry(
            thickness,
            thickness * 0.3,
            length,
            8
          );
          const whiskerMat = new THREE.MeshBasicMaterial({
            color: 0x3a3a3a,
            transparent: true,
            opacity: 0.6,
          });
          const whisker = new THREE.Mesh(whiskerGeo, whiskerMat);
          whisker.rotation.z = Math.PI / 2;
          return whisker;
        }

        // Create fur tuft
        function createFurTuft(size, color) {
          const tuftGroup = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const strand = createAnimeMesh(
              new THREE.ConeGeometry(size * 0.3, size, 8),
              color
            );
            strand.position.set(
              (Math.random() - 0.5) * size * 0.5,
              size * 0.4,
              (Math.random() - 0.5) * size * 0.3
            );
            strand.rotation.set(
              (Math.random() - 0.5) * 0.3,
              Math.random() * Math.PI * 2,
              (Math.random() - 0.5) * 0.2
            );
            tuftGroup.add(strand);
          }
          return tuftGroup;
        }

        // Create blush marks
        function createBlush(size) {
          const blush = new THREE.Mesh(
            animeSphere(size),
            new THREE.MeshBasicMaterial({
              color: 0xffaaaa,
              transparent: true,
              opacity: 0.35,
            })
          );
          blush.scale.set(1.5, 0.6, 0.3);
          return blush;
        }

        // Create paw pad
        function createPawPad(size, color = 0xffb6c1) {
          const pad = new THREE.Mesh(
            animeSphere(size),
            new THREE.MeshPhysicalMaterial({
              color: color,
              roughness: 0.7,
              metalness: 0.0,
            })
          );
          pad.scale.set(1.0, 1.0, 0.4);
          return pad;
        }

        // ===== ANIME BUNNY =====
        function createBunnyAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bunny";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bunny", colorOverride, options);
          animal.userData.variant = variantKey;

          // Elegant body
          const body = createAnimeMesh(animeSphere(0.42), primaryColor);
          body.scale.set(0.9, 1.15, 1.0);
          body.position.y = 0.5;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Soft belly
          const belly = createAnimeMesh(animeSphere(0.32), secondaryColor);
          belly.scale.set(0.85, 1.0, 0.5);
          belly.position.set(0, 0.45, 0.18);
          animal.add(belly);

          // Elegant head
          const head = createAnimeMesh(animeSphere(0.42), primaryColor);
          head.scale.set(1.1, 1.05, 1.0);
          head.position.y = 1.1;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Long, elegant drooping ears
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            // Main ear
            const ear = createAnimeMesh(
              new THREE.CapsuleGeometry(0.09, 0.65, 24, 32),
              primaryColor
            );
            ear.rotation.z = side * -0.2;
            ear.rotation.x = 0.15;
            earGroup.add(ear);

            // Inner ear (pink)
            const innerEar = createAnimeMesh(
              new THREE.CapsuleGeometry(0.05, 0.5, 16, 24),
              secondaryColor
            );
            innerEar.position.z = 0.02;
            innerEar.rotation.z = side * -0.2;
            innerEar.rotation.x = 0.15;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.22, 1.65, -0.05);
            animal.add(earGroup);
          });

          // Large anime eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.14,
              irisColor: 0x6b3a23,
              irisColorInner: 0xa05930,
              position: { x: side * 0.18, y: 1.15, z: 0.36 },
              scale: { x: 1.0, y: 1.2, z: 0.7 },
              pupilSize: 0.35,
            });
            animal.add(eye);
          });

          // Blush marks
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.08);
            blush.position.set(side * 0.32, 1.02, 0.28);
            animal.add(blush);
          });

          // Cute nose
          const nose = createAnimeMesh(animeSphere(0.045), 0xffb6c1);
          nose.scale.set(1.3, 0.9, 1.0);
          nose.position.set(0, 1.0, 0.42);
          animal.add(nose);

          // Small mouth
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.03, 0.008, 8, 12, Math.PI),
            new THREE.MeshBasicMaterial({ color: 0x4a3a3a })
          );
          mouth.rotation.x = Math.PI;
          mouth.position.set(0, 0.94, 0.4);
          animal.add(mouth);

          // Cheek fluff
          [-1, 1].forEach((side) => {
            const fluff = createFurTuft(0.06, primaryColor);
            fluff.position.set(side * 0.35, 1.05, 0.2);
            fluff.rotation.z = side * 0.3;
            animal.add(fluff);
          });

          // Fluffy cotton tail
          const tail = createAnimeMesh(animeSphere(0.14), primaryColor);
          tail.scale.set(1.1, 1.0, 0.9);
          tail.position.set(0, 0.48, -0.38);
          animal.add(tail);

          // Tail fluff detail
          const tailFluff = createFurTuft(0.05, primaryColor);
          tailFluff.position.set(0, 0.52, -0.42);
          animal.add(tailFluff);

          // Elegant front paws
          [-1, 1].forEach((side) => {
            const paw = createAnimeMesh(animeSphere(0.08), primaryColor);
            paw.scale.set(0.9, 0.7, 1.1);
            paw.position.set(side * 0.18, 0.08, 0.18);
            animal.add(paw);

            // Paw pad
            const pad = createPawPad(0.04);
            pad.position.set(side * 0.18, 0.05, 0.22);
            pad.rotation.x = -0.3;
            animal.add(pad);
          });

          // Back paws
          [-1, 1].forEach((side) => {
            const paw = createAnimeMesh(animeSphere(0.1), primaryColor);
            paw.scale.set(0.85, 0.6, 1.3);
            paw.position.set(side * 0.16, 0.06, -0.12);
            animal.add(paw);
          });

          return animal;
        }

        // ===== ANIME CAT =====
        function createCatAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "cat";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("cat", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek elegant body
          const body = createAnimeMesh(animeSphere(0.35), primaryColor);
          body.scale.set(0.9, 0.85, 1.25);
          body.position.y = 0.42;
          animal.add(body);

          // Chest tuft
          const chest = createAnimeMesh(animeSphere(0.22), secondaryColor);
          chest.scale.set(0.8, 0.9, 0.5);
          chest.position.set(0, 0.45, 0.18);
          animal.add(chest);

          // Elegant head
          const head = createAnimeMesh(animeSphere(0.34), primaryColor);
          head.scale.set(1.12, 1.0, 0.98);
          head.position.y = 0.9;
          animal.add(head);

          // Pointed ears with inner detail
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            const ear = createAnimeMesh(
              new THREE.ConeGeometry(0.1, 0.22, 16),
              primaryColor
            );
            earGroup.add(ear);

            const innerEar = createAnimeMesh(
              new THREE.ConeGeometry(0.06, 0.14, 12),
              secondaryColor
            );
            innerEar.position.z = 0.02;
            innerEar.position.y = -0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.22, 1.18, -0.02);
            earGroup.rotation.z = side * -0.15;
            animal.add(earGroup);
          });

          // Large almond-shaped anime eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.13,
              irisColor: 0x2d8a4e,
              irisColorInner: 0x4adb7a,
              position: { x: side * 0.14, y: 0.93, z: 0.28 },
              scale: { x: 1.15, y: 1.0, z: 0.65 },
              pupilSize: 0.25,
            });
            animal.add(eye);

            // Vertical pupil overlay for cat
            const vertPupil = new THREE.Mesh(
              new THREE.BoxGeometry(0.015, 0.08, 0.01),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            vertPupil.position.set(side * 0.14, 0.93, 0.36);
            animal.add(vertPupil);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.06);
            blush.position.set(side * 0.26, 0.84, 0.22);
            animal.add(blush);
          });

          // Soft muzzle
          const muzzle = createAnimeMesh(animeSphere(0.12), secondaryColor);
          muzzle.scale.set(1.0, 0.7, 0.85);
          muzzle.position.set(0, 0.82, 0.28);
          animal.add(muzzle);

          // Pink nose
          const nose = createAnimeMesh(animeSphere(0.035), 0xffb6c1);
          nose.scale.set(1.1, 0.8, 0.9);
          nose.position.set(0, 0.86, 0.35);
          animal.add(nose);

          // Whiskers (6 total)
          [-1, 1].forEach((side) => {
            for (let i = 0; i < 3; i++) {
              const whisker = createWhisker(0.18);
              whisker.position.set(side * 0.12, 0.82 + (i - 1) * 0.035, 0.28);
              whisker.rotation.y = side * (0.2 + i * 0.1);
              whisker.rotation.z = (i - 1) * 0.15;
              animal.add(whisker);
            }
          });

          // Elegant curved tail
          const tailGroup = new THREE.Group();
          const tailSegments = 5;
          let prevY = 0,
            prevZ = 0;
          for (let i = 0; i < tailSegments; i++) {
            const segSize = 0.045 - i * 0.006;
            const seg = createAnimeMesh(animeSphere(segSize), primaryColor);
            seg.scale.set(1, 1.3, 1);
            const angle = (i / tailSegments) * 1.2;
            const yOffset = Math.sin(angle) * 0.08 * i;
            const zOffset = -0.08 * i;
            seg.position.set(0, prevY + 0.06, prevZ + zOffset * 0.3);
            prevY = seg.position.y;
            prevZ = seg.position.z;
            tailGroup.add(seg);
          }
          tailGroup.position.set(0, 0.42, -0.35);
          tailGroup.rotation.x = 0.8;
          animal.add(tailGroup);

          // Front paws with pads
          [-1, 1].forEach((side) => {
            const paw = createAnimeMesh(animeSphere(0.065), primaryColor);
            paw.scale.set(0.9, 0.7, 1.1);
            paw.position.set(side * 0.14, 0.06, 0.15);
            animal.add(paw);

            // Main pad
            const mainPad = createPawPad(0.025);
            mainPad.position.set(side * 0.14, 0.04, 0.18);
            animal.add(mainPad);

            // Toe beans
            for (let t = 0; t < 3; t++) {
              const bean = createPawPad(0.012);
              bean.position.set(
                side * 0.14 + (t - 1) * 0.018,
                0.04,
                0.2 + Math.abs(t - 1) * 0.008
              );
              animal.add(bean);
            }
          });

          // Back paws
          [-1, 1].forEach((side) => {
            const paw = createAnimeMesh(animeSphere(0.07), primaryColor);
            paw.scale.set(0.85, 0.65, 1.15);
            paw.position.set(side * 0.12, 0.055, -0.15);
            animal.add(paw);
          });

          return animal;
        }

        // ===== ANIME FOX =====
        function createFoxAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "fox";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("fox", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek body
          const body = createAnimeMesh(animeSphere(0.38), primaryColor);
          body.scale.set(1.0, 0.85, 1.3);
          body.position.y = 0.45;
          animal.add(body);

          // White chest/bib
          const chest = createAnimeMesh(animeSphere(0.28), secondaryColor);
          chest.scale.set(0.8, 0.95, 0.55);
          chest.position.set(0, 0.48, 0.2);
          animal.add(chest);

          // Elegant pointed head
          const head = createAnimeMesh(animeSphere(0.32), primaryColor);
          head.scale.set(1.1, 0.98, 1.0);
          head.position.y = 0.95;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Large pointed ears with black tips
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            // Main ear
            const ear = createAnimeMesh(
              new THREE.ConeGeometry(0.12, 0.28, 16),
              primaryColor
            );
            earGroup.add(ear);

            // Black tip
            const tip = createAnimeMesh(
              new THREE.ConeGeometry(0.06, 0.1, 12),
              0x2a2a2a
            );
            tip.position.y = 0.12;
            earGroup.add(tip);

            // Inner ear
            const innerEar = createAnimeMesh(
              new THREE.ConeGeometry(0.07, 0.18, 12),
              secondaryColor
            );
            innerEar.position.z = 0.02;
            innerEar.position.y = -0.03;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.22, 1.28, -0.05);
            earGroup.rotation.z = side * -0.2;
            animal.add(earGroup);
          });

          // Sharp amber anime eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.12,
              irisColor: 0xc87a2a,
              irisColorInner: 0xf5a623,
              position: { x: side * 0.15, y: 0.98, z: 0.26 },
              scale: { x: 1.1, y: 1.0, z: 0.65 },
              pupilSize: 0.32,
            });
            animal.add(eye);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.055);
            blush.position.set(side * 0.26, 0.88, 0.2);
            animal.add(blush);
          });

          // Pointed snout
          const snout = createAnimeMesh(
            new THREE.ConeGeometry(0.1, 0.22, 24),
            secondaryColor
          );
          snout.rotation.x = -Math.PI / 2;
          snout.position.set(0, 0.88, 0.32);
          animal.add(snout);

          // Black nose
          const nose = createAnimeMesh(animeSphere(0.04), accentColor);
          nose.position.set(0, 0.88, 0.44);
          animal.add(nose);

          // Cheek fluff
          [-1, 1].forEach((side) => {
            const fluff = createFurTuft(0.05, primaryColor);
            fluff.position.set(side * 0.28, 0.92, 0.15);
            fluff.rotation.z = side * 0.4;
            animal.add(fluff);
          });

          // Gorgeous fluffy tail
          const tailGroup = new THREE.Group();

          // Main tail body
          const tailMain = createAnimeMesh(
            new THREE.CapsuleGeometry(0.12, 0.5, 24, 32),
            primaryColor
          );
          tailMain.rotation.x = 0.6;
          tailGroup.add(tailMain);

          // White tail tip
          const tailTip = createAnimeMesh(animeSphere(0.12), secondaryColor);
          tailTip.position.set(0, 0.35, -0.18);
          tailGroup.add(tailTip);

          // Tail fluff
          for (let i = 0; i < 3; i++) {
            const fluff = createFurTuft(0.06, primaryColor);
            fluff.position.set(
              (Math.random() - 0.5) * 0.1,
              0.1 + i * 0.12,
              -0.08 - i * 0.04
            );
            tailGroup.add(fluff);
          }

          tailGroup.position.set(0, 0.4, -0.48);
          animal.add(tailGroup);

          // Slender legs
          [-1, 1].forEach((side) => {
            // Front leg
            const frontLeg = createAnimeMesh(
              animeCylinder(0.045, 0.04, 0.18),
              primaryColor
            );
            frontLeg.position.set(side * 0.16, 0.12, 0.18);
            animal.add(frontLeg);

            const frontPaw = createAnimeMesh(animeSphere(0.055), primaryColor);
            frontPaw.scale.set(0.9, 0.6, 1.1);
            frontPaw.position.set(side * 0.16, 0.04, 0.2);
            animal.add(frontPaw);

            // Back leg
            const backLeg = createAnimeMesh(
              animeCylinder(0.05, 0.045, 0.16),
              primaryColor
            );
            backLeg.position.set(side * 0.14, 0.1, -0.18);
            animal.add(backLeg);

            const backPaw = createAnimeMesh(animeSphere(0.055), primaryColor);
            backPaw.scale.set(0.85, 0.55, 1.05);
            backPaw.position.set(side * 0.14, 0.04, -0.16);
            animal.add(backPaw);
          });

          return animal;
        }

        // ===== ANIME BEAR =====
        function createBearAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "bear";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("bear", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round chunky body
          const body = createAnimeMesh(animeSphere(0.52), primaryColor);
          body.scale.set(1.1, 1.0, 0.95);
          body.position.y = 0.55;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly patch
          const belly = createAnimeMesh(animeSphere(0.38), secondaryColor);
          belly.scale.set(0.9, 0.85, 0.5);
          belly.position.set(0, 0.5, 0.25);
          animal.add(belly);

          // Round expressive head
          const head = createAnimeMesh(animeSphere(0.45), primaryColor);
          head.scale.set(1.05, 1.0, 0.98);
          head.position.y = 1.18;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Round ears with inner detail
          [-1, 1].forEach((side) => {
            const ear = createAnimeMesh(animeSphere(0.12), primaryColor);
            ear.scale.set(1.0, 1.0, 0.6);
            ear.position.set(side * 0.32, 1.52, -0.02);
            animal.add(ear);

            const innerEar = createAnimeMesh(animeSphere(0.07), secondaryColor);
            innerEar.scale.set(1.0, 1.0, 0.5);
            innerEar.position.set(side * 0.32, 1.52, 0.02);
            animal.add(innerEar);
          });

          // Warm gentle eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.12,
              irisColor: 0x4a3520,
              irisColorInner: 0x725a3a,
              position: { x: side * 0.18, y: 1.22, z: 0.38 },
              scale: { x: 1.0, y: 1.05, z: 0.65 },
              pupilSize: 0.4,
            });
            animal.add(eye);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.07);
            blush.position.set(side * 0.32, 1.1, 0.32);
            animal.add(blush);
          });

          // Rounded muzzle
          const muzzle = createAnimeMesh(animeSphere(0.18), secondaryColor);
          muzzle.scale.set(1.0, 0.8, 0.85);
          muzzle.position.set(0, 1.08, 0.4);
          animal.add(muzzle);

          // Big nose
          const nose = createAnimeMesh(animeSphere(0.065), accentColor);
          nose.scale.set(1.2, 0.9, 1.0);
          nose.position.set(0, 1.14, 0.52);
          animal.add(nose);

          // Small mouth
          const mouth = new THREE.Mesh(
            new THREE.TorusGeometry(0.04, 0.01, 8, 12, Math.PI),
            new THREE.MeshBasicMaterial({ color: 0x3a2a2a })
          );
          mouth.rotation.x = Math.PI;
          mouth.position.set(0, 1.02, 0.48);
          animal.add(mouth);

          // Chunky arms
          [-1, 1].forEach((side) => {
            const arm = createAnimeMesh(animeSphere(0.14), primaryColor);
            arm.scale.set(0.85, 1.3, 0.9);
            arm.position.set(side * 0.45, 0.55, 0.1);
            animal.add(arm);

            // Paw
            const paw = createAnimeMesh(animeSphere(0.1), primaryColor);
            paw.scale.set(1.0, 0.8, 1.1);
            paw.position.set(side * 0.48, 0.35, 0.18);
            animal.add(paw);

            // Paw pad
            const pad = createPawPad(0.05);
            pad.position.set(side * 0.48, 0.32, 0.24);
            animal.add(pad);
          });

          // Chunky legs
          [-1, 1].forEach((side) => {
            const leg = createAnimeMesh(animeSphere(0.14), primaryColor);
            leg.scale.set(1.0, 0.9, 1.1);
            leg.position.set(side * 0.2, 0.12, 0.02);
            animal.add(leg);

            // Foot pad
            const footPad = createPawPad(0.06);
            footPad.position.set(side * 0.2, 0.08, 0.08);
            animal.add(footPad);
          });

          // Tiny tail
          const tail = createAnimeMesh(animeSphere(0.08), primaryColor);
          tail.position.set(0, 0.45, -0.42);
          animal.add(tail);

          return animal;
        }

        // ===== ANIME PANDA =====
        function createPandaAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "panda";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("panda", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round body (white)
          const body = createAnimeMesh(animeSphere(0.48), primaryColor);
          body.scale.set(1.0, 1.0, 0.92);
          body.position.y = 0.52;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Round head (white)
          const head = createAnimeMesh(animeSphere(0.44), primaryColor);
          head.position.y = 1.12;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Iconic eye patches (black, carefully shaped)
          [-1, 1].forEach((side) => {
            const patch = createAnimeMesh(animeSphere(0.16), secondaryColor);
            patch.scale.set(1.3, 1.1, 0.45);
            patch.position.set(side * 0.18, 1.15, 0.35);
            animal.add(patch);
          });

          // Soulful eyes within patches
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.11,
              irisColor: 0x2a2520,
              irisColorInner: 0x4a4540,
              position: { x: side * 0.17, y: 1.15, z: 0.42 },
              scale: { x: 1.0, y: 1.1, z: 0.65 },
              pupilSize: 0.38,
            });
            animal.add(eye);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.06);
            blush.position.set(side * 0.32, 1.02, 0.3);
            animal.add(blush);
          });

          // Round black ears
          [-1, 1].forEach((side) => {
            const ear = createAnimeMesh(animeSphere(0.14), secondaryColor);
            ear.scale.set(1.0, 1.0, 0.65);
            ear.position.set(side * 0.32, 1.48, -0.02);
            animal.add(ear);

            // Inner ear gray
            const innerEar = createAnimeMesh(animeSphere(0.08), 0x4a4a4a);
            innerEar.scale.set(1.0, 1.0, 0.5);
            innerEar.position.set(side * 0.32, 1.48, 0.03);
            animal.add(innerEar);
          });

          // Muzzle
          const muzzle = createAnimeMesh(animeSphere(0.14), primaryColor);
          muzzle.scale.set(1.0, 0.75, 0.8);
          muzzle.position.set(0, 1.02, 0.38);
          animal.add(muzzle);

          // Nose
          const nose = createAnimeMesh(animeSphere(0.05), secondaryColor);
          nose.position.set(0, 1.06, 0.48);
          animal.add(nose);

          // Black arms
          [-1, 1].forEach((side) => {
            const arm = createAnimeMesh(animeSphere(0.13), secondaryColor);
            arm.scale.set(0.9, 1.4, 0.9);
            arm.position.set(side * 0.42, 0.52, 0.08);
            animal.add(arm);

            // Paw
            const paw = createAnimeMesh(animeSphere(0.1), secondaryColor);
            paw.position.set(side * 0.45, 0.32, 0.15);
            animal.add(paw);

            // Paw pad
            const pad = createPawPad(0.045, 0xffcccc);
            pad.position.set(side * 0.45, 0.28, 0.2);
            animal.add(pad);
          });

          // Black legs
          [-1, 1].forEach((side) => {
            const leg = createAnimeMesh(animeSphere(0.13), secondaryColor);
            leg.scale.set(1.0, 0.9, 1.1);
            leg.position.set(side * 0.18, 0.12, 0.02);
            animal.add(leg);
          });

          return animal;
        }

        // ===== ANIME PENGUIN =====
        function createPenguinAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "penguin";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("penguin", colorOverride, options);
          animal.userData.variant = variantKey;

          // Sleek tuxedo body
          const body = createAnimeMesh(animeSphere(0.42), primaryColor);
          body.scale.set(0.95, 1.15, 0.88);
          body.position.y = 0.52;
          animal.add(body);
          animal.userData.animationData.body = body;

          // White belly (tuxedo front)
          const belly = createAnimeMesh(animeSphere(0.35), secondaryColor);
          belly.scale.set(0.85, 1.05, 0.5);
          belly.position.set(0, 0.5, 0.2);
          animal.add(belly);

          // Round head
          const head = createAnimeMesh(animeSphere(0.36), primaryColor);
          head.scale.set(1.0, 0.95, 0.95);
          head.position.y = 1.05;
          animal.add(head);
          animal.userData.animationData.head = head;

          // White face patch
          const facePatch = createAnimeMesh(animeSphere(0.28), secondaryColor);
          facePatch.scale.set(0.95, 0.9, 0.45);
          facePatch.position.set(0, 1.02, 0.28);
          animal.add(facePatch);

          // Large adorable eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.11,
              irisColor: 0x1a3050,
              irisColorInner: 0x305080,
              position: { x: side * 0.14, y: 1.08, z: 0.3 },
              scale: { x: 1.0, y: 1.1, z: 0.65 },
              pupilSize: 0.35,
            });
            animal.add(eye);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.055);
            blush.position.set(side * 0.25, 0.95, 0.26);
            animal.add(blush);
          });

          // Distinctive orange beak
          const beakTop = createAnimeMesh(
            new THREE.ConeGeometry(0.08, 0.12, 16),
            accentColor
          );
          beakTop.rotation.x = -Math.PI / 2 - 0.2;
          beakTop.position.set(0, 0.95, 0.38);
          animal.add(beakTop);

          // Flippers with detail
          [-1, 1].forEach((side) => {
            const flipperGroup = new THREE.Group();

            const flipper = createAnimeMesh(animeSphere(0.12), primaryColor);
            flipper.scale.set(0.5, 1.3, 0.9);
            flipperGroup.add(flipper);

            flipperGroup.position.set(side * 0.38, 0.52, 0);
            flipperGroup.rotation.z = side * 0.25;
            animal.add(flipperGroup);
          });

          // Orange webbed feet
          [-1, 1].forEach((side) => {
            const foot = createAnimeMesh(animeSphere(0.08), accentColor);
            foot.scale.set(1.3, 0.4, 1.5);
            foot.position.set(side * 0.12, 0.04, 0.08);
            animal.add(foot);

            // Webbing detail (3 toes)
            for (let t = 0; t < 3; t++) {
              const toe = createAnimeMesh(animeSphere(0.025), accentColor);
              toe.scale.set(0.8, 0.5, 1.8);
              toe.position.set(side * 0.12 + (t - 1) * 0.035, 0.03, 0.15);
              animal.add(toe);
            }
          });

          return animal;
        }

        // ===== ANIME OWL =====
        function createOwlAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "owl";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("owl", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round fluffy body
          const body = createAnimeMesh(animeSphere(0.4), primaryColor);
          body.scale.set(1.0, 1.1, 0.9);
          body.position.y = 0.45;
          animal.add(body);

          // Chest feathers
          const chest = createAnimeMesh(animeSphere(0.32), secondaryColor);
          chest.scale.set(0.85, 0.95, 0.5);
          chest.position.set(0, 0.42, 0.18);
          animal.add(chest);

          // Round head
          const head = createAnimeMesh(animeSphere(0.38), primaryColor);
          head.position.y = 1.0;
          animal.add(head);

          // Facial disc
          const facialDisc = createAnimeMesh(animeSphere(0.32), secondaryColor);
          facialDisc.scale.set(1.0, 1.0, 0.4);
          facialDisc.position.set(0, 0.98, 0.25);
          animal.add(facialDisc);

          // HUGE dramatic owl eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.15,
              irisColor: 0xb86a14,
              irisColorInner: 0xf5a020,
              position: { x: side * 0.15, y: 1.02, z: 0.32 },
              scale: { x: 1.0, y: 1.15, z: 0.65 },
              pupilSize: 0.35,
              highlightIntensity: 1.2,
            });
            animal.add(eye);
          });

          // Sharp beak
          const beak = createAnimeMesh(
            new THREE.ConeGeometry(0.05, 0.1, 12),
            accentColor
          );
          beak.rotation.x = -Math.PI / 2 - 0.4;
          beak.position.set(0, 0.88, 0.38);
          animal.add(beak);

          // Ear tufts
          [-1, 1].forEach((side) => {
            const tuftGroup = new THREE.Group();

            for (let i = 0; i < 3; i++) {
              const feather = createAnimeMesh(
                new THREE.ConeGeometry(0.025, 0.12 - i * 0.02, 8),
                primaryColor
              );
              feather.position.set((i - 1) * 0.02, i * 0.04, 0);
              feather.rotation.z = side * -0.15;
              tuftGroup.add(feather);
            }

            tuftGroup.position.set(side * 0.28, 1.35, -0.05);
            animal.add(tuftGroup);
          });

          // Layered wing feathers
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            // Main wing
            const wing = createAnimeMesh(animeSphere(0.15), primaryColor);
            wing.scale.set(0.5, 1.2, 0.9);
            wingGroup.add(wing);

            // Feather tips
            for (let f = 0; f < 3; f++) {
              const featherTip = createAnimeMesh(
                new THREE.ConeGeometry(0.035, 0.1, 8),
                primaryColor
              );
              featherTip.position.set(0, -0.12 - f * 0.06, -0.05);
              featherTip.rotation.x = 0.5;
              wingGroup.add(featherTip);
            }

            wingGroup.position.set(side * 0.38, 0.45, -0.02);
            animal.add(wingGroup);
          });

          // Sharp talons
          [-1, 1].forEach((side) => {
            const foot = createAnimeMesh(animeSphere(0.05), 0x5a5040);
            foot.scale.set(1.2, 0.6, 1.4);
            foot.position.set(side * 0.1, 0.04, 0.05);
            animal.add(foot);

            // Talons
            for (let c = 0; c < 3; c++) {
              const talon = createAnimeMesh(
                new THREE.ConeGeometry(0.012, 0.04, 6),
                0x3a3a3a
              );
              talon.rotation.x = Math.PI / 2;
              talon.position.set(side * 0.1 + (c - 1) * 0.02, 0.02, 0.1);
              animal.add(talon);
            }
          });

          return animal;
        }

        // ===== ANIME DUCK =====
        function createDuckAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "duck";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("duck", colorOverride, options);
          animal.userData.variant = variantKey;

          // Round fluffy body
          const body = createAnimeMesh(animeSphere(0.38), primaryColor);
          body.scale.set(1.0, 0.9, 1.15);
          body.position.y = 0.42;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Round head
          const head = createAnimeMesh(animeSphere(0.32), primaryColor);
          head.position.y = 0.9;
          animal.add(head);
          animal.userData.animationData.head = head;

          // Bright expressive eyes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.1,
              irisColor: 0x2a4a5a,
              irisColorInner: 0x4a7a9a,
              position: { x: side * 0.13, y: 0.94, z: 0.26 },
              scale: { x: 1.0, y: 1.05, z: 0.65 },
              pupilSize: 0.38,
            });
            animal.add(eye);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.05);
            blush.position.set(side * 0.24, 0.85, 0.22);
            animal.add(blush);
          });

          // Distinctive orange bill
          const bill = createAnimeMesh(animeSphere(0.1), accentColor);
          bill.scale.set(1.0, 0.55, 1.6);
          bill.position.set(0, 0.82, 0.32);
          animal.add(bill);

          // Nostril detail
          [-1, 1].forEach((side) => {
            const nostril = new THREE.Mesh(
              animeSphere(0.012),
              new THREE.MeshBasicMaterial({ color: 0x4a3a2a })
            );
            nostril.position.set(side * 0.03, 0.84, 0.42);
            animal.add(nostril);
          });

          // Wing detail
          [-1, 1].forEach((side) => {
            const wingGroup = new THREE.Group();

            const wing = createAnimeMesh(animeSphere(0.12), primaryColor);
            wing.scale.set(0.5, 1.0, 1.1);
            wingGroup.add(wing);

            // Feather layers
            for (let f = 0; f < 3; f++) {
              const feather = createAnimeMesh(animeSphere(0.035), primaryColor);
              feather.scale.set(0.6, 1.5, 1.0);
              feather.position.set(0, -0.08 - f * 0.05, 0.02);
              wingGroup.add(feather);
            }

            wingGroup.position.set(side * 0.32, 0.42, -0.02);
            animal.add(wingGroup);
          });

          // Cute tail feathers
          const tailGroup = new THREE.Group();
          for (let t = 0; t < 3; t++) {
            const tailFeather = createAnimeMesh(
              new THREE.ConeGeometry(0.03, 0.12, 8),
              primaryColor
            );
            tailFeather.position.set((t - 1) * 0.03, 0, 0);
            tailFeather.rotation.x = Math.PI / 2 + 0.3;
            tailGroup.add(tailFeather);
          }
          tailGroup.position.set(0, 0.48, -0.35);
          animal.add(tailGroup);

          // Orange webbed feet
          [-1, 1].forEach((side) => {
            const foot = createAnimeMesh(animeSphere(0.07), accentColor);
            foot.scale.set(1.4, 0.35, 1.6);
            foot.position.set(side * 0.1, 0.04, 0.08);
            animal.add(foot);
          });

          return animal;
        }

        // ===== ANIME FROG =====
        function createFrogAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "frog";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("frog", colorOverride, options);
          animal.userData.variant = variantKey;

          // Wide squat body
          const body = createAnimeMesh(animeSphere(0.4), primaryColor);
          body.scale.set(1.3, 0.75, 1.0);
          body.position.y = 0.32;
          animal.add(body);
          animal.userData.animationData.body = body;

          // Belly
          const belly = createAnimeMesh(animeSphere(0.32), secondaryColor);
          belly.scale.set(1.15, 0.65, 0.5);
          belly.position.set(0, 0.28, 0.18);
          animal.add(belly);

          // Wide head
          const head = createAnimeMesh(animeSphere(0.35), primaryColor);
          head.scale.set(1.25, 0.85, 1.0);
          head.position.y = 0.65;
          animal.add(head);
          animal.userData.animationData.head = head;

          // HUGE bulging eyes on top
          [-1, 1].forEach((side) => {
            // Eye bulge
            const eyeBulge = createAnimeMesh(animeSphere(0.15), primaryColor);
            eyeBulge.position.set(side * 0.22, 0.88, 0.12);
            animal.add(eyeBulge);

            // Actual eye (golden iris, horizontal pupil)
            const eye = createAnimeEye({
              size: 0.12,
              irisColor: 0xb8922a,
              irisColorInner: 0xe8c240,
              position: { x: side * 0.22, y: 0.9, z: 0.22 },
              scale: { x: 1.0, y: 1.0, z: 0.65 },
              pupilSize: 0.3,
              highlightIntensity: 1.1,
            });
            animal.add(eye);

            // Horizontal pupil overlay
            const hPupil = new THREE.Mesh(
              new THREE.BoxGeometry(0.06, 0.015, 0.01),
              new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            hPupil.position.set(side * 0.22, 0.9, 0.3);
            animal.add(hPupil);
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.06);
            blush.position.set(side * 0.35, 0.58, 0.2);
            animal.add(blush);
          });

          // Wide happy mouth
          const mouthCurve = new THREE.Mesh(
            new THREE.TorusGeometry(0.12, 0.015, 8, 24, Math.PI),
            new THREE.MeshBasicMaterial({ color: 0x3a4a3a })
          );
          mouthCurve.rotation.x = Math.PI;
          mouthCurve.position.set(0, 0.52, 0.32);
          animal.add(mouthCurve);

          // Front legs with finger detail
          [-1, 1].forEach((side) => {
            const armGroup = new THREE.Group();

            const arm = createAnimeMesh(animeSphere(0.08), primaryColor);
            arm.scale.set(0.9, 1.2, 0.9);
            armGroup.add(arm);

            // Fingers
            for (let f = 0; f < 4; f++) {
              const finger = createAnimeMesh(
                new THREE.CapsuleGeometry(0.015, 0.06, 8, 12),
                primaryColor
              );
              finger.position.set((f - 1.5) * 0.025, -0.1, 0.03);
              finger.rotation.x = 0.3;
              armGroup.add(finger);
            }

            armGroup.position.set(side * 0.38, 0.18, 0.2);
            animal.add(armGroup);
          });

          // Back legs (bent, powerful)
          [-1, 1].forEach((side) => {
            // Thigh
            const thigh = createAnimeMesh(animeSphere(0.12), primaryColor);
            thigh.scale.set(1.0, 1.4, 0.9);
            thigh.position.set(side * 0.35, 0.22, -0.12);
            animal.add(thigh);

            // Webbed foot
            const foot = createAnimeMesh(animeSphere(0.08), primaryColor);
            foot.scale.set(1.2, 0.5, 1.8);
            foot.position.set(side * 0.42, 0.06, -0.2);
            animal.add(foot);

            // Toe webbing
            for (let t = 0; t < 3; t++) {
              const toe = createAnimeMesh(animeSphere(0.02), primaryColor);
              toe.scale.set(0.8, 0.5, 2.0);
              toe.position.set(side * 0.42 + (t - 1) * 0.03, 0.04, -0.25);
              animal.add(toe);
            }
          });

          return animal;
        }

        // ===== ANIME ELEPHANT =====
        function createElephantAnime(type, colorOverride = null, options = {}) {
          const animal = new THREE.Group();
          animal.userData.type = "elephant";
          animal.userData.animationData = {};
          animal.userData.modelStyle = "anime";

          const { primaryColor, secondaryColor, accentColor, variantKey } =
            getBuilderColors("elephant", colorOverride, options);
          animal.userData.variant = variantKey;

          // Large round body
          const body = createAnimeMesh(animeSphere(0.52), primaryColor);
          body.scale.set(1.15, 1.0, 1.0);
          body.position.y = 0.65;
          animal.add(body);

          // Round head
          const head = createAnimeMesh(animeSphere(0.42), primaryColor);
          head.position.y = 1.25;
          animal.add(head);

          // Large expressive eyes with long lashes
          [-1, 1].forEach((side) => {
            const eye = createAnimeEye({
              size: 0.11,
              irisColor: 0x3a3530,
              irisColorInner: 0x5a5550,
              position: { x: side * 0.2, y: 1.3, z: 0.35 },
              scale: { x: 1.0, y: 1.1, z: 0.65 },
              pupilSize: 0.4,
            });
            animal.add(eye);

            // Long lashes
            for (let l = 0; l < 3; l++) {
              const lash = new THREE.Mesh(
                new THREE.CylinderGeometry(0.004, 0.002, 0.05, 6),
                new THREE.MeshBasicMaterial({ color: 0x2a2a2a })
              );
              lash.position.set(side * 0.2 + (l - 1) * 0.025, 1.38, 0.38);
              lash.rotation.x = -0.5;
              lash.rotation.z = (l - 1) * side * 0.15;
              animal.add(lash);
            }
          });

          // Blush
          [-1, 1].forEach((side) => {
            const blush = createBlush(0.06);
            blush.position.set(side * 0.32, 1.18, 0.3);
            animal.add(blush);
          });

          // Detailed trunk (segmented)
          const trunkGroup = new THREE.Group();
          const trunkSegments = 6;
          let trunkY = 0;
          for (let s = 0; s < trunkSegments; s++) {
            const segSize = 0.1 - s * 0.01;
            const seg = createAnimeMesh(animeSphere(segSize), primaryColor);
            seg.scale.set(1.0, 0.8, 1.0);
            seg.position.y = trunkY;
            trunkY -= 0.08;
            trunkGroup.add(seg);
          }
          // Trunk tip curl
          const trunkTip = createAnimeMesh(animeSphere(0.04), secondaryColor);
          trunkTip.position.set(0, trunkY + 0.02, 0.04);
          trunkGroup.add(trunkTip);

          trunkGroup.position.set(0, 1.08, 0.4);
          trunkGroup.rotation.x = 0.3;
          animal.add(trunkGroup);

          // Huge fan-shaped ears
          [-1, 1].forEach((side) => {
            const earGroup = new THREE.Group();

            // Main ear
            const ear = createAnimeMesh(animeSphere(0.35), primaryColor);
            ear.scale.set(0.15, 1.0, 0.85);
            earGroup.add(ear);

            // Inner ear (pink)
            const innerEar = createAnimeMesh(animeSphere(0.25), secondaryColor);
            innerEar.scale.set(0.12, 0.75, 0.65);
            innerEar.position.z = 0.02;
            earGroup.add(innerEar);

            earGroup.position.set(side * 0.48, 1.2, -0.05);
            earGroup.rotation.y = side * 0.15;
            animal.add(earGroup);
          });

          // Ivory tusks
          [-1, 1].forEach((side) => {
            const tusk = createAnimeMesh(
              new THREE.CapsuleGeometry(0.035, 0.18, 12, 16),
              0xfffff8
            );
            tusk.rotation.z = side * 0.3;
            tusk.rotation.x = -0.2;
            tusk.position.set(side * 0.18, 0.95, 0.35);
            animal.add(tusk);
          });

          // Chunky legs
          const legPositions = [
            { x: -0.28, z: 0.15 },
            { x: 0.28, z: 0.15 },
            { x: -0.25, z: -0.18 },
            { x: 0.25, z: -0.18 },
          ];
          legPositions.forEach((pos, idx) => {
            const leg = createAnimeMesh(
              animeCylinder(0.12, 0.1, 0.4),
              primaryColor
            );
            leg.position.set(pos.x, 0.25, pos.z);
            animal.add(leg);

            // Foot
            const foot = createAnimeMesh(animeSphere(0.1), primaryColor);
            foot.scale.set(1.1, 0.5, 1.2);
            foot.position.set(pos.x, 0.06, pos.z);
            animal.add(foot);

            // Toenails
            for (let t = 0; t < 3; t++) {
              const nail = createAnimeMesh(animeSphere(0.02), 0xe8e8d8);
              nail.scale.set(0.8, 0.6, 1.0);
              nail.position.set(pos.x + (t - 1) * 0.035, 0.04, pos.z + 0.08);
              animal.add(nail);
            }
          });

          // Expressive tail with tuft
          const tailGroup = new THREE.Group();
          const tailBody = createAnimeMesh(
            new THREE.CapsuleGeometry(0.025, 0.2, 12, 16),
            primaryColor
          );
          tailGroup.add(tailBody);

          // Tail tuft
          const tuft = createAnimeMesh(animeSphere(0.04), 0x4a4a4a);
          tuft.scale.set(1.0, 1.5, 1.0);
          tuft.position.y = -0.12;
          tailGroup.add(tuft);

          tailGroup.position.set(0, 0.58, -0.45);
          tailGroup.rotation.x = 0.5;
          animal.add(tailGroup);

          return animal;
        }

        // Register Anime builders
        const ANIME_BUILDERS = {
          bunny: createBunnyAnime,
          bear: createBearAnime,
          penguin: createPenguinAnime,
          fox: createFoxAnime,
          cat: createCatAnime,
          owl: createOwlAnime,
          panda: createPandaAnime,
          duck: createDuckAnime,
          frog: createFrogAnime,
          elephant: createElephantAnime,
        };

        // Register the Anime style
        MODEL_STYLE_BUILDERS.anime = ANIME_BUILDERS;
        console.log(
          "[Registration] Anime builders registered:",
          Object.keys(ANIME_BUILDERS).join(", ")
        );

        // Color palettes for customization
        const COLOR_PALETTES = {
          default: null,
          pink: { primary: 0xffb6c1, secondary: 0xffc0cb },
          blue: { primary: 0xadd8e6, secondary: 0xe0ffff },
          yellow: { primary: 0xfffacd, secondary: 0xffffe0 },
          green: { primary: 0x98fb98, secondary: 0xf0fff0 },
          purple: { primary: 0xdda0dd, secondary: 0xe6e6fa },
        };

        // ==========================================
        // SCENE SETUP
        // ==========================================
        const container = document.getElementById("canvas-container");
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1e2028);
        scene.fog = new THREE.Fog(0x1e2028, 10, 30);

        const camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          0.1,
          100
        );
        camera.position.set(5, 3, 5);

        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.15;
        container.appendChild(renderer.domElement);

        // ==========================================
        // LIGHTING - PHASE 4 ENHANCED PREMIUM SETUP
        // ==========================================
        // Warm ambient for soft vinyl appearance
        const ambientLight = new THREE.AmbientLight(0xfff8f0, 0.7);
        scene.add(ambientLight);

        // Key light - warm, main illumination with HIGH QUALITY shadows
        const keyLight = new THREE.DirectionalLight(0xffeedd, 2.4);
        keyLight.position.set(5, 10, 4);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 4096; // 4K shadow for crisp edges
        keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.bias = -0.00005; // Reduced bias for less peter-panning
        keyLight.shadow.normalBias = 0.02; // Helps with self-shadowing
        keyLight.shadow.radius = 4; // Softer shadows
        keyLight.shadow.camera.near = 0.5;
        keyLight.shadow.camera.far = 25;
        keyLight.shadow.camera.left = -8;
        keyLight.shadow.camera.right = 8;
        keyLight.shadow.camera.top = 8;
        keyLight.shadow.camera.bottom = -8;
        scene.add(keyLight);

        // Cool fill light - adds dimension
        const fillLight = new THREE.DirectionalLight(0xc8e0ff, 1.5);
        fillLight.position.set(-5, 4, -2);
        scene.add(fillLight);

        // ENHANCED RIM LIGHT - Colored for dramatic effect
        const rimLight = new THREE.DirectionalLight(0xffc8ff, 1.5);
        rimLight.position.set(0, 4, -8);
        scene.add(rimLight);

        // Secondary rim (opposite side) for balanced silhouette
        const rimLight2 = new THREE.DirectionalLight(0xc8ffff, 0.8);
        rimLight2.position.set(3, 2, -6);
        scene.add(rimLight2);

        // Bottom fill for softer under-shadows (ground bounce)
        const bottomFill = new THREE.DirectionalLight(0xfff5ee, 0.5);
        bottomFill.position.set(0, -3, 2);
        scene.add(bottomFill);

        // Subtle side accent light
        const accentLight = new THREE.DirectionalLight(0xffe8d0, 0.7);
        accentLight.position.set(-4, 2, 5);
        scene.add(accentLight);

        // ==========================================
        // POST-PROCESSING - ENHANCED BLOOM
        // ==========================================
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          0.3, // Increased bloom strength for premium glow
          0.35, // Tighter radius
          0.85 // Higher threshold for selective glow
        );
        composer.addPass(bloomPass);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.autoRotate = false; // Disable auto-rotate to stay in room
        controls.minDistance = 4;
        controls.maxDistance = 8;
        // Limit vertical angle (don't look too far up or down)
        controls.minPolarAngle = Math.PI / 4; // 45 degrees from top
        controls.maxPolarAngle = Math.PI / 2.2; // ~80 degrees from top
        // Limit horizontal rotation to stay within room
        controls.minAzimuthAngle = -Math.PI / 3; // -60 degrees
        controls.maxAzimuthAngle = Math.PI / 3; // +60 degrees
        controls.enablePan = false; // Disable panning to prevent leaving room

        // ==========================================
        // MATERIAL FACTORY - PHASE 4 PREMIUM VINYL
        // ==========================================
        function createVinylMaterial(color, options = {}) {
          // Calculate sheen color based on primary color for subtle iridescence
          const baseColor = new THREE.Color(color);
          const sheenColor = baseColor.clone().offsetHSL(0.05, 0.1, 0.2);

          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.2,
            metalness: options.metalness ?? 0.0,
            clearcoat: options.clearcoat ?? 0.6,
            clearcoatRoughness: options.clearcoatRoughness ?? 0.06,
            reflectivity: options.reflectivity ?? 0.7,
            // Enhanced sheen for soft vinyl subsurface
            sheen: options.sheen ?? 0.35,
            sheenRoughness: options.sheenRoughness ?? 0.35,
            sheenColor: options.sheenColor ?? sheenColor,
            // Stronger iridescence for premium look
            iridescence: options.iridescence ?? 0.2,
            iridescenceIOR: options.iridescenceIOR ?? 1.4,
            // Environment map intensity for reflections
            envMapIntensity: options.envMapIntensity ?? 0.8,
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Matte material variant for softer areas
        function createMatteMaterial(color, options = {}) {
          return new THREE.MeshPhysicalMaterial({
            color: color,
            roughness: options.roughness ?? 0.6,
            metalness: 0.0,
            clearcoat: 0.1,
            sheen: 0.5,
            sheenRoughness: 0.8,
            sheenColor: new THREE.Color(color).offsetHSL(0, -0.1, 0.3),
            side: THREE.DoubleSide,
            ...options,
          });
        }

        // Cached materials
        const materialCache = new Map();
        function getMaterial(color, options = {}) {
          const key = `${color}-${JSON.stringify(options)}`;
          if (!materialCache.has(key)) {
            materialCache.set(key, createVinylMaterial(color, options));
          }
          return materialCache.get(key);
        }

        // Special materials - ENHANCED for premium look
        const SPECIAL_MATERIALS = {
          // Ultra-glossy deep pupil with subtle blue undertone
          eyeBlack: new THREE.MeshPhysicalMaterial({
            color: 0x050510,
            roughness: 0.0,
            clearcoat: 1.0,
            clearcoatRoughness: 0.0,
            metalness: 0.05,
            reflectivity: 1.0,
            ior: 1.5,
          }),
          // Creamy white sclera with subtle translucency
          eyeWhite: new THREE.MeshPhysicalMaterial({
            color: 0xfffef8,
            roughness: 0.08,
            clearcoat: 0.9,
            clearcoatRoughness: 0.05,
            sheen: 0.2,
            sheenColor: new THREE.Color(0xfff0f0),
            transmission: 0.02,
            thickness: 0.1,
          }),
          // Bright specular highlight with subtle bloom potential
          specular: new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.95,
          }),
          // Deep black slit pupil
          pupilSlit: new THREE.MeshBasicMaterial({ color: 0x000005 }),
          // New: Iris material for colored eye details
          iris: function (color) {
            return new THREE.MeshPhysicalMaterial({
              color: color,
              roughness: 0.1,
              clearcoat: 0.8,
              metalness: 0.0,
              sheen: 0.4,
              sheenColor: new THREE.Color(color).offsetHSL(0.1, 0, 0.2),
            });
          },
        };

        // (ART_STYLES, createStyledMaterial, setArtStyle defined earlier in the file)

        // ==========================================
        // MODEL GEOMETRY STYLES
        // ==========================================

        // Current global model style
        let currentModelStyle = "default";

        // Model geometry style presets
        const MODEL_STYLES = {
          default: {
            name: "Smooth Vinyl",
            description: "Rounded, smooth surfaces",
            segments: 32, // High poly count
            flatShading: false,
            edgeOutline: false,
            proportions: { headScale: 1.0, bodyScale: 1.0 },
          },
          comic: {
            name: "Comic Style",
            description: "Angular, cel-shaded look",
            segments: 8, // Low poly for angular look
            flatShading: true,
            edgeOutline: true,
            proportions: { headScale: 1.1, bodyScale: 0.95 },
          },
          lowpoly: {
            name: "Low Poly",
            description: "Faceted retro style",
            segments: 6, // Very low poly
            flatShading: true,
            edgeOutline: false,
            proportions: { headScale: 1.0, bodyScale: 1.0 },
          },
          chibi: {
            name: "Chibi",
            description: "Big head, tiny body",
            segments: 24,
            flatShading: false,
            edgeOutline: false,
            proportions: { headScale: 1.6, bodyScale: 0.7 },
          },
          pixel3d: {
            name: "Pixel 3D",
            description: "Blocky voxel style",
            segments: 1, // Box-like
            flatShading: true,
            edgeOutline: false,
            proportions: { headScale: 1.2, bodyScale: 1.0 },
            useBoxGeometry: true,
          },
        };

        // Change model style (requires respawn to see changes)
        function setModelStyle(styleName) {
          // Update for new builder system
          currentModelStyleName = styleName;

          // Also update legacy system if style exists there
          if (MODEL_STYLES[styleName]) {
            currentModelStyle = styleName;
            console.log(
              `Model style changed to: ${MODEL_STYLES[styleName].name}`
            );
          } else {
            console.log(`Model style changed to: ${styleName}`);
          }
        }

        // ==========================================
        // GEOMETRY HELPERS
        // ==========================================

        // Teardrop/Paddle shape for ears
        function createTeardropGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 16
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * (1 - t) - height / 2;
            const radius =
              radiusBottom + (radiusTop - radiusBottom) * Math.pow(1 - t, 0.5);
            points.push(new THREE.Vector2(radius, y));
          }
          points.push(new THREE.Vector2(0, -height / 2));
          return new THREE.LatheGeometry(points, 16);
        }

        // Pear shape for body
        function createPearGeometry(
          radiusTop,
          radiusBottom,
          height,
          segments = 32
        ) {
          const points = [];
          for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const y = height * t - height / 2;
            // Pear curve - wider at bottom
            const radius =
              radiusTop + (radiusBottom - radiusTop) * Math.pow(t, 0.6);
            points.push(new THREE.Vector2(radius * Math.sin(Math.PI * t), y));
          }
          return new THREE.LatheGeometry(points, 24);
        }

        // Curved trunk with segments
        function createTrunkGeometry(
          baseRadius,
          tipRadius,
          segments,
          curveStrength = 0.3
        ) {
          const group = new THREE.Group();
          for (let i = 0; i < segments; i++) {
            const t = i / (segments - 1);
            const radius = baseRadius + (tipRadius - baseRadius) * t;
            const segment = new THREE.Mesh(
              new THREE.SphereGeometry(radius, 12, 12),
              null // Material applied later
            );
            // S-curve positioning
            const curve = Math.sin(t * Math.PI) * curveStrength;
            segment.position.y = -i * (baseRadius * 1.2);
            segment.position.z = curve + t * 0.2;
            group.add(segment);
          }
          return group;
        }

        // Eye with optional slit pupil - PREMIUM ENHANCED VERSION
        function createEye(scale = 1, slitPupil = false, options = {}) {
          const group = new THREE.Group();
          const baseScale = scale * 1.25; // 25% larger eyes overall

          // Optional eyelid ridge (for mammals)
          if (options.eyelid) {
            const lidGeom = new THREE.TorusGeometry(
              0.075 * baseScale,
              0.012 * baseScale,
              8,
              16,
              Math.PI
            );
            const lid = new THREE.Mesh(
              lidGeom,
              options.lidMaterial || getMaterial(0x1a1a1a)
            );
            lid.rotation.x = Math.PI / 2;
            lid.rotation.z = Math.PI;
            lid.position.set(0, 0.03 * baseScale, 0.02 * baseScale);
            group.add(lid);
          }

          // Ambient occlusion shadow ring around eye (subtle depth)
          const aoRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.078 * baseScale,
              0.008 * baseScale,
              8,
              24
            ),
            new THREE.MeshBasicMaterial({
              color: 0x2a2020,
              transparent: true,
              opacity: 0.15,
            })
          );
          aoRing.position.z = -0.002;
          group.add(aoRing);

          // Sclera (white) - slightly larger with depth
          const scleraGeom = new THREE.SphereGeometry(
            0.075 * baseScale,
            24,
            24
          );
          const sclera = new THREE.Mesh(scleraGeom, SPECIAL_MATERIALS.eyeWhite);
          group.add(sclera);

          // Iris ring (colored ring around pupil for depth)
          const irisColor = options.irisColor || 0x3a2510; // Deep brown default
          const irisRing = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.038 * baseScale,
              0.015 * baseScale,
              12,
              24
            ),
            SPECIAL_MATERIALS.iris(irisColor)
          );
          irisRing.position.z = 0.04 * baseScale;
          group.add(irisRing);

          // Inner iris gradient (darker inner ring)
          const innerIris = new THREE.Mesh(
            new THREE.RingGeometry(0.025 * baseScale, 0.045 * baseScale, 24),
            new THREE.MeshPhysicalMaterial({
              color: new THREE.Color(irisColor).offsetHSL(0, 0, -0.3),
              roughness: 0.15,
              clearcoat: 0.6,
              side: THREE.DoubleSide,
            })
          );
          innerIris.position.z = 0.042 * baseScale;
          group.add(innerIris);

          if (slitPupil) {
            // Cat-style slit pupil with subtle glow edge
            const pupilGeom = new THREE.CylinderGeometry(
              0.012 * baseScale,
              0.012 * baseScale,
              0.095 * baseScale,
              8
            );
            const pupil = new THREE.Mesh(
              pupilGeom,
              SPECIAL_MATERIALS.pupilSlit
            );
            pupil.rotation.x = Math.PI / 2;
            pupil.position.z = 0.055 * baseScale;
            group.add(pupil);

            // Subtle glow around slit for ethereal look
            const slitGlow = new THREE.Mesh(
              new THREE.CylinderGeometry(
                0.018 * baseScale,
                0.018 * baseScale,
                0.09 * baseScale,
                8
              ),
              new THREE.MeshBasicMaterial({
                color: irisColor,
                transparent: true,
                opacity: 0.25,
              })
            );
            slitGlow.rotation.x = Math.PI / 2;
            slitGlow.position.z = 0.054 * baseScale;
            group.add(slitGlow);
          } else {
            // Round pupil - larger for cuter look with depth
            const pupilGeom = new THREE.SphereGeometry(
              0.048 * baseScale,
              20,
              20
            );
            const pupil = new THREE.Mesh(pupilGeom, SPECIAL_MATERIALS.eyeBlack);
            pupil.position.z = 0.045 * baseScale;
            group.add(pupil);
          }

          // Primary highlight (larger, more prominent, positioned at 10 o'clock)
          const highlightGeom = new THREE.SphereGeometry(
            0.022 * baseScale,
            10,
            10
          );
          const highlight = new THREE.Mesh(
            highlightGeom,
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(
            0.018 * baseScale,
            0.028 * baseScale,
            0.068 * baseScale
          );
          group.add(highlight);

          // Secondary highlight (smaller, at 4 o'clock for depth)
          const highlight2Geom = new THREE.SphereGeometry(
            0.012 * baseScale,
            8,
            8
          );
          const highlight2 = new THREE.Mesh(
            highlight2Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(
            -0.012 * baseScale,
            -0.018 * baseScale,
            0.066 * baseScale
          );
          group.add(highlight2);

          // Tertiary micro-highlight (adds sparkle)
          const highlight3Geom = new THREE.SphereGeometry(
            0.006 * baseScale,
            6,
            6
          );
          const highlight3 = new THREE.Mesh(
            highlight3Geom,
            SPECIAL_MATERIALS.specular
          );
          highlight3.position.set(
            0.03 * baseScale,
            0.008 * baseScale,
            0.067 * baseScale
          );
          group.add(highlight3);

          // Subtle lower eye shadow (adds dimension)
          const lowerShadow = new THREE.Mesh(
            new THREE.TorusGeometry(
              0.065 * baseScale,
              0.006 * baseScale,
              8,
              16,
              Math.PI * 0.6
            ),
            new THREE.MeshBasicMaterial({
              color: 0x1a1015,
              transparent: true,
              opacity: 0.08,
            })
          );
          lowerShadow.rotation.x = Math.PI / 2;
          lowerShadow.rotation.z = Math.PI * 0.7;
          lowerShadow.position.set(0, -0.02 * baseScale, 0.03 * baseScale);
          group.add(lowerShadow);

          return group;
        }

        // Owl-style concentric eye - PREMIUM ENHANCED
        function createOwlEye(scale = 1) {
          const group = new THREE.Group();

          // Deep ambient shadow around eye socket
          const eyeSocket = new THREE.Mesh(
            new THREE.CircleGeometry(0.14 * scale, 32),
            new THREE.MeshBasicMaterial({
              color: 0x2a1a10,
              transparent: true,
              opacity: 0.2,
            })
          );
          eyeSocket.position.z = -0.005;
          group.add(eyeSocket);

          // Outer ring (facial disc) - thicker and more prominent
          const outerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.125 * scale, 0.025 * scale, 12, 32),
            getMaterial(0xdeb887, { roughness: 0.4 })
          );
          group.add(outerRing);

          // Secondary inner ring for depth
          const innerRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.105 * scale, 0.01 * scale, 8, 24),
            getMaterial(0xc9a87a, { roughness: 0.5 })
          );
          innerRing.position.z = 0.003;
          group.add(innerRing);

          // Orange iris base - more vibrant
          const eyeBg = new THREE.Mesh(
            new THREE.CircleGeometry(0.1 * scale, 32),
            new THREE.MeshPhysicalMaterial({
              color: 0xff9500,
              roughness: 0.1,
              clearcoat: 0.7,
              sheen: 0.3,
              sheenColor: new THREE.Color(0xffcc00),
            })
          );
          eyeBg.position.z = 0.01;
          group.add(eyeBg);

          // Iris ring pattern (owls have radiating patterns)
          const irisPattern = new THREE.Mesh(
            new THREE.RingGeometry(0.055 * scale, 0.095 * scale, 24, 3),
            new THREE.MeshPhysicalMaterial({
              color: 0xcc6600,
              roughness: 0.2,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.6,
            })
          );
          irisPattern.position.z = 0.012;
          group.add(irisPattern);

          // Inner iris glow ring
          const innerGlow = new THREE.Mesh(
            new THREE.RingGeometry(0.05 * scale, 0.065 * scale, 24),
            new THREE.MeshPhysicalMaterial({
              color: 0xffaa00,
              roughness: 0.05,
              emissive: 0x331100,
              emissiveIntensity: 0.1,
              side: THREE.DoubleSide,
            })
          );
          innerGlow.position.z = 0.015;
          group.add(innerGlow);

          // Large deep pupil
          const pupil = new THREE.Mesh(
            new THREE.CircleGeometry(0.05 * scale, 24),
            SPECIAL_MATERIALS.eyeBlack
          );
          pupil.position.z = 0.018;
          group.add(pupil);

          // Primary highlight - larger for owl
          const highlight = new THREE.Mesh(
            new THREE.CircleGeometry(0.025 * scale, 12),
            SPECIAL_MATERIALS.specular
          );
          highlight.position.set(0.028 * scale, 0.028 * scale, 0.025);
          group.add(highlight);

          // Secondary highlight
          const highlight2 = new THREE.Mesh(
            new THREE.CircleGeometry(0.012 * scale, 8),
            SPECIAL_MATERIALS.specular
          );
          highlight2.position.set(-0.015 * scale, -0.02 * scale, 0.024);
          group.add(highlight2);

          // Micro sparkle
          const sparkle = new THREE.Mesh(
            new THREE.CircleGeometry(0.006 * scale, 6),
            SPECIAL_MATERIALS.specular
          );
          sparkle.position.set(0.04 * scale, 0.01 * scale, 0.024);
          group.add(sparkle);

          return group;
        }

        // Paw with pad indentations
        function createPaw(radius, material, padMaterial) {
          const group = new THREE.Group();

          // Main paw
          const paw = new THREE.Mesh(
            new THREE.SphereGeometry(radius, 16, 16),
            material
          );
          paw.scale.set(1, 0.6, 1.2);
          group.add(paw);

          // Main pad
          const mainPad = new THREE.Mesh(
            new THREE.SphereGeometry(radius * 0.5, 12, 12),
            padMaterial
          );
          mainPad.position.set(0, -radius * 0.2, radius * 0.3);
          mainPad.scale.set(1.2, 0.5, 1);
          group.add(mainPad);

          // Toe pads
          for (let i = -1; i <= 1; i++) {
            const toePad = new THREE.Mesh(
              new THREE.SphereGeometry(radius * 0.2, 8, 8),
              padMaterial
            );
            toePad.position.set(i * radius * 0.4, -radius * 0.2, radius * 0.7);
            group.add(toePad);
          }

          return group;
        }

        // ==========================================
        // PARTICLE SYSTEM FOR TRANSITIONS
        // ==========================================
        class ParticleBurst {
          constructor(scene) {
            this.scene = scene;
            this.particles = [];
            this.geometry = new THREE.SphereGeometry(0.03, 8, 8);
            this.materials = [
              new THREE.MeshBasicMaterial({ color: 0xffb7c5 }),
              new THREE.MeshBasicMaterial({ color: 0xadd8e6 }),
              new THREE.MeshBasicMaterial({ color: 0xfffacd }),
              new THREE.MeshBasicMaterial({ color: 0x98fb98 }),
              new THREE.MeshBasicMaterial({ color: 0xdda0dd }),
            ];
          }

          burst(position, count = 20) {
            for (let i = 0; i < count; i++) {
              const material =
                this.materials[
                  Math.floor(Math.random() * this.materials.length)
                ];
              const particle = new THREE.Mesh(this.geometry, material);
              particle.position.copy(position);
              particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,
                Math.random() * 0.1 + 0.05,
                (Math.random() - 0.5) * 0.15
              );
              particle.userData.life = 1.0;
              this.scene.add(particle);
              this.particles.push(particle);
            }
          }

          update(delta) {
            for (let i = this.particles.length - 1; i >= 0; i--) {
              const p = this.particles[i];
              p.position.add(p.userData.velocity);
              p.userData.velocity.y -= 0.005; // gravity
              p.userData.life -= delta * 2;
              p.scale.setScalar(p.userData.life);

              if (p.userData.life <= 0) {
                this.scene.remove(p);
                this.particles.splice(i, 1);
              }
            }
          }
        }

        const particleBurst = new ParticleBurst(scene);

        // ==========================================
        // ANIMAL MODEL FACTORY
        // ==========================================
        function createAnimalModel(type, colorOverride = null, options = {}) {
          // ===== Check for registered style builder first =====
          const styleBuilders = MODEL_STYLE_BUILDERS[currentModelStyleName];
          if (styleBuilders && styleBuilders[type]) {
            try {
              // Use the registered builder
              const animal = styleBuilders[type](type, colorOverride, options);
              if (animal && animal.isObject3D) {
                // Apply variant if needed
                if (options.variant) {
                  animal.userData.variant = options.variant;
                }
                return animal;
              }
            } catch (e) {
              console.error(
                `[Builder Error] ${currentModelStyleName}/${type}: ${e.message}`
              );
              // Fall through to legacy code or vinyl fallback
            }
          }

          // ===== Fallback: Try vinyl builder =====
          if (
            currentModelStyleName !== "vinyl" &&
            MODEL_STYLE_BUILDERS.vinyl &&
            MODEL_STYLE_BUILDERS.vinyl[type]
          ) {
            try {
              console.warn(`[Fallback] Using vinyl builder for ${type}`);
              const animal = MODEL_STYLE_BUILDERS.vinyl[type](
                type,
                colorOverride,
                options
              );
              if (animal && animal.isObject3D) {
                if (options.variant) {
                  animal.userData.variant = options.variant;
                }
                return animal;
              }
            } catch (e) {
              console.error(`[Fallback Error] vinyl/${type}: ${e.message}`);
            }
          }

          // ===== Legacy Code (Original implementation) =====
          const config = ANIMAL_CONFIG[type];
          const animal = new THREE.Group();
          animal.userData.type = type;
          animal.userData.animationData = {};
          animal.userData.modelStyle = currentModelStyle;

          // Use provided variant or select random one
          const forceVariant = options.variant;

          // Get current model style settings
          const modelStyle = MODEL_STYLES[currentModelStyle];
          const seg = modelStyle.segments;
          const { headScale, bodyScale } = modelStyle.proportions;

          // Helper to create styled geometry with proper segments
          function sphere(radius, widthSeg = seg, heightSeg = seg) {
            if (modelStyle.useBoxGeometry) {
              return new THREE.BoxGeometry(radius * 2, radius * 2, radius * 2);
            }
            const geom = new THREE.SphereGeometry(radius, widthSeg, heightSeg);
            if (modelStyle.flatShading) {
              geom.computeVertexNormals();
            }
            return geom;
          }

          function cylinder(radiusTop, radiusBottom, height, radialSeg = seg) {
            if (modelStyle.useBoxGeometry) {
              return new THREE.BoxGeometry(
                radiusTop * 2,
                height,
                radiusTop * 2
              );
            }
            const geom = new THREE.CylinderGeometry(
              radiusTop,
              radiusBottom,
              height,
              Math.max(4, radialSeg)
            );
            return geom;
          }

          function cone(radius, height, radialSeg = seg) {
            if (modelStyle.useBoxGeometry) {
              return new THREE.BoxGeometry(radius * 2, height, radius * 2);
            }
            return new THREE.ConeGeometry(
              radius,
              height,
              Math.max(4, radialSeg)
            );
          }

          // Get variant colors (use forced variant or random)
          let variantKey = forceVariant || animal.userData.variant;
          if (!variantKey) {
            // Random variant selection
            const variants = ANIMAL_VARIANTS[type];
            if (variants) {
              const variantKeys = Object.keys(variants);
              variantKey =
                variantKeys[Math.floor(Math.random() * variantKeys.length)];
            }
          }
          animal.userData.variant = variantKey;

          // Apply variant or config colors
          const variantColors = getVariantColors(type, variantKey);
          let primaryColor = variantColors
            ? variantColors.primary
            : config.primaryColor;
          let secondaryColor = variantColors
            ? variantColors.secondary
            : config.secondaryColor;
          let accentColor = variantColors
            ? variantColors.accent
            : config.accentColor;

          // Color palette override takes priority
          if (colorOverride && COLOR_PALETTES[colorOverride]) {
            primaryColor = COLOR_PALETTES[colorOverride].primary;
            secondaryColor = COLOR_PALETTES[colorOverride].secondary;
          }

          // Create materials with current art style
          const primaryMat = createStyledMaterial(primaryColor);
          const secondaryMat = createStyledMaterial(secondaryColor);
          const accentMat = createStyledMaterial(accentColor);

          // Apply flat shading if needed
          if (modelStyle.flatShading) {
            primaryMat.flatShading = true;
            secondaryMat.flatShading = true;
            accentMat.flatShading = true;
          }

          // ============ BUNNY - ENHANCED ============
          if (type === "bunny") {
            // Pear-shaped body (larger hindquarters) - uses style segments
            const bodyGeom = sphere(0.42 * bodyScale);
            const body = new THREE.Mesh(bodyGeom, primaryMat);
            body.scale.set(0.88, 1.12, 1.02);
            body.position.y = 0.45 * bodyScale;
            body.castShadow = true;
            animal.add(body);

            // Hindquarters bump - more pronounced
            const hindquarters = new THREE.Mesh(
              sphere(0.38 * bodyScale),
              primaryMat
            );
            hindquarters.position.set(0, 0.28 * bodyScale, -0.18);
            hindquarters.castShadow = true;
            animal.add(hindquarters);

            // Smooth body transition
            const bodyTransition = new THREE.Mesh(
              sphere(0.25 * bodyScale),
              primaryMat
            );
            bodyTransition.position.set(0, 0.75 * bodyScale, 0);
            animal.add(bodyTransition);

            // Head (slightly oval, wider at cheeks) - uses headScale
            const head = new THREE.Mesh(sphere(0.4 * headScale), primaryMat);
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 0.9 + 0.18 * headScale;
            head.castShadow = true;
            animal.add(head);

            // Enhanced cheeks with subtle blush
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 20, 20),
                primaryMat
              );
              cheek.position.set(side * 0.3, 0.94, 0.16);
              animal.add(cheek);

              // Blush spots
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.35,
                  roughness: 0.6,
                })
              );
              blush.position.set(side * 0.34, 0.92, 0.28);
              blush.rotation.y = side * 0.3;
              animal.add(blush);
            });

            // Subtle eyebrow ridges
            [-1, 1].forEach((side) => {
              const brow = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.02, 0.08, 6, 8),
                primaryMat
              );
              brow.position.set(side * 0.16, 1.2, 0.32);
              brow.rotation.z = side * -0.3;
              brow.rotation.x = 0.2;
              animal.add(brow);
            });

            // Enhanced paddle-shaped ears (thicker, more teardrop)
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              const earOuter = new THREE.Group();

              // Main ear body - thicker elliptical paddle
              const earGeom = new THREE.CapsuleGeometry(0.12, 0.75, 12, 20);
              const ear = new THREE.Mesh(earGeom, primaryMat);
              ear.scale.set(1.15, 1, 0.45);
              earOuter.add(ear);

              // Ear edge rim for thickness
              const earRim = new THREE.Mesh(
                new THREE.TorusGeometry(0.085, 0.025, 8, 24, Math.PI * 1.6),
                primaryMat
              );
              earRim.position.set(0, 0.1, 0);
              earRim.rotation.x = Math.PI / 2;
              earRim.rotation.z = Math.PI * 0.7;
              earOuter.add(earRim);

              // Inner ear - softer pink
              const innerGeom = new THREE.CapsuleGeometry(0.07, 0.58, 10, 16);
              const inner = new THREE.Mesh(innerGeom, secondaryMat);
              inner.scale.set(1.1, 1, 0.32);
              inner.position.z = 0.025;
              earOuter.add(inner);

              // Ear tip (more rounded)
              const tip = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 16, 16),
                primaryMat
              );
              tip.scale.set(1.15, 0.85, 0.45);
              tip.position.y = 0.42;
              earOuter.add(tip);

              earOuter.position.set(side * 0.2, 1.55, -0.02);
              earOuter.rotation.z = side * -0.18;
              earOuter.rotation.x = -0.08;
              earGroup.add(earOuter);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Eyes with custom iris color
            [-1, 1].forEach((side) => {
              const eye = createEye(0.9, false, { irisColor: 0x4a3020 });
              eye.position.set(side * 0.19, 1.12, 0.34);
              animal.add(eye);
            });

            // Enhanced Y-shaped nose with nostrils
            const nose = new THREE.Group();
            const noseTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 20, 20),
              getMaterial(0xffb6c1)
            );
            noseTop.scale.set(1.35, 0.72, 1);
            nose.add(noseTop);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.014, 10, 10),
                getMaterial(0xc87090)
              );
              nostril.position.set(side * 0.02, -0.006, 0.025);
              nose.add(nostril);
            });

            // Nose line going down (philtrum)
            const noseLine = new THREE.Mesh(
              new THREE.CylinderGeometry(0.009, 0.014, 0.055, 10),
              getMaterial(0xffb6c1)
            );
            noseLine.position.y = -0.038;
            nose.add(noseLine);

            nose.position.set(0, 1.02, 0.4);
            animal.userData.animationData.nose = nose;
            animal.add(nose);

            // Whiskers (3 per side) - slightly curved
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.001, 0.25, 6),
                  getMaterial(0xffffff)
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.28;
                whisker.rotation.x = (i - 1) * 0.12;
                whisker.position.set(side * 0.2, 1.0 + (i - 1) * 0.028, 0.34);
                animal.add(whisker);
              }
            });

            // Enhanced fluffy tail with color variation
            const tailGroup = new THREE.Group();
            // Core
            const tailCore = new THREE.Mesh(
              new THREE.SphereGeometry(0.11, 20, 20),
              primaryMat
            );
            tailGroup.add(tailCore);

            // Fluffy outer layers with slight color variation
            for (let i = 0; i < 12; i++) {
              const puffSize = 0.055 + Math.random() * 0.025;
              const puff = new THREE.Mesh(
                new THREE.SphereGeometry(puffSize, 12, 12),
                i % 3 === 0 ? secondaryMat : primaryMat
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.065 + Math.random() * 0.02;
              puff.position.set(
                Math.cos(angle) * radius,
                Math.sin(angle * 0.6) * 0.05 + (Math.random() - 0.5) * 0.02,
                Math.sin(angle) * radius
              );
              tailGroup.add(puff);
            }
            tailGroup.position.set(0, 0.5, -0.4);
            animal.add(tailGroup);

            // Legs - back legs larger than front
            // Front legs with paw detail
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.075, 0.16, 10, 14),
                primaryMat
              );
              frontLeg.position.set(side * 0.22, 0.16, 0.22);
              animal.add(frontLeg);

              // Front paw
              const frontPaw = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 12, 12),
                primaryMat
              );
              frontPaw.scale.set(1, 0.6, 1.3);
              frontPaw.position.set(side * 0.22, 0.04, 0.28);
              animal.add(frontPaw);
            });

            // Back legs (much larger) with better definition
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 16, 16),
                primaryMat
              );
              thigh.scale.set(0.9, 1.1, 1);
              thigh.position.set(side * 0.24, 0.25, -0.12);
              animal.add(thigh);

              const backLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.22, 10, 14),
                primaryMat
              );
              backLeg.position.set(side * 0.24, 0.14, -0.08);
              backLeg.rotation.x = 0.35;
              animal.add(backLeg);

              // Back foot - elongated bunny foot
              const backFoot = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.085, 0.2, 10, 14),
                primaryMat
              );
              backFoot.rotation.x = Math.PI / 2;
              backFoot.position.set(side * 0.24, 0.05, 0.08);
              animal.add(backFoot);

              // Foot pad hint
              const footPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 10, 10),
                secondaryMat
              );
              footPad.scale.set(1.2, 0.5, 1.5);
              footPad.position.set(side * 0.24, 0.02, 0.12);
              animal.add(footPad);
            });
          }

          // ============ BEAR - ENHANCED ============
          else if (type === "bear") {
            // Barrel-shaped torso (1.5x wider than tall)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.58, 32, 32),
              primaryMat
            );
            body.scale.set(1.32, 1.0, 1.15);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Enhanced shoulder hump - more prominent (30% larger)
            const hump = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 20, 20),
              primaryMat
            );
            hump.scale.set(1.2, 0.9, 1);
            hump.position.set(0, 0.92, -0.12);
            animal.add(hump);

            // Secondary hump for smooth transition
            const hump2 = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 16, 16),
              primaryMat
            );
            hump2.position.set(0, 1.02, -0.05);
            animal.add(hump2);

            // Belly patch - rounder
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.0, 1.15, 0.52);
            belly.position.set(0, 0.48, 0.28);
            animal.add(belly);

            // Wide, round head with pronounced forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            head.scale.set(1.12, 1.0, 1.0);
            head.position.y = 1.22;
            head.castShadow = true;
            animal.add(head);

            // Cheek puffs for rounder face
            [-1, 1].forEach((side) => {
              const cheek = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 16, 16),
                primaryMat
              );
              cheek.position.set(side * 0.32, 1.12, 0.22);
              animal.add(cheek);
            });

            // Forehead bulge - more subtle
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.22, 18, 18),
              primaryMat
            );
            forehead.position.set(0, 1.48, 0.12);
            animal.add(forehead);

            // Smooth blended muzzle (no box geometry)
            const muzzleBase = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            muzzleBase.scale.set(1.1, 0.85, 0.9);
            muzzleBase.position.set(0, 1.1, 0.42);
            animal.add(muzzleBase);

            const muzzleFront = new THREE.Mesh(
              new THREE.SphereGeometry(0.14, 18, 18),
              secondaryMat
            );
            muzzleFront.scale.set(1.0, 0.78, 0.85);
            muzzleFront.position.set(0, 1.1, 0.52);
            animal.add(muzzleFront);

            // Muzzle bridge for smooth transition
            const muzzleBridge = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.08, 0.12, 10, 12),
              secondaryMat
            );
            muzzleBridge.rotation.x = Math.PI / 2;
            muzzleBridge.scale.set(1.2, 1, 0.8);
            muzzleBridge.position.set(0, 1.12, 0.38);
            animal.add(muzzleBridge);

            // Enhanced nose with nostrils
            const nose = new THREE.Group();
            const noseMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.09, 14, 14),
              accentMat
            );
            noseMain.scale.set(1.35, 0.88, 1.0);
            nose.add(noseMain);

            // Nostril indentations
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.04, -0.01, 0.04);
              nose.add(nostril);
            });
            nose.position.set(0, 1.16, 0.58);
            animal.add(nose);

            // Enhanced ears at 10 and 2 o'clock with depth
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();
              const angle = (side * Math.PI) / 4.2;
              const earRadius = 0.48;

              // Main ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 18, 18),
                primaryMat
              );
              earGroup.add(ear);

              // Ear inner recess (darker)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                secondaryMat
              );
              innerEar.position.z = 0.08;
              earGroup.add(innerEar);

              // Ear cavity shadow
              const earCavity = new THREE.Mesh(
                new THREE.CircleGeometry(0.06, 12),
                new THREE.MeshBasicMaterial({
                  color: 0x3a2a20,
                  transparent: true,
                  opacity: 0.3,
                })
              );
              earCavity.position.z = 0.085;
              earGroup.add(earCavity);
              // FIXED: Simple ear position at 10 and 2 o'clock
              earGroup.position.set(side * 0.32, 1.52, 0.05);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Eyes - slightly lower and forward
            [-1, 1].forEach((side) => {
              const eye = createEye(0.7, false, { irisColor: 0x2a1810 });
              eye.position.set(side * 0.22, 1.26, 0.4);
              animal.add(eye);
            });

            // Thick plantigrade legs with enhanced paw pads and curved claws
            const legPositions = [
              { x: -0.38, z: 0.22, front: true },
              { x: 0.38, z: 0.22, front: true },
              { x: -0.32, z: -0.28, front: false },
              { x: 0.32, z: -0.28, front: false },
            ];

            legPositions.forEach((pos) => {
              // Thicker legs with slight curve
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.4, 18),
                primaryMat
              );
              leg.position.set(pos.x, 0.2, pos.z);
              animal.add(leg);

              // Knee/joint bulge
              const knee = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 12, 12),
                primaryMat
              );
              knee.position.set(pos.x, 0.32, pos.z);
              animal.add(knee);

              // Enhanced paw
              const paw = createPaw(0.15, primaryMat, secondaryMat);
              paw.position.set(pos.x, 0.02, pos.z + 0.06);
              animal.add(paw);

              // 5 Curved claws per paw
              for (let c = -2; c <= 2; c++) {
                const clawGroup = new THREE.Group();
                const claw = new THREE.Mesh(
                  new THREE.ConeGeometry(0.02, 0.07, 10),
                  accentMat
                );
                claw.position.y = 0.035;
                clawGroup.add(claw);

                // Claw curve
                clawGroup.rotation.x = -Math.PI / 2 - 0.35;
                clawGroup.rotation.z = c * 0.08;
                clawGroup.position.set(pos.x + c * 0.038, 0.01, pos.z + 0.2);
                animal.add(clawGroup);
              }
            });

            // Head for animation
            animal.userData.animationData.head = head;
          }

          // ============ PENGUIN - CARTOON REDESIGN ============
          else if (type === "penguin") {
            // Rounded egg-shaped body (black outer shell)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.52, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.95);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // LARGE WHITE CIRCULAR BELLY (Center of body - like reference!)
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.44, 32, 32),
              secondaryMat
            );
            // distinct circular shape centered on body
            belly.scale.set(0.95, 1.0, 0.5);
            belly.position.set(0, 0.55, 0.22);
            animal.add(belly);

            // White chest connector (smooth blend to face)
            const chestTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 24, 24),
              secondaryMat
            );
            chestTop.scale.set(0.9, 0.7, 0.4);
            chestTop.position.set(0, 0.88, 0.24);
            animal.add(chestTop);

            // Round head attached to body (black)
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            head.position.y = 1.1;
            animal.add(head);

            // HEART-SHAPED WHITE FACE PATCH (key feature from reference!)
            // Create heart shape using two overlapping circles and a triangle bottom
            const faceGroup = new THREE.Group();

            // Left circle of heart
            const heartLeft = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartLeft.scale.set(1, 1, 0.4);
            heartLeft.position.set(-0.1, 0.08, 0);
            faceGroup.add(heartLeft);

            // Right circle of heart
            const heartRight = new THREE.Mesh(
              new THREE.SphereGeometry(0.18, 20, 20),
              secondaryMat
            );
            heartRight.scale.set(1, 1, 0.4);
            heartRight.position.set(0.1, 0.08, 0);
            faceGroup.add(heartRight);

            // Center fill for heart
            const heartCenter = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              secondaryMat
            );
            heartCenter.scale.set(1.4, 1, 0.4);
            heartCenter.position.set(0, 0.02, 0);
            faceGroup.add(heartCenter);

            // Bottom point of heart (chin area)
            const heartBottom = new THREE.Mesh(
              new THREE.ConeGeometry(0.16, 0.22, 16),
              secondaryMat
            );
            heartBottom.scale.set(1, 1, 0.4);
            heartBottom.rotation.x = Math.PI;
            heartBottom.position.set(0, -0.1, 0);
            faceGroup.add(heartBottom);

            faceGroup.position.set(0, 1.08, 0.28);
            animal.add(faceGroup);

            // LARGE CARTOON EYES (like reference image)
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.11, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Large black pupil (cartoon style - fills most of eye)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.075, 18, 18),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.04;
              eyeGroup.add(pupil);

              // Large white highlight (cartoon shine)
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.035, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025 * side, 0.03, 0.08);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.02 * side, -0.02, 0.08);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.12, 1.15, 0.32);
              animal.add(eyeGroup);
            });

            // PINK BLUSH MARKS (like reference image!)
            [-1, 1].forEach((side) => {
              const blush = new THREE.Mesh(
                new THREE.CircleGeometry(0.05, 16),
                new THREE.MeshPhysicalMaterial({
                  color: 0xffb6c1,
                  transparent: true,
                  opacity: 0.6,
                  roughness: 0.8,
                })
              );
              blush.position.set(side * 0.18, 1.02, 0.35);
              animal.add(blush);
            });

            // CUTE ROUNDED ORANGE BEAK (like reference)
            const beakGroup = new THREE.Group();

            // Main beak body - rounded capsule shape
            const beakMain = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0xf5a623)
            );
            beakMain.scale.set(1.3, 0.8, 1.0);
            beakGroup.add(beakMain);

            // Slight bump on top for cute look
            const beakTop = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xf5a623)
            );
            beakTop.position.set(0, 0.02, -0.02);
            beakGroup.add(beakTop);

            beakGroup.position.set(0, 0.98, 0.4);
            animal.add(beakGroup);

            // Small flipper wings (like reference - held out slightly)
            [-1, 1].forEach((side) => {
              const flipperGroup = new THREE.Group();

              // Main flipper shape
              const flipper = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.28, 12, 18),
                primaryMat
              );
              flipper.scale.set(1.1, 1, 0.4);
              flipperGroup.add(flipper);

              // Flipper tip
              const flipperTip = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 12, 12),
                primaryMat
              );
              flipperTip.scale.set(1, 0.8, 0.4);
              flipperTip.position.y = -0.16;
              flipperGroup.add(flipperTip);

              flipperGroup.position.set(side * 0.48, 0.55, 0.05);
              flipperGroup.rotation.z = side * 0.45;
              animal.add(flipperGroup);
            });

            // Cute orange webbed feet
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Main foot oval
              const footBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.09, 14, 14),
                getMaterial(0xf5a623)
              );
              footBase.scale.set(1.3, 0.3, 1.6);
              footGroup.add(footBase);

              // Three rounded toes
              for (let i = -1; i <= 1; i++) {
                const toe = new THREE.Mesh(
                  new THREE.SphereGeometry(0.035, 10, 10),
                  getMaterial(0xf5a623)
                );
                toe.scale.set(1, 0.5, 1.5);
                toe.position.set(i * 0.05, 0, 0.1);
                footGroup.add(toe);
              }

              footGroup.position.set(side * 0.18, 0.02, 0.12);
              animal.add(footGroup);
            });

            // Animation reference
            animal.userData.animationData.body = animal;
          }

          // ============ FOX - ENHANCED ============
          else if (type === "fox") {
            // Slender, agile body
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.3, 0.52, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.88);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Enhanced chest fluff - more prominent
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.92, 1.15, 0.65);
            chest.position.set(0, 0.58, 0.2);
            animal.add(chest);

            // Additional chest fluff layers
            const chestFluff = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 14, 14),
              secondaryMat
            );
            chestFluff.position.set(0, 0.72, 0.18);
            animal.add(chestFluff);

            // Diamond/triangular head - slightly larger
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.34, 32, 32),
              primaryMat
            );
            head.scale.set(1.02, 0.92, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // White cheek patches (fox marking)
            [-1, 1].forEach((side) => {
              const cheekPatch = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              cheekPatch.scale.set(1.2, 0.9, 0.5);
              cheekPatch.position.set(side * 0.18, 0.95, 0.22);
              animal.add(cheekPatch);
            });

            // Enhanced long pointed snout with gradient
            const snoutBase = new THREE.Mesh(
              new THREE.ConeGeometry(0.14, 0.25, 18),
              primaryMat
            );
            snoutBase.rotation.x = Math.PI / 2;
            snoutBase.position.set(0, 0.94, 0.32);
            animal.add(snoutBase);

            const snoutTip = new THREE.Mesh(
              new THREE.ConeGeometry(0.1, 0.2, 16),
              secondaryMat
            );
            snoutTip.rotation.x = Math.PI / 2;
            snoutTip.position.set(0, 0.92, 0.45);
            animal.add(snoutTip);

            // Nose with nostrils
            const noseGroup = new THREE.Group();
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.045, 14, 14),
              accentMat
            );
            noseGroup.add(nose);

            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                getMaterial(0x0a0a0a)
              );
              nostril.position.set(side * 0.02, -0.01, 0.02);
              noseGroup.add(nostril);
            });
            noseGroup.position.set(0, 0.92, 0.58);
            animal.add(noseGroup);

            // Facial tear lines (dark markings from eye to snout)
            [-1, 1].forEach((side) => {
              const tearLine = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.012, 0.15, 6, 10),
                getMaterial(0x2a1810)
              );
              tearLine.rotation.x = 0.8;
              tearLine.rotation.z = side * 0.25;
              tearLine.position.set(side * 0.1, 0.98, 0.32);
              animal.add(tearLine);
            });

            // Enhanced triangular ears with fur tufts
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.13, 0.42, 5),
                primaryMat
              );
              ear.position.y = 0.16;
              earGroup.add(ear);

              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.32, 5),
                secondaryMat
              );
              innerEar.position.set(0, 0.13, 0.035);
              earGroup.add(innerEar);

              // Black ear tips
              const earTip = new THREE.Mesh(
                new THREE.ConeGeometry(0.06, 0.1, 5),
                accentMat
              );
              earTip.position.y = 0.35;
              earGroup.add(earTip);

              earGroup.position.set(side * 0.2, 1.28, -0.02);
              earGroup.rotation.z = side * -0.15;
              animal.add(earGroup);
            });

            // Slit pupil eyes for fox
            [-1, 1].forEach((side) => {
              const eye = createEye(0.82, true, { irisColor: 0xc4a040 });
              eye.position.set(side * 0.15, 1.06, 0.3);
              animal.add(eye);
            });

            // Enhanced bushy tail (12 segments + fur overlays)
            const tailGroup = new THREE.Group();

            const tailSegments = 12;
            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseSize = 0.15 - t * 0.07;
              const isWhiteTip = t >= 0.72;

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseSize, 14, 12),
                isWhiteTip ? secondaryMat : primaryMat
              );

              const curve = Math.sin(t * Math.PI * 0.6) * 0.38;
              segment.position.y = i * 0.085;
              segment.position.z = -0.12 - curve;
              segment.position.x = Math.sin(t * Math.PI * 0.3) * 0.055;
              tailGroup.add(segment);

              if (i % 2 === 0 && i < tailSegments - 2) {
                for (let f = 0; f < 5; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(
                      baseSize * 0.55 + Math.random() * 0.02,
                      8,
                      8
                    ),
                    isWhiteTip ? secondaryMat : primaryMat
                  );
                  const angle = (f / 5) * Math.PI * 2 + Math.random() * 0.3;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseSize * 0.72,
                    segment.position.y + (Math.random() - 0.5) * 0.035,
                    segment.position.z + Math.sin(angle) * baseSize * 0.52
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.4, -0.2);
            tailGroup.rotation.x = -0.28;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Thin black "sock" legs with better definition
            const legPositions = [
              { x: -0.16, z: 0.16 },
              { x: 0.16, z: 0.16 },
              { x: -0.13, z: -0.2 },
              { x: 0.13, z: -0.2 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.32, 10, 14),
                accentMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              // Dainty paw with toe details
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                accentMat
              );
              paw.scale.set(1, 0.58, 1.35);
              paw.position.set(pos.x, 0.03, pos.z + 0.04);
              animal.add(paw);
            });
          }

          // ============ ELEPHANT ============
          else if (type === "elephant") {
            // Massive barrel body with saggy belly
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.6, 32, 32),
              primaryMat
            );
            body.scale.set(1.1, 0.9, 1.3);
            body.position.y = 0.65;
            body.castShadow = true;
            animal.add(body);

            // Saggy belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              primaryMat
            );
            belly.position.set(0, 0.4, 0);
            animal.add(belly);

            // Domed head with forehead
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.45, 32, 32),
              primaryMat
            );
            head.scale.set(1.0, 1.1, 1.0);
            head.position.set(0, 1.25, 0.25);
            animal.add(head);

            // Domed forehead
            const forehead = new THREE.Mesh(
              new THREE.SphereGeometry(0.25, 16, 16),
              primaryMat
            );
            forehead.position.set(0, 1.55, 0.2);
            animal.add(forehead);

            // LARGE fan-shaped ears (60% of body height) - FIXED visibility
            [-1, 1].forEach((side) => {
              const earGroup = new THREE.Group();

              // Main ear shape - using flattened sphere for 3D visibility
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.45,
                  24,
                  16,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.6
                ),
                primaryMat
              );
              ear.scale.set(1, 1.2, 0.15); // Wide, tall, thin
              ear.rotation.y = side * 0.2;
              earGroup.add(ear);

              // Inner ear (pinkish)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(
                  0.35,
                  20,
                  12,
                  0,
                  Math.PI * 2,
                  0,
                  Math.PI * 0.5
                ),
                getMaterial(0xd4a5a5) // Pink inner ear
              );
              innerEar.scale.set(0.9, 1, 0.1);
              innerEar.position.set(side * -0.02, -0.05, 0.05);
              innerEar.rotation.y = side * 0.2;
              earGroup.add(innerEar);

              earGroup.position.set(side * 0.55, 1.25, 0.1);
              earGroup.rotation.z = side * 0.15;
              animal.add(earGroup);
            });

            // Smooth trunk using TubeGeometry with natural S-curve
            const trunkGroup = new THREE.Group();

            // Define trunk path as smooth S-curve
            const trunkPath = new THREE.CatmullRomCurve3([
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(0, -0.15, 0.08),
              new THREE.Vector3(0, -0.35, 0.18),
              new THREE.Vector3(0, -0.55, 0.25),
              new THREE.Vector3(0, -0.75, 0.2),
              new THREE.Vector3(0, -0.9, 0.1),
            ]);

            // Create tapered tube geometry
            const radiusSegments = 8;
            const tubularSegments = 24;
            const trunkRadii = [];
            for (let i = 0; i <= tubularSegments; i++) {
              const t = i / tubularSegments;
              trunkRadii.push(0.12 - t * 0.08); // Taper from 0.12 to 0.04
            }

            // Note: THREE.TubeGeometry doesn't support variable radius,
            // so we use multiple scaled torus/cylinder sections for smooth look
            const trunkSegments = 16;
            for (let i = 0; i < trunkSegments; i++) {
              const t = i / (trunkSegments - 1);
              const radius = 0.11 - t * 0.07;
              const point = trunkPath.getPointAt(t);

              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 16, 12),
                primaryMat
              );
              segment.scale.set(1, 0.8, 1); // Slightly flatten for organic look
              segment.position.copy(point);
              trunkGroup.add(segment);
            }

            // Trunk tip with nostril openings
            const tipPoint = trunkPath.getPointAt(1);
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.TorusGeometry(0.02, 0.008, 8, 12),
                getMaterial(0x5a6a7a) // Darker for depth
              );
              nostril.position.set(
                side * 0.025,
                tipPoint.y - 0.02,
                tipPoint.z + 0.03
              );
              nostril.rotation.y = Math.PI / 2;
              trunkGroup.add(nostril);
            });

            trunkGroup.position.set(0, 1.15, 0.55);
            animal.userData.animationData.trunk = trunkGroup;
            animal.add(trunkGroup);

            // Curved tusks (outward and upward)
            [-1, 1].forEach((side) => {
              const tuskGroup = new THREE.Group();

              for (let i = 0; i < 5; i++) {
                const t = i / 4;
                const tuskSeg = new THREE.Mesh(
                  new THREE.SphereGeometry(0.04 - t * 0.02, 8, 8),
                  secondaryMat
                );
                tuskSeg.position.x = side * t * 0.1;
                tuskSeg.position.y = -t * 0.1 + t * t * 0.15; // Curve up
                tuskSeg.position.z = t * 0.08;
                tuskGroup.add(tuskSeg);
              }

              tuskGroup.position.set(side * 0.15, 1.0, 0.6);
              animal.add(tuskGroup);
            });

            // Enhanced visible eyes with eyelid ridges
            [-1, 1].forEach((side) => {
              // Eyelid ridge/brow for definition
              const browRidge = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.1, 8, 12),
                primaryMat
              );
              browRidge.position.set(side * 0.28, 1.42, 0.48);
              browRidge.rotation.z = side * 0.3;
              animal.add(browRidge);

              // Eye socket depression
              const eyeSocket = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 12, 12),
                getMaterial(0x5a6a7a)
              );
              eyeSocket.scale.set(1.2, 1, 0.6);
              eyeSocket.position.set(side * 0.28, 1.35, 0.48);
              animal.add(eyeSocket);

              // Larger, more visible eye
              const eye = createEye(0.75, false, { irisColor: 0x3a2a20 });
              eye.position.set(side * 0.28, 1.35, 0.52);
              animal.add(eye);
            });

            // Column-like legs with toenails
            const legPositions = [
              { x: -0.35, z: 0.35 },
              { x: 0.35, z: 0.35 },
              { x: -0.3, z: -0.35 },
              { x: 0.3, z: -0.35 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CylinderGeometry(0.14, 0.16, 0.5, 16),
                primaryMat
              );
              leg.position.set(pos.x, 0.25, pos.z);
              animal.add(leg);

              // Foot
              const foot = new THREE.Mesh(
                new THREE.CylinderGeometry(0.16, 0.18, 0.08, 16),
                primaryMat
              );
              foot.position.set(pos.x, 0.04, pos.z);
              animal.add(foot);

              // Toenails
              for (let i = -1; i <= 1; i++) {
                const nail = new THREE.Mesh(
                  new THREE.SphereGeometry(0.03, 8, 8),
                  secondaryMat
                );
                nail.position.set(pos.x + i * 0.06, 0.02, pos.z + 0.15);
                animal.add(nail);
              }
            });

            // Thin tail with tuft
            const tailGroup = new THREE.Group();

            const tailBase = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.03, 0.4, 8),
              primaryMat
            );
            tailBase.position.y = -0.15;
            tailGroup.add(tailBase);

            const tuft = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 12, 12),
              primaryMat
            );
            tuft.scale.set(0.8, 1.5, 0.8);
            tuft.position.y = -0.4;
            tailGroup.add(tuft);

            tailGroup.position.set(0, 0.5, -0.65);
            tailGroup.rotation.x = 0.3;
            animal.add(tailGroup);
          }

          // ============ CAT - ENHANCED ============
          else if (type === "cat") {
            // Sleek body - slightly more elegant
            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.32, 0.48, 14, 22),
              primaryMat
            );
            body.scale.set(1, 1, 0.92);
            body.position.y = 0.52;
            body.castShadow = true;
            animal.add(body);

            // Fluffy chest
            const chest = new THREE.Mesh(
              new THREE.SphereGeometry(0.24, 18, 18),
              secondaryMat
            );
            chest.scale.set(0.95, 1.1, 0.65);
            chest.position.set(0, 0.58, 0.17);
            animal.add(chest);

            // Head with better cheekbone structure
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.08, 1.0, 0.96);
            head.position.y = 1.02;
            animal.add(head);

            // Cheekbones for cat-like face
            [-1, 1].forEach((side) => {
              const cheekbone = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                primaryMat
              );
              cheekbone.scale.set(1.2, 0.8, 0.6);
              cheekbone.position.set(side * 0.2, 0.95, 0.18);
              animal.add(cheekbone);
            });

            // Enhanced muzzle with whisker pads
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.13, 18, 18),
              secondaryMat
            );
            muzzle.scale.set(1, 0.72, 0.82);
            muzzle.position.set(0, 0.93, 0.27);
            animal.add(muzzle);

            // Whisker pads (puffy areas on either side of nose)
            [-1, 1].forEach((side) => {
              const whiskerPad = new THREE.Mesh(
                new THREE.SphereGeometry(0.055, 14, 14),
                secondaryMat
              );
              whiskerPad.scale.set(1.2, 0.9, 1);
              whiskerPad.position.set(side * 0.07, 0.91, 0.32);
              animal.add(whiskerPad);
            });

            // Pink nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 14, 14),
              getMaterial(0xffb6c1)
            );
            nose.scale.set(1.1, 0.85, 1);
            nose.position.set(0, 0.96, 0.35);
            animal.add(nose);

            // Enhanced whiskers (curved)
            [-1, 1].forEach((side) => {
              for (let i = 0; i < 3; i++) {
                const whisker = new THREE.Mesh(
                  new THREE.CylinderGeometry(0.003, 0.002, 0.22, 6),
                  secondaryMat
                );
                whisker.rotation.z = (Math.PI / 2) * side;
                whisker.rotation.y = (i - 1) * 0.22;
                whisker.rotation.x = (i - 1) * 0.08;
                whisker.position.set(side * 0.18, 0.93 + (i - 1) * 0.032, 0.28);
                animal.add(whisker);
              }
            });

            // Enhanced pointed ears with fur tufts
            const earGroup = new THREE.Group();
            [-1, 1].forEach((side) => {
              // Main ear
              const ear = new THREE.Mesh(
                new THREE.ConeGeometry(0.11, 0.24, 5),
                primaryMat
              );
              ear.position.set(side * 0.2, 1.32, 0);
              ear.rotation.z = side * -0.18;
              earGroup.add(ear);

              // Inner pink ear
              const innerEar = new THREE.Mesh(
                new THREE.ConeGeometry(0.065, 0.17, 5),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.2, 1.3, 0.035);
              innerEar.rotation.z = side * -0.18;
              earGroup.add(innerEar);

              // Fur tuft at ear tip
              const earTuft = new THREE.Mesh(
                new THREE.ConeGeometry(0.025, 0.06, 4),
                primaryMat
              );
              earTuft.position.set(side * 0.2, 1.45, 0);
              earTuft.rotation.z = side * -0.2;
              earGroup.add(earTuft);
            });
            animal.userData.animationData.ears = earGroup;
            animal.add(earGroup);

            // Enhanced slit pupil eyes with green/amber iris
            [-1, 1].forEach((side) => {
              const eye = createEye(0.92, true, { irisColor: 0x7cb342 });
              eye.position.set(side * 0.14, 1.06, 0.27);
              animal.add(eye);
            });

            // Enhanced long curved tail (12 segments + fur)
            const tailGroup = new THREE.Group();
            const tailSegments = 14;

            for (let i = 0; i < tailSegments; i++) {
              const t = i / (tailSegments - 1);
              const baseRadius = 0.058 - t * 0.028;
              const segment = new THREE.Mesh(
                new THREE.SphereGeometry(baseRadius, 12, 10),
                primaryMat
              );
              segment.position.y = i * 0.072;
              segment.position.z = -Math.sin(t * Math.PI) * 0.2;
              segment.position.x = Math.sin(t * Math.PI * 0.55) * 0.13;
              tailGroup.add(segment);

              if (i % 3 === 0 && i < tailSegments - 1) {
                for (let f = 0; f < 3; f++) {
                  const fur = new THREE.Mesh(
                    new THREE.SphereGeometry(baseRadius * 0.52, 6, 6),
                    primaryMat
                  );
                  const angle = (f / 3) * Math.PI * 2;
                  fur.position.set(
                    segment.position.x + Math.cos(angle) * baseRadius * 0.82,
                    segment.position.y,
                    segment.position.z + Math.sin(angle) * baseRadius * 0.62
                  );
                  tailGroup.add(fur);
                }
              }
            }

            tailGroup.position.set(0, 0.5, -0.24);
            tailGroup.rotation.x = -0.58;
            animal.userData.animationData.tail = tailGroup;
            animal.add(tailGroup);

            // Enhanced legs with paw pads
            const legPositions = [
              { x: -0.16, z: 0.14 },
              { x: 0.16, z: 0.14 },
              { x: -0.13, z: -0.16 },
              { x: 0.13, z: -0.16 },
            ];

            legPositions.forEach((pos) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.065, 0.27, 10, 14),
                primaryMat
              );
              leg.position.set(pos.x, 0.16, pos.z);
              animal.add(leg);

              const paw = createPaw(0.065, primaryMat, getMaterial(0xffb6c1));
              paw.position.set(pos.x, 0.02, pos.z + 0.025);
              animal.add(paw);
            });
          }

          // ============ OWL ============
          else if (type === "owl") {
            // Round body (1:1 with head)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.position.y = 0.5;
            body.castShadow = true;
            animal.add(body);

            // Belly feathers (layered discs)
            for (let i = 0; i < 4; i++) {
              const featherRow = new THREE.Mesh(
                new THREE.TorusGeometry(0.25 - i * 0.04, 0.03, 8, 24),
                secondaryMat
              );
              featherRow.rotation.x = Math.PI / 2;
              featherRow.position.set(0, 0.6 - i * 0.1, 0.2);
              animal.add(featherRow);
            }

            // Large round head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.38, 32, 32),
              primaryMat
            );
            head.position.y = 1.05;
            animal.userData.animationData.head = head;
            animal.add(head);

            // Facial disc
            const facialDisc = new THREE.Mesh(
              new THREE.CircleGeometry(0.35, 32),
              secondaryMat
            );
            facialDisc.position.set(0, 1.05, 0.2);
            animal.add(facialDisc);

            // HUGE forward-facing eyes - FIXED position forward
            [-1, 1].forEach((side) => {
              const eye = createOwlEye(1.5);
              eye.position.set(side * 0.14, 1.1, 0.38);
              animal.add(eye);
            });

            // Small hooked beak
            const beak = new THREE.Mesh(
              new THREE.ConeGeometry(0.05, 0.1, 8),
              getMaterial(0x8b7355)
            );
            beak.rotation.x = Math.PI / 2 + 0.3;
            beak.position.set(0, 0.98, 0.32);
            animal.add(beak);

            // Ear tufts - ENLARGED for visibility
            [-1, 1].forEach((side) => {
              const tuft = new THREE.Group();

              // More feathers, larger sizes
              for (let i = 0; i < 4; i++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.04, 0.2 - i * 0.03, 6),
                  primaryMat
                );
                feather.position.set(i * side * 0.025, i * 0.05, 0);
                tuft.add(feather);
              }

              tuft.position.set(side * 0.28, 1.42, -0.02);
              tuft.rotation.z = side * -0.35;
              animal.add(tuft);
            });

            // Enhanced wings with feather details
            [-1, 1].forEach((side) => {
              const wingGroup = new THREE.Group();

              // Main wing body
              const wingBase = new THREE.Mesh(
                new THREE.SphereGeometry(0.25, 16, 16),
                primaryMat
              );
              wingBase.scale.set(0.4, 0.8, 0.6);
              wingGroup.add(wingBase);

              // Feather layers (3 rows)
              for (let row = 0; row < 3; row++) {
                const featherRow = new THREE.Mesh(
                  new THREE.TorusGeometry(
                    0.12 - row * 0.025,
                    0.02,
                    6,
                    12,
                    Math.PI * 0.8
                  ),
                  getMaterial(row === 0 ? 0x654321 : config.primaryColor)
                );
                featherRow.rotation.set(0, (side * Math.PI) / 2, Math.PI);
                featherRow.position.set(side * 0.02, -0.1 - row * 0.08, 0.05);
                wingGroup.add(featherRow);
              }

              // Primary flight feathers at tip (5 feathers)
              for (let f = 0; f < 5; f++) {
                const feather = new THREE.Mesh(
                  new THREE.ConeGeometry(0.015, 0.12, 4),
                  getMaterial(f === 0 ? 0x4a3728 : config.primaryColor)
                );
                feather.rotation.z = side * (0.3 + f * 0.15);
                feather.rotation.x = 0.2;
                feather.position.set(
                  side * (0.05 + f * 0.02),
                  -0.35 + f * 0.03,
                  0.1 - f * 0.02
                );
                wingGroup.add(feather);
              }

              wingGroup.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wingGroup);
            });

            // Feet/talons
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Three forward talons
              for (let i = -1; i <= 1; i++) {
                const talon = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.025, 0.1, 6, 8),
                  getMaterial(0x8b7355)
                );
                talon.position.set(i * 0.04, 0, 0.05);
                talon.rotation.x = 0.3;
                footGroup.add(talon);
              }

              // One back talon
              const backTalon = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.025, 0.08, 6, 8),
                getMaterial(0x8b7355)
              );
              backTalon.position.set(0, 0, -0.05);
              backTalon.rotation.x = -0.3;
              footGroup.add(backTalon);

              footGroup.position.set(side * 0.12, 0.1, 0.05);
              animal.add(footGroup);
            });
          }

          // ============ PANDA - CARTOON REDESIGN ============
          else if (type === "panda") {
            // Rounded white body (upright standing pose)
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.48, 32, 32),
              primaryMat
            );
            body.scale.set(1.0, 1.1, 0.9);
            body.position.y = 0.55;
            body.castShadow = true;
            animal.add(body);

            // Large round white head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.42, 32, 32),
              primaryMat
            );
            head.position.y = 1.18;
            animal.add(head);

            // BLACK EARS WITH PINK INNER EAR (like reference!)
            [-1, 1].forEach((side) => {
              // Main black ear
              const ear = new THREE.Mesh(
                new THREE.SphereGeometry(0.14, 18, 18),
                secondaryMat
              );
              ear.position.set(side * 0.32, 1.52, -0.02);
              animal.add(ear);

              // Pink inner ear (key feature from reference!)
              const innerEar = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 14, 14),
                getMaterial(0xffb6c1)
              );
              innerEar.position.set(side * 0.32, 1.52, 0.06);
              animal.add(innerEar);
            });

            // TILTED BLACK EYE PATCHES (like reference - diagonal orientation)
            [-1, 1].forEach((side) => {
              // Main black eye patch - larger and tilted
              const patch = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 20, 20),
                secondaryMat
              );
              patch.scale.set(1.4, 1.7, 0.4);
              patch.position.set(side * 0.18, 1.2, 0.26);
              // Tilt outer corners upward (panda signature look)
              patch.rotation.z = side * 0.4;
              animal.add(patch);

              // LARGE EXPRESSIVE BLUE EYES (like reference!)
              const eyeGroup = new THREE.Group();

              // Large white sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 20, 20),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.15, 0.55);
              eyeGroup.add(sclera);

              // Blue iris (like reference image!)
              const iris = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 18, 18),
                new THREE.MeshPhysicalMaterial({
                  color: 0x4a90d9,
                  roughness: 0.1,
                  clearcoat: 0.5,
                })
              );
              iris.scale.set(1, 1.1, 0.6);
              iris.position.z = 0.03;
              eyeGroup.add(iris);

              // Black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.8);
              pupil.position.z = 0.05;
              eyeGroup.add(pupil);

              // Large white highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 10, 10),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.02 * side, 0.02, 0.065);
              eyeGroup.add(highlight);

              // Smaller secondary highlight
              const highlight2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.012, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight2.position.set(-0.015 * side, -0.015, 0.065);
              eyeGroup.add(highlight2);

              eyeGroup.position.set(side * 0.17, 1.22, 0.36);
              animal.add(eyeGroup);
            });

            // White muzzle area
            const muzzle = new THREE.Mesh(
              new THREE.SphereGeometry(0.15, 18, 18),
              primaryMat
            );
            muzzle.scale.set(1, 0.75, 0.65);
            muzzle.position.set(0, 1.02, 0.35);
            animal.add(muzzle);

            // Small black nose
            const nose = new THREE.Mesh(
              new THREE.SphereGeometry(0.05, 14, 14),
              secondaryMat
            );
            nose.scale.set(1.3, 0.9, 0.9);
            nose.position.set(0, 1.04, 0.44);
            animal.add(nose);

            // OPEN SMILING MOUTH (like reference with visible tongue!)
            const mouthGroup = new THREE.Group();

            // Mouth opening (dark inside)
            const mouthOpen = new THREE.Mesh(
              new THREE.SphereGeometry(0.06, 16, 16),
              getMaterial(0x2a1a1a)
            );
            mouthOpen.scale.set(1.5, 0.8, 0.5);
            mouthGroup.add(mouthOpen);

            // Pink tongue inside mouth
            const tongue = new THREE.Mesh(
              new THREE.SphereGeometry(0.035, 12, 12),
              getMaterial(0xff6b8a)
            );
            tongue.scale.set(1.3, 0.7, 0.8);
            tongue.position.set(0, -0.015, 0.015);
            mouthGroup.add(tongue);

            mouthGroup.position.set(0, 0.93, 0.42);
            animal.add(mouthGroup);

            // BLACK ARMS (like reference - holding down at sides)
            [-1, 1].forEach((side) => {
              const armGroup = new THREE.Group();

              // Upper arm
              const arm = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.11, 0.28, 10, 14),
                secondaryMat
              );
              armGroup.add(arm);

              // Paw at end
              const paw = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 14, 14),
                secondaryMat
              );
              paw.position.y = -0.18;
              armGroup.add(paw);

              armGroup.position.set(side * 0.48, 0.48, 0.08);
              armGroup.rotation.z = side * 0.15;
              animal.add(armGroup);
            });

            // BLACK LEGS (like reference - standing upright)
            [-1, 1].forEach((side) => {
              const leg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.13, 0.22, 10, 14),
                secondaryMat
              );
              leg.position.set(side * 0.22, 0.18, 0.02);
              animal.add(leg);

              const foot = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 14, 14),
                secondaryMat
              );
              foot.scale.set(1.1, 0.55, 1.35);
              foot.position.set(side * 0.22, 0.06, 0.08);
              animal.add(foot);
            });

            // Small white fluffy tail
            const pandaTail = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            pandaTail.position.set(0, 0.5, -0.42);
            animal.add(pandaTail);

            // Animation references
            animal.userData.animationData.head = head;
            animal.userData.animationData.muzzle = muzzle;
          }

          // ============ DUCK ============
          else if (type === "duck") {
            // Compact oval body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1, 0.8, 1.2);
            body.position.y = 0.45;
            body.castShadow = true;
            animal.add(body);

            // Round head with slight crest
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.28, 32, 32),
              primaryMat
            );
            head.position.set(0, 0.95, 0.2);
            animal.userData.animationData.head = head;
            animal.add(head);

            // Crest
            const crest = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 12, 12),
              primaryMat
            );
            crest.position.set(0, 1.18, 0.1);
            animal.add(crest);

            // Rounded duck bill (replaces angular boxes)
            const beakGroup = new THREE.Group();

            // Upper bill - flattened capsule shape
            const beakUpper = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
              getMaterial(config.accentColor)
            );
            beakUpper.scale.set(1.4, 0.35, 1);
            beakUpper.rotation.x = Math.PI / 2;
            beakUpper.position.set(0, 0.02, 0.12);
            beakGroup.add(beakUpper);

            // Lower bill - slightly smaller
            const beakLower = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.05, 0.12, 8, 12),
              getMaterial(config.accentColor)
            );
            beakLower.scale.set(1.3, 0.3, 0.9);
            beakLower.rotation.x = Math.PI / 2;
            beakLower.position.set(0, -0.02, 0.1);
            beakGroup.add(beakLower);

            // Spatula tip (rounded end)
            const beakTip = new THREE.Mesh(
              new THREE.SphereGeometry(0.055, 12, 12),
              getMaterial(config.accentColor)
            );
            beakTip.scale.set(1.5, 0.4, 1);
            beakTip.position.set(0, 0, 0.2);
            beakGroup.add(beakTip);

            // Nail/tip marking
            const beakNail = new THREE.Mesh(
              new THREE.SphereGeometry(0.02, 8, 8),
              getMaterial(0x1a1a1a)
            );
            beakNail.scale.set(1.2, 0.8, 1);
            beakNail.position.set(0, 0.01, 0.24);
            beakGroup.add(beakNail);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.008, 6, 6),
                getMaterial(0x1a1a1a)
              );
              nostril.position.set(side * 0.03, 0.025, 0.08);
              beakGroup.add(nostril);
            });

            beakGroup.position.set(0, 0.92, 0.32);
            animal.add(beakGroup);

            // FIXED: Larger, more visible eyes on head
            [-1, 1].forEach((side) => {
              const eyeGroup = new THREE.Group();

              // White sclera
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.065, 16, 16),
                SPECIAL_MATERIALS.eyeWhite
              );
              sclera.scale.set(1, 1.1, 0.6);
              eyeGroup.add(sclera);

              // Black pupil (large for cartoon look)
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.scale.set(1, 1.1, 0.75);
              pupil.position.z = 0.025;
              eyeGroup.add(pupil);

              // White highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.018, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.015 * side, 0.018, 0.05);
              eyeGroup.add(highlight);

              // Position on head - forward facing
              eyeGroup.position.set(side * 0.12, 0.98, 0.42);
              animal.add(eyeGroup);
            });

            // Wings tucked at sides
            [-1, 1].forEach((side) => {
              const wing = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                primaryMat
              );
              wing.scale.set(0.35, 0.6, 0.9);
              wing.position.set(side * 0.35, 0.5, -0.05);
              animal.add(wing);
            });

            // Tail feathers pointing up
            const tailGroup = new THREE.Group();
            for (let i = -1; i <= 1; i++) {
              const feather = new THREE.Mesh(
                new THREE.ConeGeometry(0.04, 0.15, 6),
                primaryMat
              );
              feather.position.set(i * 0.05, 0.05, 0);
              feather.rotation.x = -0.5;
              tailGroup.add(feather);
            }
            tailGroup.position.set(0, 0.45, -0.45);
            animal.add(tailGroup);

            // Enhanced webbed feet with membrane
            [-1, 1].forEach((side) => {
              const footGroup = new THREE.Group();

              // Rounded foot base (replaces box)
              const footBase = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.04, 0.06, 8, 8),
                getMaterial(config.accentColor)
              );
              footBase.rotation.x = Math.PI / 2;
              footBase.scale.set(1.4, 0.3, 1);
              footGroup.add(footBase);

              // Three toes with webbing between them
              const toePositions = [-0.045, 0, 0.045];
              toePositions.forEach((xPos, idx) => {
                // Toe
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.018, 0.08, 6, 8),
                  getMaterial(config.accentColor)
                );
                toe.rotation.x = -Math.PI / 2 + 0.1;
                toe.position.set(xPos, 0.005, 0.09);
                footGroup.add(toe);

                // Webbing membrane between toes (triangular shape)
                if (idx < toePositions.length - 1) {
                  const webShape = new THREE.Shape();
                  webShape.moveTo(0, 0);
                  webShape.lineTo(0.04, 0.08);
                  webShape.lineTo(-0.04, 0.08);
                  webShape.lineTo(0, 0);

                  const webGeom = new THREE.ShapeGeometry(webShape);
                  const web = new THREE.Mesh(
                    webGeom,
                    getMaterial(config.accentColor, {
                      transparent: true,
                      opacity: 0.85,
                      side: THREE.DoubleSide,
                    })
                  );
                  web.rotation.x = -Math.PI / 2 + 0.15;
                  web.position.set(xPos + 0.022, 0.002, 0.05);
                  footGroup.add(web);
                }
              });

              footGroup.position.set(side * 0.15, 0.02, 0.12);
              animal.add(footGroup);
            });
          }

          // ============ FROG ============
          else if (type === "frog") {
            // Wide flat body
            const body = new THREE.Mesh(
              new THREE.SphereGeometry(0.4, 32, 32),
              primaryMat
            );
            body.scale.set(1.2, 0.7, 1.0);
            body.position.y = 0.35;
            body.castShadow = true;
            animal.add(body);

            // Spots and warts on back (darker green spots)
            const spotPositions = [
              { x: -0.15, y: 0.45, z: -0.1 },
              { x: 0.12, y: 0.48, z: -0.08 },
              { x: 0.0, y: 0.5, z: -0.15 },
              { x: -0.2, y: 0.38, z: 0.05 },
              { x: 0.18, y: 0.4, z: 0.08 },
              { x: -0.08, y: 0.42, z: 0.12 },
              { x: 0.1, y: 0.35, z: -0.2 },
            ];
            spotPositions.forEach((pos) => {
              const spot = new THREE.Mesh(
                new THREE.SphereGeometry(0.04 + Math.random() * 0.02, 8, 8),
                getMaterial(0x228b22) // Darker forest green
              );
              spot.scale.set(1.2, 0.6, 1.2);
              spot.position.set(pos.x, pos.y, pos.z);
              animal.add(spot);
            });

            // Small wart bumps
            for (let i = 0; i < 12; i++) {
              const wart = new THREE.Mesh(
                new THREE.SphereGeometry(0.015 + Math.random() * 0.01, 6, 6),
                getMaterial(0x2e8b2e)
              );
              const angle = (i / 12) * Math.PI * 2;
              const radius = 0.3 + Math.random() * 0.1;
              wart.position.set(
                Math.cos(angle) * radius * 0.8,
                0.4 + Math.random() * 0.1,
                Math.sin(angle) * radius * 0.6 - 0.05
              );
              animal.add(wart);
            }

            // Belly
            const belly = new THREE.Mesh(
              new THREE.SphereGeometry(0.35, 24, 24),
              secondaryMat
            );
            belly.scale.set(1.1, 0.6, 0.8);
            belly.position.set(0, 0.3, 0.15);
            animal.add(belly);

            // Wide flat head
            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.32, 32, 32),
              primaryMat
            );
            head.scale.set(1.3, 0.8, 1.0);
            head.position.set(0, 0.55, 0.25);
            animal.add(head);

            // HUGE bulging eyes on top - ENHANCED
            [-1, 1].forEach((side) => {
              // Larger eye bulge
              const eyeBulge = new THREE.Mesh(
                new THREE.SphereGeometry(0.17, 18, 18),
                primaryMat
              );
              eyeBulge.position.set(side * 0.22, 0.82, 0.22);
              animal.add(eyeBulge);

              // Eye shadow ring
              const eyeShadow = new THREE.Mesh(
                new THREE.TorusGeometry(0.1, 0.015, 8, 20),
                getMaterial(0x228b22)
              );
              eyeShadow.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeShadow);

              // Larger eye group
              const eyeGroup = new THREE.Group();
              const sclera = new THREE.Mesh(
                new THREE.SphereGeometry(0.12, 18, 18),
                SPECIAL_MATERIALS.eyeWhite
              );
              eyeGroup.add(sclera);

              // Golden iris ring (frog style)
              const irisRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.05, 0.025, 10, 20),
                getMaterial(0xc4a020)
              );
              irisRing.position.z = 0.06;
              eyeGroup.add(irisRing);

              // Larger black pupil
              const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(0.045, 14, 14),
                SPECIAL_MATERIALS.eyeBlack
              );
              pupil.position.z = 0.075;
              eyeGroup.add(pupil);

              // Specular highlight
              const highlight = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 8),
                SPECIAL_MATERIALS.specular
              );
              highlight.position.set(0.025, 0.03, 0.1);
              eyeGroup.add(highlight);

              eyeGroup.position.set(side * 0.22, 0.88, 0.32);
              animal.add(eyeGroup);
            });

            // Wide mouth line
            const mouth = new THREE.Mesh(
              new THREE.TorusGeometry(0.2, 0.015, 8, 24, Math.PI),
              getMaterial(0x228b22)
            );
            mouth.rotation.x = Math.PI;
            mouth.position.set(0, 0.45, 0.42);
            animal.add(mouth);

            // Nostrils
            [-1, 1].forEach((side) => {
              const nostril = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 8, 8),
                getMaterial(0x228b22)
              );
              nostril.position.set(side * 0.08, 0.6, 0.48);
              animal.add(nostril);
            });

            // Front legs
            [-1, 1].forEach((side) => {
              const frontLeg = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.06, 0.15, 8, 12),
                primaryMat
              );
              frontLeg.position.set(side * 0.35, 0.2, 0.2);
              frontLeg.rotation.z = side * 0.5;
              animal.add(frontLeg);

              // Front foot with webbing
              const footGroup = new THREE.Group();
              for (let i = 0; i < 3; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.015, 0.06, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1) * 0.03, 0, 0.03);
                footGroup.add(toe);
              }
              footGroup.position.set(side * 0.42, 0.1, 0.25);
              animal.add(footGroup);
            });

            // Long folded back legs
            [-1, 1].forEach((side) => {
              // Thigh
              const thigh = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.1, 0.2, 8, 12),
                primaryMat
              );
              thigh.position.set(side * 0.3, 0.3, -0.15);
              thigh.rotation.z = side * -0.8;
              thigh.rotation.x = 0.3;
              animal.add(thigh);

              // Shin (folded back)
              const shin = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.07, 0.2, 8, 12),
                primaryMat
              );
              shin.position.set(side * 0.45, 0.2, -0.05);
              shin.rotation.z = side * 0.5;
              animal.add(shin);

              // Webbed back foot
              const backFootGroup = new THREE.Group();
              for (let i = 0; i < 4; i++) {
                const toe = new THREE.Mesh(
                  new THREE.CapsuleGeometry(0.02, 0.1, 6, 8),
                  primaryMat
                );
                toe.position.set((i - 1.5) * 0.04, 0, 0.05);
                toe.rotation.x = 0.3;
                backFootGroup.add(toe);
              }
              // Webbing
              const webbing = new THREE.Mesh(
                new THREE.CircleGeometry(0.08, 8),
                primaryMat
              );
              webbing.rotation.x = -Math.PI / 2 + 0.3;
              webbing.position.y = -0.02;
              backFootGroup.add(webbing);

              backFootGroup.position.set(side * 0.5, 0.08, 0.1);
              animal.add(backFootGroup);
            });

            // Throat for pulse animation
            const throat = new THREE.Mesh(
              new THREE.SphereGeometry(0.12, 16, 16),
              secondaryMat
            );
            throat.scale.set(1, 0.6, 0.8);
            throat.position.set(0, 0.35, 0.35);
            animal.userData.animationData.throat = throat;
            animal.add(throat);
          }

          return animal;
        }

        // ==========================================
        // ROOM SYSTEM - 3D ENVIRONMENT
        // ==========================================

        // Room configuration
        const ROOM_CONFIG = {
          living: {
            name: "Living Room",
            size: { x: 10, y: 4, z: 10 },
            floorColor: 0x8b7355, // Warm wood
            wallColor: 0xfff8e7, // Cream
            accentColor: 0xd4a574,
            animals: ["bunny", "cat", "bear"],
          },
          bedroom: {
            name: "Bedroom",
            size: { x: 8, y: 3.5, z: 8 },
            floorColor: 0x6b5b7a, // Purple carpet
            wallColor: 0xe8e4f0, // Soft lavender
            accentColor: 0x9b8ab8,
            animals: ["owl", "panda", "fox"],
          },
          garden: {
            name: "Garden",
            size: { x: 12, y: 6, z: 12 },
            floorColor: 0x4a7c4e, // Grass green
            wallColor: 0x87ceeb, // Sky blue (open sky)
            accentColor: 0x8fbc8f,
            animals: ["penguin", "duck", "frog", "elephant"],
          },
        };

        // Room class
        class Room {
          constructor(config, key) {
            this.config = config;
            this.key = key;
            this.group = new THREE.Group();
            this.animals = [];
            this.createRoom();
          }

          createRoom() {
            const { size, floorColor, wallColor } = this.config;

            // Floor
            const floorGeo = new THREE.PlaneGeometry(size.x, size.z);
            const floorMat = new THREE.MeshPhysicalMaterial({
              color: floorColor,
              roughness: 0.7,
              metalness: 0,
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            this.group.add(floor);

            // Contact shadow in center
            const shadowGeo = new THREE.CircleGeometry(1.5, 32);
            const shadowMat = new THREE.MeshBasicMaterial({
              color: 0x000000,
              transparent: true,
              opacity: 0.25,
              depthWrite: false,
            });
            const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
            shadowMesh.rotation.x = -Math.PI / 2;
            shadowMesh.position.y = 0.01;
            this.group.add(shadowMesh);

            // Walls (only for indoor rooms)
            if (this.key !== "garden") {
              this.createWalls(size, wallColor);
            } else {
              // Garden has sky dome instead
              this.createSkyDome();
            }
          }

          createWalls(size, wallColor) {
            const wallMat = new THREE.MeshPhysicalMaterial({
              color: wallColor,
              roughness: 0.9,
              side: THREE.DoubleSide,
            });

            // Back wall
            const backWall = new THREE.Mesh(
              new THREE.PlaneGeometry(size.x, size.y),
              wallMat
            );
            backWall.position.set(0, size.y / 2, -size.z / 2);
            this.group.add(backWall);

            // Side walls
            [-1, 1].forEach((side) => {
              const sideWall = new THREE.Mesh(
                new THREE.PlaneGeometry(size.z, size.y),
                wallMat
              );
              sideWall.position.set((side * size.x) / 2, size.y / 2, 0);
              sideWall.rotation.y = (side * Math.PI) / 2;
              this.group.add(sideWall);
            });
          }

          createSkyDome() {
            // Simple sky gradient for garden
            const skyGeo = new THREE.SphereGeometry(
              15,
              32,
              16,
              0,
              Math.PI * 2,
              0,
              Math.PI / 2
            );
            const skyMat = new THREE.MeshBasicMaterial({
              color: 0x87ceeb,
              side: THREE.BackSide,
            });
            const sky = new THREE.Mesh(skyGeo, skyMat);
            this.group.add(sky);

            // Grass texture on floor (dots)
            for (let i = 0; i < 50; i++) {
              const blade = new THREE.Mesh(
                new THREE.ConeGeometry(0.03, 0.15, 4),
                new THREE.MeshBasicMaterial({ color: 0x3a6b3a })
              );
              blade.position.set(
                (Math.random() - 0.5) * 10,
                0.05,
                (Math.random() - 0.5) * 10
              );
              this.group.add(blade);
            }
          }

          addAnimal(animal) {
            this.animals.push(animal);
            this.group.add(animal);
          }
        }

        // Create all rooms
        const rooms = {};
        let roomOffsetX = 0;
        Object.entries(ROOM_CONFIG).forEach(([key, config]) => {
          const room = new Room(config, key);
          room.group.position.x = roomOffsetX;
          room.group.visible = false; // Hide all initially
          rooms[key] = room;
          scene.add(room.group);
          roomOffsetX += 50; // Offset rooms far apart
        });

        // Current room state
        let currentRoom = "living";
        rooms[currentRoom].group.visible = true;

        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        let currentAnimal = null;
        let currentType = "bunny";
        let currentColor = "default";
        let isTransitioning = false;

        function switchAnimal(type, colorOverride = null) {
          if (isTransitioning) return;

          const color = colorOverride || currentColor;
          const config = ANIMAL_CONFIG[type];

          if (!config) return;

          isTransitioning = true;

          // Scale down current animal
          if (currentAnimal) {
            const oldAnimal = currentAnimal;
            const startScale = { value: 1 };

            const animateOut = () => {
              startScale.value -= 0.08;
              if (startScale.value > 0) {
                oldAnimal.scale.setScalar(startScale.value);
                requestAnimationFrame(animateOut);
              } else {
                // Particle burst at center
                particleBurst.burst(new THREE.Vector3(0, 0.8, 0), 25);

                scene.remove(oldAnimal);
                oldAnimal.traverse((child) => {
                  if (child.geometry) child.geometry.dispose();
                });

                // Create and animate in new animal
                createNewAnimal();
              }
            };
            animateOut();
          } else {
            createNewAnimal();
          }

          function createNewAnimal() {
            currentAnimal = createAnimalModel(type, color);
            currentAnimal.scale.setScalar(0);
            scene.add(currentAnimal);

            currentType = type;

            // Animate in with bounce
            let scaleProgress = 0;
            const animateIn = () => {
              scaleProgress += 0.06;
              if (scaleProgress < 1) {
                // Bounce easing
                const t = scaleProgress;
                const bounce = 1 + Math.sin(t * Math.PI) * 0.15 * (1 - t);
                currentAnimal.scale.setScalar(t * bounce);
                requestAnimationFrame(animateIn);
              } else {
                currentAnimal.scale.setScalar(1);
                isTransitioning = false;
              }
            };
            animateIn();
          }

          // Update UI
          document.getElementById("animal-name").textContent = config.name;
          document.getElementById("animal-emoji").textContent = config.emoji;

          const badgeEl = document.getElementById("animal-badge");
          badgeEl.classList.remove("pop-in");
          void badgeEl.offsetWidth;
          badgeEl.classList.add("pop-in");
        }

        // Color change handler
        function changeColor(colorName) {
          currentColor = colorName;
          document.querySelectorAll(".color-swatch").forEach((swatch) => {
            swatch.classList.toggle(
              "active",
              swatch.dataset.color === colorName
            );
          });
        }

        // ==========================================
        // ROOM SWITCHING SYSTEM
        // ==========================================
        function switchRoom(roomKey) {
          if (roomKey === currentRoom) return;

          // Hide current room
          rooms[currentRoom].group.visible = false;

          // Show new room
          currentRoom = roomKey;
          rooms[currentRoom].group.visible = true;

          // Move camera to new room position
          const roomPos = rooms[currentRoom].group.position;
          camera.position.set(roomPos.x, 3, roomPos.z + 8);
          controls.target.set(roomPos.x, 1, roomPos.z);
          controls.update();

          // Update room badge
          const roomConfig = ROOM_CONFIG[roomKey];
          document.getElementById("animal-name").textContent = roomConfig.name;
          document.getElementById("animal-emoji").textContent =
            roomKey === "living" ? "ğŸ›‹ï¸" : roomKey === "bedroom" ? "ğŸ›ï¸" : "ğŸŒ³";

          // Update room button active states
          document.querySelectorAll(".room-btn").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.room === roomKey);
          });
        }

        // ANIMAL AI - PHASE 2 TYPE-SPECIFIC LOCOMOTION
        // ==========================================

        // Type-specific locomotion profiles
        const LOCOMOTION_PROFILES = {
          bunny: {
            hopHeight: 0.35,
            hopSpeed: 8,
            waddle: 0.05,
            squashIntensity: 0.25,
            speed: 1.2,
            style: "hop",
          },
          bear: {
            hopHeight: 0.08,
            hopSpeed: 4,
            waddle: 0.12,
            squashIntensity: 0.15,
            speed: 0.5,
            style: "lumber",
          },
          penguin: {
            hopHeight: 0.05,
            hopSpeed: 6,
            waddle: 0.25,
            squashIntensity: 0.1,
            speed: 0.6,
            style: "waddle",
          },
          fox: {
            hopHeight: 0.15,
            hopSpeed: 7,
            waddle: 0.08,
            squashIntensity: 0.18,
            speed: 1.0,
            style: "trot",
          },
          elephant: {
            hopHeight: 0.03,
            hopSpeed: 2,
            waddle: 0.06,
            squashIntensity: 0.08,
            speed: 0.3,
            style: "stomp",
          },
          cat: {
            hopHeight: 0.12,
            hopSpeed: 5,
            waddle: 0.04,
            squashIntensity: 0.2,
            speed: 0.9,
            style: "prowl",
          },
          owl: {
            hopHeight: 0.2,
            hopSpeed: 3,
            waddle: 0.02,
            squashIntensity: 0.15,
            speed: 0.4,
            style: "hop",
          },
          panda: {
            hopHeight: 0.06,
            hopSpeed: 3,
            waddle: 0.18,
            squashIntensity: 0.12,
            speed: 0.4,
            style: "waddle",
          },
          duck: {
            hopHeight: 0.08,
            hopSpeed: 7,
            waddle: 0.22,
            squashIntensity: 0.1,
            speed: 0.7,
            style: "waddle",
          },
          frog: {
            hopHeight: 0.5,
            hopSpeed: 2,
            waddle: 0.0,
            squashIntensity: 0.4,
            speed: 0.8,
            style: "leap",
          },
        };

        class AnimalAI {
          constructor(animal, roomConfig) {
            this.animal = animal;
            this.roomConfig = roomConfig;
            this.animalType = animal.userData.type || "bunny";
            this.locomotion =
              LOCOMOTION_PROFILES[this.animalType] || LOCOMOTION_PROFILES.bunny;

            this.state = "idle"; // idle, anticipation, walking, arriving, sitting, playing
            this.targetPosition = new THREE.Vector3();
            this.startPosition = new THREE.Vector3();
            this.moveSpeed = this.locomotion.speed + Math.random() * 0.2;
            this.stateTimer = 0;
            this.stateDuration = 3 + Math.random() * 2;
            this.roomBounds = {
              x: roomConfig.size.x / 2 - 1.5,
              z: roomConfig.size.z / 2 - 1.5,
            };
            this.walkCycle = 0;
            this.bouncePhase = 0;
            this.squash = 1;
            this.stretch = 1;
            this.hopCount = 0; // For discrete hop styles
            this.collisionRadius = 0.6; // Collision detection radius
            this.isColliding = false; // Track collision state
            this.collisionCooldown = 0; // Cooldown timer to prevent collision loops
            this.collisionPartner = null; // Track who we collided with
            this.pickNewTarget();
          }

          pickNewTarget() {
            this.startPosition.copy(this.animal.position);

            // Try to find a good target that avoids other animals
            let attempts = 0;
            let bestTarget = new THREE.Vector3();
            let valid = false;

            while (!valid && attempts < 5) {
              attempts++;

              // Occasionally explore edges/corners (30% chance)
              if (Math.random() < 0.3) {
                // Pick an edge or corner position
                const edgeX =
                  (Math.random() > 0.5 ? 1 : -1) * this.roomBounds.x * 0.85;
                const edgeZ =
                  (Math.random() > 0.5 ? 1 : -1) * this.roomBounds.z * 0.85;
                if (Math.random() > 0.5) {
                  bestTarget.set(
                    edgeX,
                    0,
                    (Math.random() - 0.5) * this.roomBounds.z
                  );
                } else {
                  bestTarget.set(
                    (Math.random() - 0.5) * this.roomBounds.x,
                    0,
                    edgeZ
                  );
                }
              } else {
                // Normal random position
                bestTarget.set(
                  (Math.random() - 0.5) * this.roomBounds.x * 1.4,
                  0,
                  (Math.random() - 0.5) * this.roomBounds.z * 1.4
                );
              }

              // Check distance from other animals
              valid = true;
              animalAIs.forEach((otherAI) => {
                if (otherAI !== this && otherAI.roomKey === this.roomKey) {
                  const dist = bestTarget.distanceTo(otherAI.animal.position);
                  if (dist < 1.2) {
                    // Minimum safe distance
                    valid = false;
                  }
                }
              });
            }

            this.targetPosition.copy(bestTarget);
            this.journeyLength = this.startPosition.distanceTo(
              this.targetPosition
            );
          }

          // Cartoon easing functions
          easeOutBack(t) {
            const c1 = 1.70158;
            const c3 = c1 + 1;
            return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
          }

          easeOutElastic(t) {
            if (t === 0 || t === 1) return t;
            return (
              Math.pow(2, -10 * t) *
                Math.sin(((t * 10 - 0.75) * (2 * Math.PI)) / 3) +
              1
            );
          }

          easeInOutQuad(t) {
            return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          }

          update(deltaTime) {
            this.stateTimer += deltaTime;
            const t = this.stateTimer;

            switch (this.state) {
              case "idle":
                // Gentle breathing (reset squash/stretch)
                this.squash = 1 + Math.sin(t * 2) * 0.02;
                this.stretch = 1;
                this.applySquashStretch();

                // ===== PERSONALITY BEHAVIORS WHILE IDLE =====
                const data = this.animal.userData.animationData;

                // Curious looking around (head movement)
                if (data && data.head) {
                  const lookCycle = t * 0.5;
                  // Occasional look to side
                  const lookSide = Math.sin(lookCycle) * 0.2;
                  // Random curious tilt
                  const tilt = Math.sin(t * 0.3) * 0.1;
                  data.head.rotation.y = lookSide;
                  data.head.rotation.z = tilt;
                }

                // Ear twitches (alert/curious)
                if (data && data.ears) {
                  data.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      const twitch = Math.sin(t * 4 + i * 2) * 0.05;
                      ear.rotation.z = (i === 0 ? -1 : 1) * (0.15 + twitch);
                    }
                  });
                }

                // Occasional yawn (every 8+ seconds)
                const yawnPhase = t % 10;
                if (yawnPhase > 8 && yawnPhase < 8.8) {
                  const yawnProgress = (yawnPhase - 8) / 0.8;
                  // Open mouth wide, tilt head back
                  if (data && data.head) {
                    data.head.rotation.x =
                      -Math.sin(yawnProgress * Math.PI) * 0.2;
                  }
                  // Squash-stretch during yawn
                  this.squash = 1 + Math.sin(yawnProgress * Math.PI) * 0.1;
                  this.applySquashStretch();
                }

                // ===== UNIVERSAL BLINKING SYSTEM =====
                // Initialize blink timer if not set
                if (this.nextBlinkTime === undefined) {
                  this.nextBlinkTime = t + 2 + Math.random() * 3; // First blink in 2-5 seconds
                  this.blinkPhase = 0;
                }

                // Check if it's time to blink
                if (t >= this.nextBlinkTime && this.blinkPhase === 0) {
                  this.blinkPhase = 1; // Start blink
                  this.blinkStartTime = t;
                }

                // Animate blink (close eyes briefly)
                if (this.blinkPhase > 0) {
                  const blinkDuration = 0.15; // Quick blink
                  const blinkProgress =
                    (t - this.blinkStartTime) / blinkDuration;

                  if (blinkProgress <= 1) {
                    // Squash eyes vertically during blink
                    const eyeSquash =
                      1 - Math.sin(blinkProgress * Math.PI) * 0.85;

                    // Apply to eyes - look for eye meshes in the ANIMAL (not head.traverse)
                    // Eyes are typically small, white or colored meshes
                    if (data && this.animal) {
                      this.animal.traverse((child) => {
                        // Skip the head mesh itself and body
                        if (child === data.head || child === data.body) return;

                        if (child.isMesh && child.geometry) {
                          const geomType = child.geometry.type;
                          // Check if geometry is sphere-like (potential eye)
                          const isSphereish =
                            geomType &&
                            (geomType.includes("Sphere") ||
                              geomType.includes("Icosahedron") ||
                              geomType.includes("Octahedron"));

                          if (isSphereish) {
                            // Size check: eyes are small (scale typically < 0.15)
                            const avgScale =
                              (child.scale.x + child.scale.y + child.scale.z) /
                              3;
                            const isEyeSize = avgScale < 0.2;

                            // Position check: eyes are near top half of model
                            const isNearTop =
                              child.position.y > 0.5 ||
                              (child.parent &&
                                child.parent.position &&
                                child.parent.position.y > 0.5);

                            // Color check: eyes are often white or have bright materials
                            const material = child.material;
                            const isLikelyEye =
                              material &&
                              ((material.color &&
                                material.color.getHex() === 0xffffff) || // white
                                (material.color &&
                                  material.color.getHex() === 0x000000) || // black (pupil)
                                (material.color && material.color.r > 0.8)); // bright

                            // Only apply to likely eyes
                            if (isEyeSize && (isNearTop || isLikelyEye)) {
                              if (!child.userData.originalScaleY) {
                                child.userData.originalScaleY = child.scale.y;
                              }
                              child.scale.y =
                                child.userData.originalScaleY * eyeSquash;
                            }
                          }
                        }
                      });
                    }
                  } else {
                    // Blink finished, reset and schedule next
                    this.blinkPhase = 0;
                    this.nextBlinkTime = t + 2.5 + Math.random() * 4; // Next blink in 2.5-6.5 seconds

                    // Restore eye scales
                    if (this.animal) {
                      this.animal.traverse((child) => {
                        if (child.isMesh && child.userData.originalScaleY) {
                          child.scale.y = child.userData.originalScaleY;
                        }
                      });
                    }
                  }
                }

                // ===== ENHANCED TAIL PHYSICS =====
                if (data && data.tail) {
                  // Primary gentle sway
                  const tailSwayX = Math.sin(t * 1.5) * 0.15;
                  const tailSwayZ = Math.sin(t * 2.2) * 0.08; // Secondary motion
                  const tailWave = Math.sin(t * 3.5) * 0.05; // High-frequency wave

                  data.tail.rotation.z = tailSwayX + tailWave;
                  data.tail.rotation.x = Math.sin(t * 0.8) * 0.08; // Slow vertical

                  // Animate tail children for wave effect
                  if (data.tail.children && data.tail.children.length > 0) {
                    data.tail.children.forEach((segment, i) => {
                      if (segment.isMesh || segment.isGroup) {
                        const delay = i * 0.3;
                        segment.rotation.z = Math.sin(t * 2 + delay) * 0.1;
                      }
                    });
                  }
                }

                // ===== TRUNK WAVE (for elephant) =====
                if (data && data.trunk) {
                  const trunkWave = Math.sin(t * 1.2) * 0.08;
                  data.trunk.rotation.x = trunkWave;

                  // Animate trunk segments
                  if (data.trunk.children && data.trunk.children.length > 0) {
                    data.trunk.children.forEach((segment, i) => {
                      if (segment.isMesh) {
                        const segmentDelay = i * 0.15;
                        segment.rotation.x =
                          Math.sin(t * 1.5 + segmentDelay) * 0.05;
                      }
                    });
                  }
                }

                if (t > this.stateDuration) {
                  this.transitionTo("anticipation");
                }
                break;

              case "anticipation":
                // SQUASH DOWN before jumping/moving (wind-up)
                const anticipationDuration = 0.4;
                const anticipationProgress = Math.min(
                  t / anticipationDuration,
                  1
                );

                // Turn to face target BEFORE hopping
                const turnDirection = new THREE.Vector3().subVectors(
                  this.targetPosition,
                  this.animal.position
                );
                if (turnDirection.length() > 0.1) {
                  const targetRot = Math.atan2(
                    turnDirection.x,
                    turnDirection.z
                  );
                  let rotDiff = targetRot - this.animal.rotation.y;
                  while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                  while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                  this.animal.rotation.y += rotDiff * 0.6; // Faster turn (was 0.3)
                }

                // Squash down dramatically
                this.squash = 1 - anticipationProgress * 0.3; // Compress to 70%
                this.stretch = 1 + anticipationProgress * 0.15; // Widen
                this.applySquashStretch();

                // Crouch down
                this.animal.position.y = -anticipationProgress * 0.1;

                if (t > anticipationDuration) {
                  this.transitionTo("walking");
                }
                break;

              case "walking":
                // TYPE-SPECIFIC LOCOMOTION
                const loco = this.locomotion;
                const walkDuration = this.journeyLength / this.moveSpeed;
                const walkProgress = Math.min(t / walkDuration, 1);

                // Hop/walk cycle using type-specific speed
                this.walkCycle += deltaTime * loco.hopSpeed;
                const hopPhase = Math.sin(this.walkCycle * Math.PI);

                // Apply hop based on style
                if (loco.style === "hop") {
                  // BUNNY/OWL: Distinct bouncy hops
                  const discreteHop = Math.abs(
                    Math.sin(this.walkCycle * Math.PI)
                  );
                  this.animal.position.y = discreteHop * loco.hopHeight;
                } else if (loco.style === "leap") {
                  // FROG: Big single leap with hang time
                  const leapProgress = this.easeInOutQuad(
                    Math.sin(walkProgress * Math.PI)
                  );
                  this.animal.position.y = leapProgress * loco.hopHeight;
                } else if (loco.style === "stomp") {
                  // ELEPHANT: Heavy stomp with ground impact
                  this.animal.position.y = Math.max(
                    0,
                    Math.abs(hopPhase) * loco.hopHeight
                  );
                  // Add "weight" shake on landing
                  if (Math.abs(hopPhase) < 0.1) {
                    this.animal.rotation.x = Math.random() * 0.02;
                  }
                } else if (loco.style === "waddle") {
                  // PENGUIN/DUCK/PANDA: Tiny bounces with strong side-to-side
                  this.animal.position.y = Math.abs(hopPhase) * loco.hopHeight;
                } else {
                  // DEFAULT (trot, lumber, prowl): Standard hop
                  this.animal.position.y = Math.max(
                    0,
                    Math.abs(hopPhase) * loco.hopHeight
                  );
                }

                // Squash on landing, stretch in air (type-specific intensity)
                if (hopPhase > 0) {
                  // In air - stretch tall
                  this.squash = 1 + loco.squashIntensity;
                  this.stretch = 1 - loco.squashIntensity * 0.6;
                } else {
                  // Landing - squash wide
                  this.squash = 1 - loco.squashIntensity;
                  this.stretch = 1 + loco.squashIntensity * 0.6;
                }
                this.applySquashStretch();

                // Move towards target with easing
                const easedProgress = this.easeInOutQuad(walkProgress);
                const newX =
                  this.startPosition.x +
                  (this.targetPosition.x - this.startPosition.x) *
                    easedProgress;
                const newZ =
                  this.startPosition.z +
                  (this.targetPosition.z - this.startPosition.z) *
                    easedProgress;
                this.animal.position.x = newX;
                this.animal.position.z = newZ;

                // Face movement direction - use startâ†’target direction (not currentâ†’target)
                const moveDirection = new THREE.Vector3().subVectors(
                  this.targetPosition,
                  this.startPosition
                );
                if (moveDirection.length() > 0.1) {
                  const targetRot = Math.atan2(
                    moveDirection.x,
                    moveDirection.z
                  );
                  // Snap rotation faster for responsiveness
                  let rotDiff = targetRot - this.animal.rotation.y;
                  // Normalize angle
                  while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                  while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                  this.animal.rotation.y += rotDiff * 0.5; // Faster rotation (was 0.2)
                }

                // Type-specific waddle side-to-side
                const waddleAmount = Math.sin(this.walkCycle * 2) * loco.waddle;
                this.animal.rotation.z = waddleAmount;

                // Type-specific tilt based on locomotion style
                if (loco.style === "prowl") {
                  this.animal.rotation.x = 0.03; // Cat: sleek, low profile
                } else if (loco.style === "lumber") {
                  this.animal.rotation.x = 0.12; // Bear: heavy lean
                } else if (loco.style === "leap") {
                  this.animal.rotation.x = -0.1; // Frog: nose up during leap
                } else {
                  this.animal.rotation.x = 0.06; // Default forward tilt
                }

                // Animate body parts during walking
                this.animateBodyParts(hopPhase, deltaTime);

                // ===== COLLISION DETECTION =====
                // Decrease cooldown
                if (this.collisionCooldown > 0) {
                  this.collisionCooldown -= deltaTime;
                }

                // Check for collisions with other animals in same room (only if not on cooldown)
                if (this.collisionCooldown <= 0) {
                  for (const otherAI of animalAIs) {
                    if (otherAI === this) continue;
                    if (otherAI.roomKey !== this.roomKey) continue;
                    if (otherAI.collisionCooldown > 0) continue; // Other is also on cooldown

                    const distance = this.animal.position.distanceTo(
                      otherAI.animal.position
                    );
                    const minDistance =
                      this.collisionRadius + otherAI.collisionRadius;

                    if (distance < minDistance) {
                      // Collision detected! Both animals get confused
                      this.collisionPartner = otherAI;
                      otherAI.collisionPartner = this;
                      this.collisionCooldown = 2.0; // 2 second cooldown
                      otherAI.collisionCooldown = 2.0;
                      this.transitionTo("confused");
                      otherAI.transitionTo("confused");
                      break;
                    }
                  }
                }

                // Check if arrived
                if (this.state === "walking" && walkProgress >= 1) {
                  this.transitionTo("arriving");
                }
                break;

              case "arriving":
                // OVERSHOOT and settle with bounce
                const arriveDuration = 0.5;
                const arriveProgress = Math.min(t / arriveDuration, 1);

                // Elastic overshoot bounce
                const bounce = this.easeOutElastic(arriveProgress);
                this.squash =
                  1 +
                  (1 - bounce) * 0.2 * Math.sin(arriveProgress * Math.PI * 4);
                this.stretch = 1;
                this.applySquashStretch();

                // Settle rotation
                this.animal.rotation.x *= 0.9;
                this.animal.rotation.z *= 0.9;
                this.animal.position.y *= 0.8;

                if (t > arriveDuration) {
                  const nextState = Math.random();
                  if (nextState < 0.4) this.transitionTo("idle");
                  else if (nextState < 0.7) this.transitionTo("sitting");
                  else this.transitionTo("playing");
                }
                break;

              case "sitting":
                // Cute sit-down animation
                const sitProgress = Math.min(t / 0.3, 1);
                this.squash = 0.8; // Stay squashed
                this.stretch = 1.1;
                this.applySquashStretch();
                this.animal.position.y = -0.08 * sitProgress;

                // ===== SITTING PERSONALITY =====
                const sitData = this.animal.userData.animationData;

                // Sleepy slow breathing
                const sleepyBreath = Math.sin(t * 1.2) * 0.03;
                this.squash = 0.8 + sleepyBreath;

                // Content head resting/looking around slowly
                if (sitData && sitData.head) {
                  sitData.head.rotation.y = Math.sin(t * 0.4) * 0.15;
                  sitData.head.rotation.x = 0.1; // Looking down slightly
                }

                // Occasional grooming (look at side as if checking fur)
                const groomPhase = t % 6;
                if (
                  groomPhase > 4.5 &&
                  groomPhase < 5.5 &&
                  sitData &&
                  sitData.head
                ) {
                  sitData.head.rotation.y = 0.5; // Turn head to side
                  sitData.head.rotation.z = 0.2; // Tilt
                }

                // Ears relaxed/droopy while sitting
                if (sitData && sitData.ears) {
                  sitData.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      ear.rotation.z = (i === 0 ? -1 : 1) * 0.25; // Relaxed droopy
                    }
                  });
                }

                // Tail curled calmly
                if (sitData && sitData.tail) {
                  sitData.tail.rotation.z = Math.sin(t * 0.8) * 0.1;
                  sitData.tail.rotation.x = 0.3; // Curled up
                }

                // Stretch when about to get up
                if (
                  t > this.stateDuration * 1.3 &&
                  t < this.stateDuration * 1.5
                ) {
                  const stretchProgress =
                    (t - this.stateDuration * 1.3) / (this.stateDuration * 0.2);
                  this.squash = 0.8 + stretchProgress * 0.4; // Stretch tall!
                  this.stretch = 1.1 - stretchProgress * 0.2;
                  this.applySquashStretch();
                }

                if (t > this.stateDuration * 1.5) {
                  this.transitionTo("idle");
                }
                break;

              case "playing":
                // Excited spinning and bouncing!
                this.animal.rotation.y += deltaTime * 4;
                this.bouncePhase += deltaTime * 8;
                this.animal.position.y =
                  Math.abs(Math.sin(this.bouncePhase)) * 0.15;

                // Joyful squash-stretch
                this.squash = 1 + Math.sin(this.bouncePhase * 2) * 0.1;
                this.stretch = 1 - Math.sin(this.bouncePhase * 2) * 0.05;
                this.applySquashStretch();

                // ===== PLAYFUL EXPRESSIONS =====
                const playData = this.animal.userData.animationData;

                // Happy perked up ears
                if (playData && playData.ears) {
                  playData.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      // Perky and bouncy
                      ear.rotation.z =
                        (i === 0 ? -1 : 1) *
                        (0.1 + Math.sin(this.bouncePhase * 2 + i) * 0.1);
                      ear.rotation.x = -0.1; // Forward alert position
                    }
                  });
                }

                // Excited tail wagging
                if (playData && playData.tail) {
                  playData.tail.rotation.z =
                    Math.sin(this.bouncePhase * 3) * 0.4; // Fast wag!
                  playData.tail.rotation.y =
                    Math.sin(this.bouncePhase * 2) * 0.2;
                }

                // Happy head bobbing
                if (playData && playData.head) {
                  playData.head.rotation.x =
                    Math.sin(this.bouncePhase * 2) * 0.1;
                  playData.head.rotation.z = Math.sin(this.bouncePhase) * 0.1;
                }

                if (t > this.stateDuration * 0.8) {
                  this.transitionTo("arriving");
                }
                break;

              case "confused":
                // ===== CONFUSED COLLISION REACTION =====
                const confusedDuration = 0.8;
                const confusedProgress = t / confusedDuration;

                // Shake/wobble animation
                const shakeIntensity = Math.max(0, 1 - confusedProgress) * 0.3;
                this.animal.rotation.z = Math.sin(t * 25) * shakeIntensity;
                this.animal.rotation.x =
                  Math.sin(t * 20) * shakeIntensity * 0.5;

                // Squash down in surprise
                this.squash = 0.85 + Math.sin(t * 15) * 0.1;
                this.stretch = 1.1 - Math.sin(t * 15) * 0.05;
                this.applySquashStretch();

                // Dizzy head shake
                const confData = this.animal.userData.animationData;
                if (confData && confData.head) {
                  confData.head.rotation.y = Math.sin(t * 18) * 0.25;
                  confData.head.rotation.z = Math.sin(t * 22) * 0.15;
                }

                // Ears flattened in surprise
                if (confData && confData.ears) {
                  confData.ears.children.forEach((ear, i) => {
                    if (ear.isMesh || ear.isGroup) {
                      ear.rotation.z = (i === 0 ? -1 : 1) * 0.5; // Flattened
                      ear.rotation.x = 0.3; // Pulled back
                    }
                  });
                }

                // Push apart from collision partner during confusion
                if (this.collisionPartner && confusedProgress < 0.5) {
                  const pushDir = new THREE.Vector3().subVectors(
                    this.animal.position,
                    this.collisionPartner.animal.position
                  );
                  if (pushDir.length() > 0.01) {
                    pushDir.normalize();
                    // Smoothly push apart
                    this.animal.position.x += pushDir.x * deltaTime * 1.5;
                    this.animal.position.z += pushDir.z * deltaTime * 1.5;
                  }
                }

                // Small backward hop
                if (confusedProgress < 0.3) {
                  const hopBack =
                    Math.sin((confusedProgress / 0.3) * Math.PI) * 0.15;
                  this.animal.position.y = hopBack;
                } else {
                  this.animal.position.y *= 0.8; // Settle down
                }

                // After confusion, turn AWAY from partner and go
                if (t > confusedDuration) {
                  // Reset rotation
                  this.animal.rotation.z = 0;
                  this.animal.rotation.x = 0;

                  // Turn to face AWAY from collision partner (or random if no partner)
                  if (this.collisionPartner) {
                    const awayDir = new THREE.Vector3().subVectors(
                      this.animal.position,
                      this.collisionPartner.animal.position
                    );
                    if (awayDir.length() > 0.01) {
                      // Face away from partner with some randomness
                      const awayAngle = Math.atan2(awayDir.x, awayDir.z);
                      this.animal.rotation.y =
                        awayAngle + (Math.random() - 0.5) * 0.5;
                    }
                    this.collisionPartner = null;
                  } else {
                    // Random turn if no partner
                    this.animal.rotation.y +=
                      (Math.random() - 0.5) * Math.PI * 1.5;
                  }

                  // Pick new target and start moving
                  this.pickNewTarget();
                  this.transitionTo("anticipation");
                }
                break;
            }

            // Keep in bounds
            this.animal.position.x = Math.max(
              -this.roomBounds.x,
              Math.min(this.roomBounds.x, this.animal.position.x)
            );
            this.animal.position.z = Math.max(
              -this.roomBounds.z,
              Math.min(this.roomBounds.z, this.animal.position.z)
            );
          }

          applySquashStretch() {
            this.animal.scale.y = this.squash;
            this.animal.scale.x = this.stretch;
            this.animal.scale.z = this.stretch;
          }

          animateBodyParts(hopPhase, deltaTime) {
            const data = this.animal.userData.animationData;
            if (!data) return;

            const walkCycle = this.walkCycle;

            // ===== EAR ANIMATION =====
            if (data.ears) {
              data.ears.children.forEach((ear, i) => {
                if (ear.isMesh || ear.isGroup) {
                  // Bounce ears with each hop (opposite phase for natural look)
                  const earBounce =
                    Math.sin(walkCycle * Math.PI + i * Math.PI) * 0.2;
                  const earFlop = Math.abs(hopPhase) * 0.15;
                  ear.rotation.z =
                    (i === 0 ? -1 : 1) * (0.15 + earBounce + earFlop);
                  // Slight forward/back with movement
                  ear.rotation.x = hopPhase * 0.1;
                }
              });
            }

            // ===== TAIL ANIMATION =====
            if (data.tail) {
              // Tail waves with a delay (drag effect)
              const tailPhase = walkCycle - 0.5; // Lags behind body
              data.tail.rotation.z = Math.sin(tailPhase * 2) * 0.3;
              data.tail.rotation.x = -0.2 + Math.sin(tailPhase) * 0.15;

              // Animate tail segments if they exist
              data.tail.children.forEach((seg, i) => {
                if (seg.isMesh) {
                  const delay = i * 0.3;
                  seg.rotation.z = Math.sin(tailPhase * 2 - delay) * 0.15;
                }
              });
            }

            // ===== HEAD ANIMATION =====
            if (data.head) {
              // Head bobs with walking
              data.head.rotation.x = Math.sin(walkCycle * 2 * Math.PI) * 0.05;
              // Slight side tilt with waddle
              data.head.rotation.z = Math.sin(walkCycle * Math.PI) * 0.03;
            }

            // ===== NOSE ANIMATION =====
            if (data.nose) {
              // Nose twitches faster during movement
              data.nose.rotation.z = Math.sin(walkCycle * 4 * Math.PI) * 0.1;
            }

            // ===== TRUNK ANIMATION (Elephant) =====
            if (data.trunk) {
              // Trunk swings with walking
              data.trunk.rotation.z = Math.sin(walkCycle * Math.PI) * 0.2;
              data.trunk.rotation.x = Math.sin(walkCycle * 2 * Math.PI) * 0.1;
            }

            // ===== THROAT ANIMATION (Frog) =====
            if (data.throat) {
              // Throat pulses faster during hopping
              const pulse = 1 + Math.abs(hopPhase) * 0.3;
              data.throat.scale.set(1.1 * pulse, 0.6 * pulse, 0.8);
            }
          }

          transitionTo(newState) {
            // Reset animation properties for clean transitions
            this.animal.rotation.x = 0;
            this.animal.rotation.z = 0;
            this.squash = 1;
            this.stretch = 1;
            this.applySquashStretch();
            this.walkCycle = 0;
            this.bouncePhase = 0;

            // Special handling for state-specific resets
            if (newState === "idle" || newState === "anticipation") {
              this.animal.position.y = 0;
            }

            this.state = newState;
            this.stateTimer = 0;
            this.stateDuration = 2 + Math.random() * 3;

            if (newState === "anticipation") {
              this.pickNewTarget();
            }
          }
        }

        // Store AI instances
        const animalAIs = [];

        // Spawn animals in their rooms with AI
        function spawnAnimalsInRooms() {
          Object.entries(ROOM_CONFIG).forEach(([roomKey, config]) => {
            const room = rooms[roomKey];
            config.animals.forEach((animalType, index) => {
              const animal = createAnimalModel(animalType);
              // Position animals spread out in room
              const angle = (index / config.animals.length) * Math.PI * 2;
              const radius = 2;
              animal.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
              );
              animal.rotation.y = -angle + Math.PI; // Face center
              room.addAnimal(animal);

              // Create AI for this animal
              const ai = new AnimalAI(animal, config);
              ai.roomKey = roomKey; // Track which room
              animalAIs.push(ai);
            });
          });
        }

        // Initialize rooms with animals
        spawnAnimalsInRooms();

        // Set initial camera for living room
        camera.position.set(0, 3, 8);
        controls.target.set(0, 1, 0);
        controls.update();

        // Event listeners - Room buttons
        document.querySelectorAll(".room-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const roomKey = e.currentTarget.dataset.room;
            if (roomKey) switchRoom(roomKey);
          });
        });

        // Event listeners - Art Style buttons (only inside #style-selector)
        document
          .querySelectorAll("#style-selector .style-btn")
          .forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const styleName = e.currentTarget.dataset.style;
              if (styleName && ART_STYLES[styleName]) {
                // Update active state (only for art style buttons)
                document
                  .querySelectorAll("#style-selector .style-btn")
                  .forEach((b) => b.classList.remove("active"));
                e.currentTarget.classList.add("active");

                // Set art style and respawn to apply correctly
                setArtStyle(styleName);
                respawnAllAnimals();
                console.log(`Art style changed to: ${styleName}`);
              }
            });
          });

        // Update all animal materials with new art style
        function updateAllAnimalMaterials(styleName) {
          Object.values(rooms).forEach((room) => {
            room.animals.forEach((animal) => {
              animal.traverse((child) => {
                if (
                  child.isMesh &&
                  child.material &&
                  !child.userData.preserveMaterial
                ) {
                  const oldColor = child.material.color
                    ? child.material.color.getHex()
                    : 0x888888;
                  child.material = createStyledMaterial(oldColor, styleName);
                }
              });
            });
          });
        }

        // Event listeners - Model Style buttons
        document.querySelectorAll("[data-model-style]").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const styleName = e.currentTarget.dataset.modelStyle;
            // Check both new builder system and legacy MODEL_STYLES
            if (
              styleName &&
              (MODEL_STYLE_BUILDERS[styleName] || MODEL_STYLES[styleName])
            ) {
              // Update active state
              document
                .querySelectorAll("[data-model-style]")
                .forEach((b) => b.classList.remove("active"));
              e.currentTarget.classList.add("active");

              // Set model style and respawn animals
              setModelStyle(styleName);
              respawnAllAnimals();

              console.log(`Switched to style: ${styleName}`);
            } else {
              console.warn(
                `Style "${styleName}" not found in builders or legacy styles`
              );
            }
          });
        });

        // ==========================================
        // VARIANT SELECTOR
        // ==========================================
        const variantAnimalSelect = document.getElementById("variant-animal");
        const variantTypeSelect = document.getElementById("variant-type");
        const applyVariantBtn = document.getElementById("apply-variant");

        // Populate variant dropdown based on selected animal
        function populateVariantDropdown(animalType) {
          variantTypeSelect.innerHTML = "";
          const variants = ANIMAL_VARIANTS[animalType];
          if (variants) {
            Object.entries(variants).forEach(([key, variant]) => {
              const option = document.createElement("option");
              option.value = key;
              option.textContent = variant.name;
              variantTypeSelect.appendChild(option);
            });
          }
        }

        // Initialize with first animal's variants
        populateVariantDropdown("bunny");

        // Update variants when animal changes
        variantAnimalSelect.addEventListener("change", (e) => {
          populateVariantDropdown(e.target.value);
        });

        // Apply selected variant
        applyVariantBtn.addEventListener("click", () => {
          const animalType = variantAnimalSelect.value;
          const variantKey = variantTypeSelect.value;

          // Update current variant for this animal type
          currentVariants[animalType] = variantKey;

          // Find and respawn all animals of this type in all rooms
          Object.entries(rooms).forEach(([roomKey, room]) => {
            const config = ROOM_CONFIG[roomKey];

            // Find animals of this type
            room.animals.forEach((animal, index) => {
              if (animal.userData.type === animalType) {
                // Remove old animal
                room.group.remove(animal);

                // Create new animal with selected variant
                const newAnimal = createAnimalModel(animalType, null, {
                  variant: variantKey,
                });
                newAnimal.position.copy(animal.position);
                newAnimal.rotation.copy(animal.rotation);
                room.animals[index] = newAnimal;
                room.group.add(newAnimal);

                // Update AI reference
                const aiIndex = animalAIs.findIndex(
                  (ai) => ai.animal === animal
                );
                if (aiIndex !== -1) {
                  animalAIs[aiIndex].animal = newAnimal;
                }
              }
            });
          });

          console.log(
            `Applied ${ANIMAL_VARIANTS[animalType][variantKey].name} to all ${animalType}s`
          );
        });

        // ==========================================
        // THEME SELECTOR
        // ==========================================
        document.querySelectorAll("[data-theme]").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const themeKey = e.currentTarget.dataset.theme;
            if (themeKey && ROOM_THEMES[themeKey]) {
              // Update active state
              document
                .querySelectorAll("[data-theme]")
                .forEach((b) => b.classList.remove("active"));
              e.currentTarget.classList.add("active");

              // Apply theme to current room
              applyTheme(themeKey, currentRoom);
            }
          });
        });

        // Apply a theme to a specific room
        function applyTheme(themeKey, roomKey) {
          const theme = ROOM_THEMES[themeKey];
          const room = rooms[roomKey];
          if (!theme || !room) return;

          // Clear old animals from room
          room.animals.forEach((animal) => {
            room.group.remove(animal);
          });
          room.animals.length = 0;

          // Remove AIs for this room
          for (let i = animalAIs.length - 1; i >= 0; i--) {
            if (animalAIs[i].roomKey === roomKey) {
              animalAIs.splice(i, 1);
            }
          }

          // Spawn themed animals
          theme.animals.forEach((animalSpec, index) => {
            const animal = createAnimalModel(animalSpec.type, null, {
              variant: animalSpec.variant,
            });
            const angle = (index / theme.animals.length) * Math.PI * 2;
            const radius = 2;
            animal.position.set(
              Math.cos(angle) * radius,
              0,
              Math.sin(angle) * radius
            );
            animal.rotation.y = -angle + Math.PI;
            room.addAnimal(animal);

            // Create AI
            const config = ROOM_CONFIG[roomKey];
            const ai = new AnimalAI(animal, config);
            ai.roomKey = roomKey;
            animalAIs.push(ai);
          });

          currentRoomTheme = themeKey;
          console.log(`Applied ${theme.name} theme to ${roomKey}`);
        }

        // Respawn all animals with current model style (preserves variants)
        function respawnAllAnimals() {
          // Clear AI references
          animalAIs.length = 0;

          // Respawn for each room
          Object.entries(rooms).forEach(([roomKey, room]) => {
            const config = ROOM_CONFIG[roomKey];

            // Store existing variants before removing
            const existingVariants = room.animals.map((animal) => ({
              type: animal.userData.type,
              variant: animal.userData.variant,
            }));

            // Remove old animals
            room.animals.forEach((animal) => {
              room.group.remove(animal);
            });
            room.animals.length = 0;

            // Spawn new animals with new model style, preserving variants
            config.animals.forEach((type, i) => {
              // Use existing variant if available, otherwise random
              const existingData = existingVariants[i];
              const options =
                existingData && existingData.variant
                  ? { variant: existingData.variant }
                  : {};

              const animal = createAnimalModel(type, null, options);
              const angle = (i / config.animals.length) * Math.PI * 2;
              const radius = 2;
              animal.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
              );
              animal.rotation.y = -angle + Math.PI;
              room.addAnimal(animal);

              // Create AI
              const ai = new AnimalAI(animal, config);
              ai.roomKey = roomKey;
              animalAIs.push(ai);
            });
          });

          console.log(
            `Respawned all animals with style: ${currentModelStyleName}`
          );
        }

        document.querySelectorAll(".color-swatch").forEach((swatch) => {
          swatch.addEventListener("click", (e) => {
            const color = e.currentTarget.dataset.color;
            if (color) changeColor(color);
          });
        });

        // Screenshot
        document
          .getElementById("btn-screenshot")
          .addEventListener("click", () => {
            composer.render();
            const link = document.createElement("a");
            link.download = `vinyl-${currentType}-${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            link.click();
          });

        // Fullscreen
        document
          .getElementById("btn-fullscreen")
          .addEventListener("click", () => {
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else {
              document.documentElement.requestFullscreen();
            }
          });

        // Sound toggle (placeholder)
        let soundEnabled = false;
        document.getElementById("btn-sound").addEventListener("click", (e) => {
          soundEnabled = !soundEnabled;
          e.currentTarget.textContent = soundEnabled ? "ğŸ”Š" : "ğŸ”‡";
        });

        // Panel toggle
        const controlPanel = document.getElementById("control-panel");
        const panelToggle = document.getElementById("panel-toggle");
        let panelVisible = true;

        panelToggle.addEventListener("click", () => {
          panelVisible = !panelVisible;
          if (panelVisible) {
            controlPanel.style.transform = "translateX(-50%) translateY(0)";
            controlPanel.style.opacity = "1";
            controlPanel.style.pointerEvents = "auto";
            panelToggle.textContent = "âš™ï¸";
            panelToggle.style.bottom = "4px";
          } else {
            controlPanel.style.transform = "translateX(-50%) translateY(100%)";
            controlPanel.style.opacity = "0";
            controlPanel.style.pointerEvents = "none";
            panelToggle.textContent = "ğŸ“‹";
            panelToggle.style.bottom = "16px";
          }
        });

        // ==========================================
        // ANIMATION SYSTEM
        // ==========================================
        const clock = new THREE.Clock();

        function tick() {
          const t = clock.getElapsedTime();
          const delta = clock.getDelta();

          // Update particles
          particleBurst.update(delta || 0.016);

          // Update animal AI (only for current room)
          const effectiveDelta = delta || 0.016;
          animalAIs.forEach((ai) => {
            if (ai.roomKey === currentRoom) {
              ai.update(effectiveDelta);
            }
          });

          // Animate all animals in the current visible room
          const room = rooms[currentRoom];
          if (room && room.animals) {
            room.animals.forEach((animal, animalIndex) => {
              const type = animal.userData.type;
              const data = animal.userData.animationData;

              // Offset time per animal for variety
              const at = t + animalIndex * 0.7;

              // ===== ENHANCED BREATHING (localized to body) =====
              const breathCycle = Math.sin(at * 1.8);
              const breath = 1 + breathCycle * 0.015;
              animal.scale.set(1, breath, 1 + breathCycle * 0.008);

              // ===== ENHANCED BLINKING (asymmetric + expressive) =====
              const blinkCycle = 4;
              const blinkPhase = (t % blinkCycle) / blinkCycle;
              // Add occasional slow "sleepy" blink
              const slowBlink = Math.floor(t / 12) % 3 === 0;
              const blinkSpeed = slowBlink ? 0.08 : 0.03;

              let eyeScaleY = 1;
              if (blinkPhase < blinkSpeed) {
                eyeScaleY = 1 - blinkPhase / blinkSpeed; // Close
              } else if (blinkPhase < blinkSpeed * 2) {
                eyeScaleY = (blinkPhase - blinkSpeed) / blinkSpeed; // Open
              }
              // Squash effect during blink (eyes widen slightly horizontally)
              const eyeScaleX = 1 + (1 - eyeScaleY) * 0.15;
              eyeScaleY = Math.max(0.1, eyeScaleY);

              // ===== EYE DART - SMOOTH LOOK, HOLD, RETURN =====
              // Look cycle: 8 seconds total
              // 0-1s: smoothly look to side, 1-2.5s: hold, 2.5-3.5s: return, 3.5-8s: rest
              const lookCycle = 8;
              const lookPhase = t % lookCycle;
              let eyeOffsetX = 0;

              // Determine direction (alternate left/right each cycle)
              const lookDir = Math.floor(t / lookCycle) % 2 === 0 ? 1 : -1;
              const maxOffset = 0.012;

              if (lookPhase < 1.0) {
                // Smooth ease-out to look position
                const progress = lookPhase / 1.0;
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                eyeOffsetX = maxOffset * lookDir * eased;
              } else if (lookPhase < 2.5) {
                // Hold at look position
                eyeOffsetX = maxOffset * lookDir;
              } else if (lookPhase < 3.5) {
                // Smooth ease-in-out return to center
                const progress = (lookPhase - 2.5) / 1.0;
                const eased =
                  progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                eyeOffsetX = maxOffset * lookDir * (1 - eased);
              }
              // else: rest at center (eyeOffsetX = 0)

              // Apply enhanced blink and eye dart to ALL eye parts
              animal.traverse((child) => {
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.eyeWhite
                ) {
                  if (child.userData.origScaleY === undefined) {
                    child.userData.origScaleY = child.scale.y;
                    child.userData.origScaleX = child.scale.x;
                    child.userData.origPosX = child.position.x;
                  }
                  child.scale.y = child.userData.origScaleY * eyeScaleY;
                  child.scale.x = child.userData.origScaleX * eyeScaleX;
                  child.position.x = child.userData.origPosX + eyeOffsetX;
                }
                // Move pupils with eye dart
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.eyeBlack
                ) {
                  if (child.userData.origPosX === undefined) {
                    child.userData.origPosX = child.position.x;
                  }
                  child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
                }
                // Move specular highlights with eye dart too!
                if (
                  child.isMesh &&
                  child.material === SPECIAL_MATERIALS.specular
                ) {
                  if (child.userData.origPosX === undefined) {
                    child.userData.origPosX = child.position.x;
                  }
                  child.position.x = child.userData.origPosX + eyeOffsetX * 1.5;
                }
              });

              // ===== WEIGHT SHIFT (subtle body sway) =====
              const swayPhase = Math.sin(at * 0.7) * 0.008;
              animal.rotation.z = swayPhase;

              // Type-specific animations
              switch (type) {
                case "bunny":
                  // Enhanced ear twitch with independent timing
                  if (data.ears) {
                    data.ears.children.forEach((ear, i) => {
                      const earPhase = t * 3 + i * 1.5;
                      ear.rotation.z =
                        (i === 0 ? -1 : 1) * (0.15 + Math.sin(earPhase) * 0.08);
                      // Occasional alert perk
                      if (Math.floor(t / 6) % 3 === i) {
                        ear.rotation.z += (i === 0 ? -1 : 1) * 0.15;
                      }
                    });
                  }
                  // Faster nose wiggle (bunnies twitch a lot!)
                  if (data.nose) {
                    data.nose.rotation.z = Math.sin(t * 10) * 0.12;
                    data.nose.scale.x = 1 + Math.sin(t * 8) * 0.15;
                  }
                  // Note: Foot thump removed - AI handles hopping now
                  break;

                case "bear":
                  // Enhanced head sway with occasional look around
                  if (data.head) {
                    const lookAround = Math.floor(t / 8) % 2 === 0;
                    const headSwayAmp = lookAround ? 0.08 : 0.03;
                    data.head.rotation.z = Math.sin(t * 1.2) * headSwayAmp;
                    data.head.rotation.y =
                      Math.sin(t * 0.6) * headSwayAmp * 1.5;
                    // Gentle head tilt
                    data.head.rotation.x = Math.sin(t * 0.4) * 0.02;
                  }
                  // Shoulder roll motion
                  animal.rotation.x = Math.sin(t * 0.8) * 0.015;
                  break;

                case "penguin":
                  // Enhanced waddle with happy flipper flutter
                  const waddleSpeed = 2.5;
                  animal.rotation.z = Math.sin(at * waddleSpeed) * 0.06;
                  // Occasional excited hop
                  const hopPhase = at % 10;
                  if (hopPhase > 9.5) {
                    animal.position.y =
                      Math.sin((hopPhase - 9.5) * Math.PI * 2) * 0.05;
                  }
                  break;

                case "fox":
                  // Enhanced tail physics
                  if (data.tail) {
                    data.tail.rotation.z = Math.sin(at * 3) * 0.22;
                    data.tail.rotation.x = -0.25 + Math.sin(at * 1.5) * 0.1;
                    data.tail.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.15;
                        seg.rotation.z = Math.sin(at * 4 - delay) * 0.12;
                      }
                    });
                  }
                  // Alert sniff motion (head bob)
                  if (data.head) {
                    const sniffCycle = at % 4;
                    if (sniffCycle > 3.5) {
                      data.head.rotation.x =
                        Math.sin((sniffCycle - 3.5) * Math.PI * 8) * 0.03;
                    }
                  }
                  break;

                case "elephant":
                  // Trunk sway with curl
                  if (data.trunk) {
                    data.trunk.rotation.z = Math.sin(at * 1.5) * 0.15;
                    data.trunk.rotation.x = Math.sin(at * 0.8) * 0.1;
                    // Wave through trunk segments
                    data.trunk.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.1;
                        seg.position.x = Math.sin(at * 2 - delay) * 0.015;
                      }
                    });
                  }
                  break;

                case "cat":
                  // Enhanced tail swish with physics
                  if (data.tail) {
                    const swishSpeed = 2.5;
                    const swishAmp = 0.28;
                    data.tail.rotation.z = Math.sin(at * swishSpeed) * swishAmp;
                    data.tail.children.forEach((seg, i) => {
                      if (seg.isMesh) {
                        const delay = i * 0.12;
                        seg.rotation.z = Math.sin(at * 3 - delay) * 0.1;
                      }
                    });
                  }
                  // Enhanced ear swivel (independent movement)
                  if (data.ears) {
                    data.ears.children.forEach((ear, i) => {
                      if (i % 2 === 0) {
                        ear.rotation.y = Math.sin(at * 1.8 + i * 0.5) * 0.12;
                      }
                    });
                  }
                  break;

                case "owl":
                  // Enhanced head rotation with tilt
                  if (data.head) {
                    const headRotation = Math.sin(at * 0.5) * 0.35;
                    // Occasional dramatic turn (owls are known for this!)
                    const dramaticTurn =
                      Math.floor(at / 5) % 2 === 0
                        ? Math.sin(((at % 5) * Math.PI) / 5) * 1.8
                        : 0;
                    data.head.rotation.y = headRotation + dramaticTurn * 0.35;
                    // Head tilt (curious look)
                    data.head.rotation.z = Math.sin(at * 0.7) * 0.15;
                  }
                  // Feather ruffle (body puff)
                  const rufflePhase = at % 12;
                  if (rufflePhase > 11.5) {
                    animal.scale.x =
                      1 + Math.sin((rufflePhase - 11.5) * Math.PI * 4) * 0.03;
                  }
                  break;

                case "panda":
                  // Enhanced chewing motion (happy munching!)
                  if (data.muzzle) {
                    const munchSpeed = 5;
                    data.muzzle.scale.y =
                      0.7 + Math.abs(Math.sin(at * munchSpeed)) * 0.12;
                  }
                  if (data.head) {
                    data.head.rotation.x = Math.sin(at * 5) * 0.025;
                    // Gentle side-to-side while eating
                    data.head.rotation.y = Math.sin(at * 0.8) * 0.04;
                  }
                  break;

                case "duck":
                  // Enhanced head rotation with occasional quack
                  if (data.head) {
                    data.head.rotation.x = Math.sin(at * 2.2) * 0.06;
                    data.head.rotation.y = Math.sin(at * 1.3) * 0.04;
                    // Quack motion (head up!)
                    const quackPhase = at % 6;
                    if (quackPhase > 5.5 && quackPhase < 5.7) {
                      data.head.rotation.x = -0.15;
                    }
                  }
                  // Tail waggle
                  const tailWag = Math.sin(at * 4) * 0.03;
                  animal.rotation.z = tailWag;
                  break;

                case "frog":
                  // Enhanced throat pulse
                  if (data.throat) {
                    const pulseSpeed = 2.5;
                    const pulse =
                      1 + Math.max(0, Math.sin(at * pulseSpeed)) * 0.35;
                    data.throat.scale.set(1.1 * pulse, 0.6 * pulse, 0.8);
                  }
                  // Occasional jump anticipation with crouch
                  const jumpPhase = at % 8;
                  if (jumpPhase > 7.3 && jumpPhase < 7.5) {
                    animal.scale.y = 0.92; // Crouch
                  } else if (jumpPhase > 7.5) {
                    animal.position.y = 0.05 + (jumpPhase - 7.5) * 0.12;
                  }
                  break;
              }

              // Gentle idle sway for all
              animal.rotation.z += Math.sin(at * 1.5) * 0.01;
            }); // End forEach animal
          } // End if room

          controls.update();
          composer.render();
          requestAnimationFrame(tick);
        }

        // ==========================================
        // RESIZE HANDLER
        // ==========================================
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading
        setTimeout(() => {
          document.getElementById("loading").style.opacity = "0";
          setTimeout(
            () => (document.getElementById("loading").style.display = "none"),
            700
          );
        }, 800);

        tick();
      } catch (err) {
        console.error(err);
        showError("Failed to initialize 3D scene. " + err.message);
      }
    </script>
  </body>
</html>
