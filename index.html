<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Space Pets (Lite)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
      }
      body {
        font-family: system-ui, -apple-system, sans-serif;
        background: radial-gradient(
          ellipse at 50% 20%,
          #1a1a4a 0%,
          #0a0a1a 50%,
          #050510 100%
        );
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      /* Critical layering: don‚Äôt rely on Tailwind utilities in embedded previews */
      #hud {
        position: fixed;
        top: 14px;
        left: 14px;
        z-index: 1000;
        pointer-events: auto;
        max-width: min(92vw, 420px);
      }

      .glass {
        background: rgba(15, 20, 40, 0.68);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
      }
      .btn {
        padding: 8px 14px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 10px;
        color: #fff;
        font-size: 13px;
        cursor: pointer;
        transition: background 0.2s;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }
      .btn:active {
        transform: translateY(1px);
      }

      #toast {
        position: fixed;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        z-index: 1001;
        padding: 8px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.45);
        color: rgba(255, 255, 255, 0.9);
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }
      #toast.show {
        opacity: 1;
      }

      #boot {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        background: radial-gradient(
          ellipse at 50% 20%,
          rgba(26, 26, 74, 0.95) 0%,
          rgba(10, 10, 26, 0.95) 50%,
          rgba(5, 5, 16, 0.98) 100%
        );
        color: rgba(255, 255, 255, 0.9);
        letter-spacing: 0.02em;
      }

      #errorOverlay {
        position: fixed;
        left: 14px;
        right: 14px;
        bottom: 14px;
        z-index: 3000;
        padding: 12px 14px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.75);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.92);
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        display: none;
        max-height: 44vh;
        overflow: auto;
      }  

      /* Color picker buttons */
      .color-btn {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.3);
        cursor: pointer;
        transition: all 0.2s;
      }
      .color-btn:hover {
        transform: scale(1.15);
        border-color: rgba(255, 255, 255, 0.7);
      }
      .color-btn.selected {
        border-color: #fff;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        transform: scale(1.1);
      }

      /* Gacha modal */
      #gachaModal {
        opacity: 0;
        transition: opacity 0.3s;
      }
      #gachaModal.show {
        opacity: 1;
      }
      #gachaCard {
        min-width: 280px;
      }
      .rarity-common {
        color: #9ca3af;
      }
      .rarity-rare {
        color: #60a5fa;
      }
      .rarity-legendary {
        color: #fbbf24;
        text-shadow: 0 0 12px rgba(251, 191, 36, 0.6);
      }

      @keyframes starPop {
        0% {
          transform: scale(0);
          opacity: 0;
        }
        50% {
          transform: scale(1.3);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      .star-animate {
        display: inline-block;
        animation: starPop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        opacity: 0;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <div id="boot">
      <div class="glass px-5 py-4 text-center">
        <div class="text-lg font-bold">Space Pets</div>
        <div class="text-xs text-white/70 mt-1">Loading 3D scene‚Ä¶</div>
        <div class="text-[11px] text-white/50 mt-3">
          If this hangs, your preview may be blocking CDN scripts.
        </div>
      </div>
    </div>

    <div id="errorOverlay"></div>

    <!-- HUD Overlay -->
    <div id="hud" class="glass p-4 text-white">
      <div class="flex items-center justify-between gap-3">
        <div>
          <h1 class="text-lg font-bold leading-tight">Space Pets</h1>
          <p class="text-xs text-white/70">
            Lite roaming pets (mobile-friendly)
          </p>
        </div>
        <div
          id="perfBadge"
          class="text-[11px] px-2 py-1 rounded-full bg-white/10 border border-white/10 text-white/80"
        ></div>
      </div>

      <div class="flex gap-2 mt-3 flex-wrap">
        <button id="addBtn" class="btn">+ Add Pet</button>
        <button id="resetBtn" class="btn">Reset</button>
      </div>

      <!-- Color Palette Picker -->
      <div class="mt-3">
        <div class="text-[11px] text-white/60 mb-1">Next pet color:</div>
        <div id="colorPalette" class="flex gap-1 flex-wrap">
          <button
            class="color-btn"
            data-color="0xffc8dd"
            style="background: #ffc8dd"
          ></button>
          <button
            class="color-btn"
            data-color="0xffafcc"
            style="background: #ffafcc"
          ></button>
          <button
            class="color-btn"
            data-color="0xbde0fe"
            style="background: #bde0fe"
          ></button>
          <button
            class="color-btn"
            data-color="0xa2d2ff"
            style="background: #a2d2ff"
          ></button>
          <button
            class="color-btn"
            data-color="0xcdb4db"
            style="background: #cdb4db"
          ></button>
          <button
            class="color-btn"
            data-color="0xffd6a5"
            style="background: #ffd6a5"
          ></button>
          <button
            class="color-btn"
            data-color="0xd0f4de"
            style="background: #d0f4de"
          ></button>
          <button
            class="color-btn"
            data-color="0xff6b6b"
            style="background: #ff6b6b"
          ></button>
          <button
            class="color-btn"
            data-color="0x7b2cbf"
            style="background: #7b2cbf"
          ></button>
          <button
            class="color-btn"
            data-color="0xfbbf24"
            style="background: #fbbf24"
          ></button>
        </div>
      </div>

      <div class="mt-3 text-[11px] text-white/70 space-y-1">
        <div><strong>Tap</strong> pet for hearts</div>
        <div><strong>Drag</strong> to pick up & move</div>
        <div>
          <strong>Summon</strong> for rare species! (70% Common, 25% Rare, 5%
          Legendary)
        </div>
      </div>

      <div class="mt-3 flex items-center gap-2">
        <span class="text-[11px] text-white/60">Hold height</span>
        <input
          type="range"
          id="heightSlider"
          min="0.6"
          max="4"
          step="0.1"
          value="1.5"
          class="flex-1"
        />
        <span id="heightVal" class="text-[11px] w-9 text-right">1.5</span>
      </div>

      <div id="petName" class="mt-2 text-sm text-cyan-200"></div>
    </div>

    <div id="toast"></div>

    <script>
      // ======== Robust boot + error overlay (so "blank" never happens silently) ========
      const bootEl = document.getElementById("boot");
      const errorEl = document.getElementById("errorOverlay");

      function showError(err) {
        const msg = err && err.stack ? err.stack : String(err);
        errorEl.style.display = "block";
        errorEl.textContent = "Space Pets failed to start:\n\n" + msg;
        bootEl.style.display = "none";
      }

      window.addEventListener(
        "error",
        (e) => {
          // Capture resource load failures too
          if (e?.error) showError(e.error);
          else if (
            e?.target &&
            (e.target.tagName === "SCRIPT" || e.target.tagName === "LINK")
          ) {
            showError(
              "Resource failed to load: " +
                (e.target.src || e.target.href || "(unknown)")
            );
          }
        },
        true
      );

      window.addEventListener("unhandledrejection", (e) =>
        showError(e.reason || e)
      );

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = src;
          s.async = true;
          s.onload = () => resolve(src);
          s.onerror = () => reject(new Error("Failed to load script: " + src));
          document.head.appendChild(s);
        });
      }

      async function loadAny(sources) {
        let lastErr = null;
        for (const src of sources) {
          try {
            await loadScript(src);
            return src;
          } catch (e) {
            lastErr = e;
          }
        }
        throw lastErr || new Error("Failed to load scripts");
      }

      function hasWebGL() {
        try {
          const c = document.createElement("canvas");
          return !!(
            c.getContext("webgl") || c.getContext("experimental-webgl")
          );
        } catch {
          return false;
        }
      }

      (async function boot() {
        if (!hasWebGL()) {
          showError(
            "WebGL is not available in this browser/context. Try opening in Safari/Chrome directly (not in-app browser)."
          );
          return;
        }

        // Three.js + OrbitControls (CDN fallbacks)
        await loadAny([
          "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js",
          "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js",
        ]);

        await loadAny([
          "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js",
          "https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js",
        ]);

        if (!window.THREE) {
          showError("THREE failed to load.");
          return;
        }

        try {
          startSpacePets();
          bootEl.style.display = "none";
        } catch (err) {
          showError(err);
        }
      })();

      // ======== App code (vanilla Three, optimized for mobile) ========
      function startSpacePets() {
        // --- Simple mobile detection
        const isMobile =
          matchMedia("(pointer: coarse)").matches ||
          Math.min(window.innerWidth, window.innerHeight) < 700;

        const perfBadge = document.getElementById("perfBadge");
        perfBadge.textContent = isMobile ? "MOBILE LITE" : "DESKTOP";

        const toastEl = document.getElementById("toast");
        let toastT = 0;
        function toast(msg) {
          toastEl.textContent = msg;
          toastEl.classList.add("show");
          clearTimeout(toastT);
          toastT = setTimeout(() => toastEl.classList.remove("show"), 1100);
        }

        // ============ CONFIG ============
        const GROUND_Y = 0;
        let holdHeight = 1.5;
        let heldPet = null;
        let hoveredPet = null;
        const pets = [];
        const MAX_PETS = isMobile ? 16 : 36;
        const WORLD_BOUNDS = 16;

        const petNames = [
          "Nova",
          "Mochi",
          "Cosmo",
          "Luna",
          "Pip",
          "Byte",
          "Orion",
          "Sprout",
          "Echo",
          "Miso",
          "Comet",
          "Ziggy",
          "Bean",
          "Nori",
          "Pebble",
        ];

        const SPECIES = {
          cat: {
            key: "cat",
            label: "Cat",
            emoji: "üê±",
            earType: "pointy",
            snoutScale: [0.9, 0.7, 0.9],
            snoutPos: [0, -0.08, 0.36],
            tailType: "long",
            whiskers: true,
            roam: { min: 1.0, max: 2.8 },
          },
          duck: {
            key: "duck",
            label: "Duck",
            emoji: "ü¶Ü",
            earType: "floppy",
            snoutScale: [1.0, 0.75, 1.5],
            snoutPos: [0, -0.06, 0.42],
            tailType: "short",
            whiskers: false,
            roam: { min: 0.9, max: 2.2 },
          },
        };

        // Helper to get species array for random selection
        const SPECIES_LIST = Object.values(SPECIES);

        // ============ UI refs (define early to avoid TDZ problems) ============
        const addBtn = document.getElementById("addBtn");
        const resetBtn = document.getElementById("resetBtn");
        const heightSlider = document.getElementById("heightSlider");
        const heightVal = document.getElementById("heightVal");
        const petNameEl = document.getElementById("petName");

        // ============ THREE SETUP ============
        const container = document.getElementById("app");
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x050510, 12, 50);

        const camera = new THREE.PerspectiveCamera(
          55,
          window.innerWidth / window.innerHeight,
          0.1,
          160
        );
        camera.position.set(0, 5, 12);

        let renderer;
        try {
          renderer = new THREE.WebGLRenderer({
            antialias: !isMobile,
            alpha: true,
            powerPreference: "high-performance",
          });
        } catch (e) {
          throw new Error(
            "WebGLRenderer failed to initialize. " + (e?.message || e)
          );
        }

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(
          Math.min(window.devicePixelRatio || 1, isMobile ? 1.15 : 2)
        );

        // Shadows are expensive on phones
        renderer.shadowMap.enabled = !isMobile;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x050510, 1);

        // Ensure only one canvas exists if hot-reloaded
        container.innerHTML = "";
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.maxPolarAngle = Math.PI * 0.48;
        controls.minDistance = 5;
        controls.maxDistance = 32;
        controls.enablePan = false;

        // Desktop mouse mapping
        controls.mouseButtons = {
          LEFT: null,
          MIDDLE: THREE.MOUSE.DOLLY,
          RIGHT: THREE.MOUSE.ROTATE,
        };

        // Touch: one-finger rotate if not holding pet; two-finger dolly
        controls.touches = {
          ONE: THREE.TOUCH.ROTATE,
          TWO: THREE.TOUCH.DOLLY_PAN,
        };

        // ============ LIGHTING (Toony) ============
        scene.add(new THREE.AmbientLight(0x8899ff, 0.7));

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(8, 12, 5);
        mainLight.castShadow = !isMobile;
        if (!isMobile) {
          mainLight.shadow.mapSize.width = 1024;
          mainLight.shadow.mapSize.height = 1024;
          mainLight.shadow.camera.near = 1;
          mainLight.shadow.camera.far = 40;
          mainLight.shadow.camera.left = -16;
          mainLight.shadow.camera.right = 16;
          mainLight.shadow.camera.top = 16;
          mainLight.shadow.camera.bottom = -16;
        }
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0x6688ff, 0.45);
        fillLight.position.set(-6, 7, -8);
        scene.add(fillLight);

        // ============ TOON GRADIENT ============
        function createToonGradient() {
          // 3-step luminance ramp (dark-mid-light)
          const data = new Uint8Array([55, 140, 255]);
          const tex = new THREE.DataTexture(data, 3, 1, THREE.LuminanceFormat);
          tex.minFilter = THREE.NearestFilter;
          tex.magFilter = THREE.NearestFilter;
          tex.needsUpdate = true;
          return tex;
        }
        const toonGradient = createToonGradient();

        // ============ STARS (light) ============
        function createStars(count) {
          const geometry = new THREE.BufferGeometry();
          const vertices = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            const r = 65 + Math.random() * 30;
            const theta = Math.random() * Math.PI * 2;
            const u = Math.random() * 2 - 1;
            const phi = Math.acos(u);
            const idx = i * 3;
            vertices[idx] = r * Math.sin(phi) * Math.cos(theta);
            vertices[idx + 1] = r * Math.sin(phi) * Math.sin(theta);
            vertices[idx + 2] = r * Math.cos(phi);
          }
          geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(vertices, 3)
          );
          const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: isMobile ? 0.42 : 0.55,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9,
          });
          const points = new THREE.Points(geometry, material);
          points.frustumCulled = false;
          return points;
        }
        const stars = createStars(isMobile ? 460 : 980);
        scene.add(stars);
        let twinkleSeed = Math.random() * Math.PI * 2;

        // ============ FLOOR + GRID ============
        const floor = new THREE.Mesh(
          new THREE.PlaneGeometry(80, 80),
          new THREE.MeshToonMaterial({
            color: 0x07071c,
            gradientMap: toonGradient,
          })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = GROUND_Y;
        floor.receiveShadow = !isMobile;
        scene.add(floor);

        const grid = new THREE.GridHelper(
          isMobile ? 34 : 44,
          isMobile ? 22 : 36,
          0x4460ff,
          0x1a1a44
        );
        grid.material.transparent = true;
        grid.material.opacity = 0.35;
        grid.position.y = GROUND_Y + 0.01;
        scene.add(grid);

        // ============ PETS ============
        const colliderGeometry = new THREE.SphereGeometry(0.85, 8, 6);
        const colliderMaterial = new THREE.MeshBasicMaterial({
          transparent: true,
          opacity: 0.0,
          depthWrite: false,
        });

        // Low-poly shared geometries
        const GEO = (() => {
          const sA = isMobile ? 12 : 20;
          const sB = isMobile ? 9 : 14;
          const tailRadial = isMobile ? 7 : 11;
          return {
            body: new THREE.SphereGeometry(0.55, sA, sB),
            bodyOutline: new THREE.SphereGeometry(0.6, sA, sB),
            belly: new THREE.SphereGeometry(
              0.32,
              isMobile ? 10 : 16,
              isMobile ? 8 : 12
            ),
            head: new THREE.SphereGeometry(0.42, sA, sB),
            headOutline: new THREE.SphereGeometry(0.46, sA, sB),
            snout: new THREE.SphereGeometry(
              0.18,
              isMobile ? 9 : 13,
              isMobile ? 7 : 10
            ),
            nose: new THREE.SphereGeometry(0.05, 8, 6),
            eye: new THREE.SphereGeometry(0.06, 8, 6),
            highlight: new THREE.SphereGeometry(0.02, 6, 5),
            blush: new THREE.SphereGeometry(0.06, 8, 6),
            ear: new THREE.ConeGeometry(0.12, 0.3, isMobile ? 7 : 11),
            earOutline: new THREE.ConeGeometry(0.14, 0.32, isMobile ? 7 : 11),
            longEar: new THREE.CylinderGeometry(
              0.055,
              0.04,
              0.6,
              isMobile ? 7 : 10,
              1
            ),
            tail: new THREE.CylinderGeometry(0.06, 0.06, 0.55, tailRadial, 1),
            tailLong: new THREE.CylinderGeometry(
              0.055,
              0.05,
              0.85,
              tailRadial,
              1
            ),
            tip: new THREE.SphereGeometry(0.1, 8, 6),
            foot: new THREE.SphereGeometry(0.12, 8, 6),
            whisker: new THREE.CylinderGeometry(0.01, 0.01, 0.38, 6, 1),
            pom: new THREE.SphereGeometry(0.11, 8, 6),
            earFlop: new THREE.SphereGeometry(
              0.12,
              isMobile ? 9 : 12,
              isMobile ? 7 : 10
            ),
          };
        })();

        const colliders = []; // raycast list

        // Reusable temp vecs to avoid allocations
        const _v1 = new THREE.Vector3();
        const _v2 = new THREE.Vector3();
        const _v3 = new THREE.Vector3();
        const cursorWorld = new THREE.Vector3(0, 0.6, 0);

        function lerpAngle(a, b, t) {
          let diff = ((b - a + Math.PI) % (Math.PI * 2)) - Math.PI;
          return a + diff * t;
        }

        function pickSpecies() {
          // Randomly pick from available species (Cat or Duck)
          return SPECIES_LIST[(Math.random() * SPECIES_LIST.length) | 0];
        }

        function pickColor(speciesKey) {
          // Slightly more "real animal" palette while staying kawaii
          const palettes = {
            cat: [0x8f8f9a, 0x5a5a66, 0xe0b7a5, 0xc8c8d6],
            dog: [0xd2a679, 0x9a6b43, 0xf2e6d8, 0xc8b28a],
            bunny: [0xf5f5f8, 0xe6d3ef, 0xd8dde6, 0xf1d1d9],
          };
          const arr = palettes[speciesKey] || [0x7bd7ff, 0xff9bd4, 0xa7ff7b];
          return new THREE.Color(
            arr[(Math.random() * arr.length) | 0]
          ).offsetHSL((Math.random() - 0.5) * 0.05, 0.05, 0.03);
        }

        class Pet {
          constructor(x, z, color, species) {
            this.id = Math.random().toString(36).slice(2);
            this.species = species || pickSpecies();
            this.name =
              petNames[(Math.random() * petNames.length) | 0] +
              " " +
              ((Math.random() * 100) | 0);

            this.baseColor = new THREE.Color(
              color !== null ? color : pickColor(this.species.key)
            );
            this.outlineColor = this.baseColor.clone().multiplyScalar(0.35);

            this.group = new THREE.Group();
            this.group.position.set(x, 0.6, z);
            this.group.userData.pet = this;

            this.velocity = new THREE.Vector3();
            this.targetPos = new THREE.Vector3(x, 0.6, z);
            this.wanderTarget = new THREE.Vector3(x, 0.6, z);
            this.wanderTimer = 0.5 + Math.random() * 1.5;
            this.pauseTimer = 0;

            this.isHeld = false;
            this.bobPhase = Math.random() * Math.PI * 2;
            this.blinkTimer = 1 + Math.random() * 2;
            this.isBlinking = false;

            // Collider used for picking (fast)
            this.collider = new THREE.Mesh(colliderGeometry, colliderMaterial);
            this.collider.userData.parentPet = this;
            this.collider.position.set(0, 0.15, 0);
            this.group.add(this.collider);
            colliders.push(this.collider);

            this.createBody();
            scene.add(this.group);
          }

          createBody() {
            const bodyMat = new THREE.MeshToonMaterial({
              color: this.baseColor,
              gradientMap: toonGradient,
            });
            const whiteMat = new THREE.MeshToonMaterial({
              color: 0xffffff,
              gradientMap: toonGradient,
            });
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111122 });
            const blushMat = new THREE.MeshToonMaterial({
              color: 0xff6699,
              gradientMap: toonGradient,
              transparent: true,
              opacity: 0.6,
            });
            const outlineMat = new THREE.MeshBasicMaterial({
              color: this.outlineColor,
              side: THREE.BackSide,
            });

            // Body
            const body = new THREE.Mesh(GEO.body, bodyMat);
            body.castShadow = !isMobile;
            this.group.add(body);

            const bodyOutline = new THREE.Mesh(GEO.bodyOutline, outlineMat);
            this.group.add(bodyOutline);

            // Belly
            const belly = new THREE.Mesh(GEO.belly, whiteMat);
            belly.position.set(0, -0.05, 0.28);
            belly.scale.set(1, 0.85, 0.7);
            this.group.add(belly);

            // Head
            this.head = new THREE.Group();
            this.head.position.set(0, 0.52, 0.12);
            this.group.add(this.head);

            const headMesh = new THREE.Mesh(GEO.head, bodyMat);
            headMesh.castShadow = !isMobile;
            this.head.add(headMesh);

            const headOutline = new THREE.Mesh(GEO.headOutline, outlineMat);
            this.head.add(headOutline);

            // Snout (species tweak)
            const snout = new THREE.Mesh(GEO.snout, whiteMat);
            snout.position.set(
              this.species.snoutPos[0],
              this.species.snoutPos[1],
              this.species.snoutPos[2]
            );
            snout.scale.set(
              this.species.snoutScale[0],
              this.species.snoutScale[1],
              this.species.snoutScale[2]
            );
            this.head.add(snout);

            // Nose
            const nose = new THREE.Mesh(GEO.nose, eyeMat);
            nose.position.set(0, -0.03, 0.5);
            if (this.species.key === "dog") nose.position.z = 0.53;
            this.head.add(nose);

            // Eyes
            this.leftEye = new THREE.Mesh(GEO.eye, eyeMat);
            this.leftEye.position.set(-0.14, 0.06, 0.36);
            this.head.add(this.leftEye);

            this.rightEye = new THREE.Mesh(GEO.eye, eyeMat);
            this.rightEye.position.set(0.14, 0.06, 0.36);
            this.head.add(this.rightEye);

            // Highlights
            const highlightMat = new THREE.MeshBasicMaterial({
              color: 0xffffff,
            });
            const leftHighlight = new THREE.Mesh(GEO.highlight, highlightMat);
            leftHighlight.position.set(-0.12, 0.08, 0.41);
            this.head.add(leftHighlight);

            const rightHighlight = new THREE.Mesh(GEO.highlight, highlightMat);
            rightHighlight.position.set(0.16, 0.08, 0.41);
            this.head.add(rightHighlight);

            // Blush
            const leftBlush = new THREE.Mesh(GEO.blush, blushMat);
            leftBlush.position.set(-0.24, -0.02, 0.32);
            leftBlush.scale.set(1.4, 0.6, 0.4);
            this.head.add(leftBlush);

            const rightBlush = new THREE.Mesh(GEO.blush, blushMat);
            rightBlush.position.set(0.24, -0.02, 0.32);
            rightBlush.scale.set(1.4, 0.6, 0.4);
            this.head.add(rightBlush);

            // Ears (species variants)
            if (this.species.earType === "pointy") {
              const leftEar = new THREE.Mesh(GEO.ear, bodyMat);
              leftEar.position.set(-0.22, 0.35, 0);
              leftEar.rotation.z = 0.3;
              this.head.add(leftEar);

              const leftEarOutline = new THREE.Mesh(GEO.earOutline, outlineMat);
              leftEarOutline.position.copy(leftEar.position);
              leftEarOutline.rotation.copy(leftEar.rotation);
              this.head.add(leftEarOutline);

              const rightEar = new THREE.Mesh(GEO.ear, bodyMat);
              rightEar.position.set(0.22, 0.35, 0);
              rightEar.rotation.z = -0.3;
              this.head.add(rightEar);

              const rightEarOutline = new THREE.Mesh(
                GEO.earOutline,
                outlineMat
              );
              rightEarOutline.position.copy(rightEar.position);
              rightEarOutline.rotation.copy(rightEar.rotation);
              this.head.add(rightEarOutline);
            } else if (this.species.earType === "floppy") {
              // Floppy dog ears: stretched spheres
              const makeFlop = (sx) => {
                const ear = new THREE.Mesh(GEO.earFlop, bodyMat);
                ear.scale.set(0.7, 1.55, 0.55);
                ear.position.set(sx * 0.26, 0.27, 0.02);
                ear.rotation.z = sx * 0.65;
                ear.rotation.x = 0.15;
                this.head.add(ear);

                const earO = new THREE.Mesh(GEO.earFlop, outlineMat);
                earO.scale.copy(ear.scale).multiplyScalar(1.06);
                earO.position.copy(ear.position);
                earO.rotation.copy(ear.rotation);
                this.head.add(earO);
              };
              makeFlop(-1);
              makeFlop(1);
            } else {
              // Bunny long ears
              const makeLong = (sx) => {
                const ear = new THREE.Mesh(GEO.longEar, bodyMat);
                ear.position.set(sx * 0.16, 0.48, -0.02);
                ear.rotation.z = sx * 0.16;
                ear.rotation.x = -0.15;
                this.head.add(ear);

                const earO = new THREE.Mesh(GEO.longEar, outlineMat);
                earO.scale.set(1.07, 1.06, 1.07);
                earO.position.copy(ear.position);
                earO.rotation.copy(ear.rotation);
                this.head.add(earO);

                const tip = new THREE.Mesh(GEO.tip, whiteMat);
                tip.scale.set(0.7, 0.7, 0.7);
                tip.position.set(sx * 0.16, 0.78, -0.02);
                this.head.add(tip);
              };
              makeLong(-1);
              makeLong(1);
            }

            // Whiskers (cat)
            if (this.species.whiskers) {
              const whiskMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
              const makeWhisk = (sx, y, z, rotY) => {
                const w = new THREE.Mesh(GEO.whisker, whiskMat);
                w.position.set(sx * 0.2, y, z);
                w.rotation.z = Math.PI / 2;
                w.rotation.y = rotY;
                w.scale.set(1, 1, 1);
                this.head.add(w);
              };
              makeWhisk(-1, -0.02, 0.44, 0.25);
              makeWhisk(-1, -0.06, 0.44, 0.05);
              makeWhisk(1, -0.02, 0.44, -0.25);
              makeWhisk(1, -0.06, 0.44, -0.05);
            }

            // Tail
            this.tail = new THREE.Group();
            this.tail.position.set(0, 0.05, -0.5);
            this.group.add(this.tail);

            if (this.species.tailType === "long") {
              const tailSeg = new THREE.Mesh(GEO.tailLong, bodyMat);
              tailSeg.position.set(0, 0.3, -0.18);
              tailSeg.rotation.x = Math.PI * 0.45;
              this.tail.add(tailSeg);

              const tailTip = new THREE.Mesh(GEO.tip, whiteMat);
              tailTip.scale.set(0.8, 0.8, 0.8);
              tailTip.position.set(0, 0.58, -0.52);
              this.tail.add(tailTip);
            } else if (this.species.tailType === "pom") {
              const pom = new THREE.Mesh(GEO.pom, whiteMat);
              pom.position.set(0, 0.13, -0.6);
              this.tail.add(pom);
            } else {
              const tailSeg = new THREE.Mesh(GEO.tail, bodyMat);
              tailSeg.position.set(0, 0.2, -0.12);
              tailSeg.rotation.x = Math.PI * 0.35;
              this.tail.add(tailSeg);

              const tailTip = new THREE.Mesh(GEO.tip, whiteMat);
              tailTip.position.set(0, 0.38, -0.36);
              this.tail.add(tailTip);
            }

            // Feet
            const positions = [
              [-0.22, -0.38, 0.18],
              [0.22, -0.38, 0.18],
              [-0.22, -0.38, -0.15],
              [0.22, -0.38, -0.15],
            ];
            for (let i = 0; i < positions.length; i++) {
              const p = positions[i];
              const foot = new THREE.Mesh(GEO.foot, whiteMat);
              foot.position.set(p[0], p[1], p[2]);
              foot.castShadow = !isMobile;
              this.group.add(foot);
            }
          }

          chooseNewWander() {
            const r = 0.25 + Math.random() * 0.75;
            const tx = (Math.random() * 2 - 1) * WORLD_BOUNDS * r;
            const tz = (Math.random() * 2 - 1) * WORLD_BOUNDS * r;
            this.wanderTarget.set(tx, 0.6, tz);
            this.wanderTimer =
              this.species.roam.min +
              Math.random() * (this.species.roam.max - this.species.roam.min);

            // Small chance to pause (cute idle)
            if (Math.random() < 0.22) {
              this.pauseTimer = 0.7 + Math.random() * 1.6;
            }
          }

          update(time, dt) {
            // Calculate movement speed for animations
            const vx = this.velocity.x;
            const vz = this.velocity.z;
            const speed = Math.sqrt(vx * vx + vz * vz);
            const isMoving = speed > 0.01 && this.pauseTimer <= 0;

            // Autonomous roaming (when not held)
            if (!this.isHeld) {
              if (this.pauseTimer > 0) {
                this.pauseTimer -= dt;
              } else {
                this.wanderTimer -= dt;
                if (this.wanderTimer <= 0) this.chooseNewWander();

                // Smoothly interpolate target position (no teleporting!)
                const lerpSpeed = 0.02;
                this.targetPos.x = THREE.MathUtils.lerp(
                  this.targetPos.x,
                  this.wanderTarget.x,
                  lerpSpeed
                );
                this.targetPos.z = THREE.MathUtils.lerp(
                  this.targetPos.z,
                  this.wanderTarget.z,
                  lerpSpeed
                );
              }

              // Face movement direction smoothly
              _v2.set(
                this.targetPos.x - this.group.position.x,
                0,
                this.targetPos.z - this.group.position.z
              );
              const dist = _v2.length();
              if (dist > 0.05) {
                const targetYaw = Math.atan2(_v2.x, _v2.z);
                // Smoother rotation - slower turn rate for natural movement
                this.group.rotation.y = lerpAngle(
                  this.group.rotation.y,
                  targetYaw,
                  0.06
                );
              }
            }

            // ===== CUTE WADDLE ANIMATIONS =====
            const walkCycle =
              time * (this.species.key === "bunny" ? 8 : 5) + this.bobPhase;

            // Bobbing - more pronounced when moving
            if (!this.isHeld) {
              const bobFreq = isMoving ? 5.5 : 2.0;
              const bobAmp = isMoving ? 0.08 : 0.03;
              const bob = Math.sin(time * bobFreq + this.bobPhase) * bobAmp;

              // Hop effect for bunnies
              const hopBonus =
                this.species.key === "bunny" && isMoving
                  ? Math.max(0, Math.sin(walkCycle * 1.2)) * 0.12
                  : 0;

              this.group.position.y = 0.6 + bob + hopBonus;
              if (hoveredPet === this) this.group.position.y += 0.14;
            }

            // Side-to-side waddle (roll) - penguin-like wobble
            if (!this.isHeld) {
              const waddleAmp = isMoving ? 0.12 : 0.03;
              const waddleFreq = isMoving ? 5.5 : 2.0;
              const waddle =
                Math.sin(time * waddleFreq + this.bobPhase) * waddleAmp;
              this.group.rotation.z = THREE.MathUtils.lerp(
                this.group.rotation.z,
                waddle,
                0.15
              );

              // Forward tilt when moving (lean into movement)
              const tiltAmount = isMoving ? -0.08 : 0;
              this.group.rotation.x = THREE.MathUtils.lerp(
                this.group.rotation.x,
                tiltAmount,
                0.1
              );
            }

            // Head bobbing and curiosity
            if (this.head) {
              const wantsLook = hoveredPet === this || this.isHeld;
              const lookStrength = wantsLook ? 0.12 : 0.06;

              if (wantsLook) {
                _v3.copy(cursorWorld);
                this.group.worldToLocal(_v3);
                const yaw = Math.atan2(_v3.x, _v3.z);
                const pitch = -Math.atan2(
                  _v3.y - 0.1,
                  Math.max(0.001, Math.sqrt(_v3.x * _v3.x + _v3.z * _v3.z))
                );
                const cy = THREE.MathUtils.clamp(yaw, -0.65, 0.65);
                const cx = THREE.MathUtils.clamp(pitch, -0.35, 0.25);
                this.head.rotation.y = lerpAngle(
                  this.head.rotation.y,
                  cy,
                  lookStrength
                );
                this.head.rotation.x = THREE.MathUtils.lerp(
                  this.head.rotation.x,
                  cx,
                  lookStrength
                );
              } else {
                // Gentle head bob while walking
                const headBob = isMoving ? Math.sin(walkCycle * 1.1) * 0.08 : 0;
                const headTilt =
                  Math.sin(time * 0.8 + this.bobPhase * 2) * 0.04; // Slight curiosity tilt
                this.head.rotation.y = lerpAngle(
                  this.head.rotation.y,
                  headTilt,
                  0.08
                );
                this.head.rotation.x = THREE.MathUtils.lerp(
                  this.head.rotation.x,
                  headBob - 0.05,
                  0.08
                );
              }

              // Ear twitching (if ears exist)
              if (this.leftEar && this.rightEar) {
                const twitch = Math.sin(time * 4 + this.bobPhase * 3) * 0.15;
                const randomTwitch =
                  Math.sin(time * 7.3 + this.bobPhase) > 0.92 ? 0.2 : 0;
                this.leftEar.rotation.z = 0.3 + twitch + randomTwitch;
                this.rightEar.rotation.z = -0.3 - twitch - randomTwitch;
              }
            }

            // Tail wag - faster and more vigorous when moving/excited
            const excitement = isMoving ? 1.3 : 1.0;
            const hoverExcitement = hoveredPet === this ? 1.5 : 1.0;
            const wagSpeed = this.isHeld
              ? 11
              : this.species.key === "cat"
              ? 4.6 * excitement
              : this.species.key === "dog"
              ? 7.0 * excitement * hoverExcitement
              : 4.5 * excitement;
            const wagAmount = this.isHeld
              ? 0.75
              : this.species.key === "dog"
              ? 0.65 * hoverExcitement
              : 0.4;
            this.tail.rotation.y = Math.sin(time * wagSpeed) * wagAmount;
            this.tail.rotation.x = Math.cos(time * wagSpeed * 0.7) * 0.22;

            // Blink with personality
            this.blinkTimer -= dt;
            if (this.blinkTimer <= 0) {
              this.isBlinking = !this.isBlinking;
              this.blinkTimer = this.isBlinking
                ? 0.08 + Math.random() * 0.04
                : 1.5 + Math.random() * 3.5;
            }
            const eyeScale = this.isBlinking ? 0.08 : 1;
            this.leftEye.scale.y = THREE.MathUtils.lerp(
              this.leftEye.scale.y,
              eyeScale,
              0.4
            );
            this.rightEye.scale.y = THREE.MathUtils.lerp(
              this.rightEye.scale.y,
              eyeScale,
              0.4
            );

            // Happy squint when petted/hovered
            if (hoveredPet === this && !this.isBlinking) {
              this.leftEye.scale.y = THREE.MathUtils.lerp(
                this.leftEye.scale.y,
                0.7,
                0.1
              );
              this.rightEye.scale.y = THREE.MathUtils.lerp(
                this.rightEye.scale.y,
                0.7,
                0.1
              );
            }

            // Held wiggle
            if (this.isHeld) {
              this.group.rotation.z = Math.sin(time * 9) * 0.12;
              this.group.rotation.x = Math.cos(time * 7) * 0.06;
            }

            // ===== SMOOTH PHYSICS-BASED MOVEMENT =====
            // Much softer spring for natural, gradual movement
            const spring = this.isHeld ? 8 : 1.5; // Reduced from 7.5 to 1.5
            const damping = this.isHeld ? 0.75 : 0.92; // Increased damping for smooth stop

            _v1.subVectors(this.targetPos, this.group.position);
            _v1.y = 0; // Don't affect Y velocity
            this.velocity.add(_v1.multiplyScalar(spring * dt));
            this.velocity.multiplyScalar(damping);

            // Clamp max speed for natural movement
            const maxSpeed = this.species.key === "bunny" ? 0.08 : 0.05;
            const currentSpeed = Math.sqrt(
              this.velocity.x * this.velocity.x +
                this.velocity.z * this.velocity.z
            );
            if (currentSpeed > maxSpeed) {
              this.velocity.x = (this.velocity.x / currentSpeed) * maxSpeed;
              this.velocity.z = (this.velocity.z / currentSpeed) * maxSpeed;
            }

            this.group.position.x += this.velocity.x * dt * 60;
            this.group.position.z += this.velocity.z * dt * 60;

            // Keep within bounds
            this.group.position.x = THREE.MathUtils.clamp(
              this.group.position.x,
              -WORLD_BOUNDS,
              WORLD_BOUNDS
            );
            this.group.position.z = THREE.MathUtils.clamp(
              this.group.position.z,
              -WORLD_BOUNDS,
              WORLD_BOUNDS
            );

            // Squash/stretch based on speed (subtle)
            const squashAmount = isMoving ? 0.06 : 0;
            const squash = 1 + Math.abs(Math.sin(walkCycle)) * squashAmount;
            const stretch =
              1 - Math.abs(Math.sin(walkCycle)) * squashAmount * 0.5;
            this.group.scale.set(
              THREE.MathUtils.lerp(this.group.scale.x, stretch, 0.12),
              THREE.MathUtils.lerp(this.group.scale.y, squash, 0.12),
              THREE.MathUtils.lerp(this.group.scale.z, stretch, 0.12)
            );
          }

          grab() {
            this.isHeld = true;
            this.targetPos.y = holdHeight;
            this.pauseTimer = 0;
          }

          release() {
            this.isHeld = false;
            this.targetPos.y = 0.6;
            this.velocity.y = -2.0;
            this.chooseNewWander();
          }

          moveTo(x, z) {
            this.targetPos.x = THREE.MathUtils.clamp(
              x,
              -WORLD_BOUNDS,
              WORLD_BOUNDS
            );
            this.targetPos.z = THREE.MathUtils.clamp(
              z,
              -WORLD_BOUNDS,
              WORLD_BOUNDS
            );
            this.wanderTarget.x = this.targetPos.x;
            this.wanderTarget.z = this.targetPos.z;
          }
        }

        // ============ INITIAL PETS ============
        function removeCollider(c) {
          const idx = colliders.indexOf(c);
          if (idx >= 0) colliders.splice(idx, 1);
        }

        function clearPets() {
          for (let i = 0; i < pets.length; i++) {
            scene.remove(pets[i].group);
          }
          pets.length = 0;
          colliders.length = 0;
          heldPet = null;
          hoveredPet = null;
          petNameEl.textContent = "";
        }

        function createInitialPets() {
          clearPets();
          pets.push(new Pet(-2.2, 0.6, null, SPECIES.cat));
          pets.push(new Pet(0.0, -1.0, null, SPECIES.dog));
          pets.push(new Pet(2.2, 0.8, null, SPECIES.bunny));

          if (isMobile) {
            // Keep 2 pets on mobile (remove third cleanly)
            const removed = pets.pop();
            scene.remove(removed.group);
            removeCollider(removed.collider);
          }
        }
        createInitialPets();

        // ============ RAYCASTING (colliders) ============
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        const intersectPoint = new THREE.Vector3();
        const dragOffset = new THREE.Vector3();

        function updateMouseFromClient(clientX, clientY) {
          mouse.x = (clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(clientY / window.innerHeight) * 2 + 1;
        }

        function getPetUnderMouse() {
          if (colliders.length === 0) return null;
          raycaster.setFromCamera(mouse, camera);
          const hits = raycaster.intersectObjects(colliders, false);
          if (hits.length) return hits[0].object.userData.parentPet;
          return null;
        }

        function getPlaneIntersection(y) {
          dragPlane.constant = -y;
          raycaster.setFromCamera(mouse, camera);
          raycaster.ray.intersectPlane(dragPlane, intersectPoint);
          return intersectPoint;
        }

        // ============ POINTER EVENTS (mobile-friendly) ============
        let activePointerId = null;

        function setCursor(state) {
          renderer.domElement.style.cursor = state;
        }

        renderer.domElement.addEventListener(
          "pointermove",
          (e) => {
            updateMouseFromClient(e.clientX, e.clientY);
            cursorWorld.copy(getPlaneIntersection(0.6));

            if (heldPet && e.pointerId === activePointerId) {
              const point = getPlaneIntersection(holdHeight);
              heldPet.moveTo(point.x + dragOffset.x, point.z + dragOffset.z);
            } else if (!heldPet) {
              const pet = getPetUnderMouse();
              if (pet !== hoveredPet) {
                hoveredPet = pet;
                setCursor(pet ? "grab" : "default");
                petNameEl.textContent = pet
                  ? "üêæ " + pet.species.label + " ‚Äî " + pet.name
                  : "";
              }
            }
          },
          { passive: true }
        );

        renderer.domElement.addEventListener(
          "pointerdown",
          (e) => {
            if (!e.isPrimary) return;

            updateMouseFromClient(e.clientX, e.clientY);
            cursorWorld.copy(getPlaneIntersection(0.6));
            const pet = getPetUnderMouse();

            if (pet) {
              e.preventDefault();
              activePointerId = e.pointerId;
              if (renderer.domElement.setPointerCapture)
                renderer.domElement.setPointerCapture(e.pointerId);

              heldPet = pet;
              pet.grab();
              controls.enabled = false;
              setCursor("grabbing");

              const point = getPlaneIntersection(holdHeight);
              dragOffset.set(
                pet.group.position.x - point.x,
                0,
                pet.group.position.z - point.z
              );
            }
          },
          { passive: false }
        );

        function endHold(pointerId) {
          if (heldPet && (activePointerId === pointerId || pointerId == null)) {
            heldPet.release();
            heldPet = null;
            activePointerId = null;
            controls.enabled = true;
            setCursor(hoveredPet ? "grab" : "default");
          }
        }

        renderer.domElement.addEventListener(
          "pointerup",
          (e) => endHold(e.pointerId),
          { passive: true }
        );
        renderer.domElement.addEventListener(
          "pointercancel",
          (e) => endHold(e.pointerId),
          { passive: true }
        );
        window.addEventListener("blur", () => endHold(null));

        // Desktop wheel lift/lower (guarded)
        window.addEventListener(
          "wheel",
          (e) => {
            if (!heldPet) return;
            e.preventDefault();
            holdHeight = THREE.MathUtils.clamp(
              holdHeight - e.deltaY * 0.003,
              0.6,
              4
            );
            heightSlider.value = String(holdHeight);
            heightVal.textContent = holdHeight.toFixed(1);
            heldPet.targetPos.y = holdHeight;
          },
          { passive: false }
        );

        // ============ UI ============
        function addPet() {
          if (pets.length >= MAX_PETS) {
            toast("Pet limit reached (" + MAX_PETS + ")");
            return;
          }
          const x = (Math.random() * 2 - 1) * 8;
          const z = (Math.random() * 2 - 1) * 8;
          const sp = pickSpecies();
          pets.push(new Pet(x, z, null, sp));
          toast("Added a " + sp.label);
        }

        // Single click handlers to avoid double-firing
        let lastAddTime = 0;
        addBtn.addEventListener("click", (e) => {
          e.preventDefault();
          // Debounce to prevent double-add
          if (Date.now() - lastAddTime < 300) return;
          lastAddTime = Date.now();
          addPet();
        });

        let lastResetTime = 0;
        resetBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (Date.now() - lastResetTime < 300) return;
          lastResetTime = Date.now();
          createInitialPets();
          toast("Reset");
        });

        // ============ COLOR PICKER ============
        let selectedColor = 0xffc8dd; // Default pastel pink
        const colorBtns = document.querySelectorAll(".color-btn");
        colorBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            colorBtns.forEach((b) => b.classList.remove("selected"));
            btn.classList.add("selected");
            selectedColor = parseInt(btn.dataset.color);
            toast("Color selected!");
          });
        });
        // Select first color by default
        colorBtns[0]?.classList.add("selected");

        heightSlider.addEventListener("input", (e) => {
          holdHeight = parseFloat(e.target.value);
          heightVal.textContent = holdHeight.toFixed(1);
          if (heldPet) heldPet.targetPos.y = holdHeight;
        });

        // Resize
        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(
            Math.min(window.devicePixelRatio || 1, isMobile ? 1.15 : 2)
          );
        });

        // ============ ANIMATION LOOP ============
        const clock = new THREE.Clock();

        function animate() {
          requestAnimationFrame(animate);
          const dt = Math.min(clock.getDelta(), 0.033);
          const time = clock.getElapsedTime();

          // Twinkle (cheap: opacity only)
          twinkleSeed += 0.0025;
          stars.material.opacity =
            0.76 + Math.sin(time * 1.2 + twinkleSeed) * 0.12;

          for (let i = 0; i < pets.length; i++) pets[i].update(time, dt);

          controls.update();
          renderer.render(scene, camera);
        }

        animate();
      }
    </script>
  </body>
</html>
