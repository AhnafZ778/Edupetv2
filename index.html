<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />
    <title>Biome â€” Noâ€‘Build Pet Simulator (ImportMap + Babel)</title>

    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
      }
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: radial-gradient(
          ellipse at 50% 20%,
          #0f1631 0%,
          #070914 55%,
          #04040b 100%
        );
        color: white;
      }
      #root {
        width: 100%;
        height: 100%;
      }
      canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }

      .glass {
        background: rgba(12, 16, 30, 0.62);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
      }

      #boot {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        background: radial-gradient(
          ellipse at 50% 20%,
          rgba(15, 22, 49, 0.95) 0%,
          rgba(7, 9, 20, 0.96) 55%,
          rgba(4, 4, 11, 0.98) 100%
        );
        color: rgba(255, 255, 255, 0.92);
        letter-spacing: 0.02em;
      }

      #errorOverlay {
        position: fixed;
        left: 14px;
        right: 14px;
        bottom: 14px;
        z-index: 3000;
        padding: 12px 14px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.78);
        border: 1px solid rgba(255, 255, 255, 0.14);
        color: rgba(255, 255, 255, 0.92);
        font-size: 12px;
        line-height: 1.35;
        white-space: pre-wrap;
        display: none;
        max-height: 44vh;
        overflow: auto;
      }

      /* Crosshair */
      #crosshair {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 14px;
        height: 14px;
        z-index: 1200;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s ease;
      }
      #crosshair.show {
        opacity: 0.92;
      }
      #crosshair::before,
      #crosshair::after {
        content: "";
        position: absolute;
        left: 50%;
        top: 50%;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 999px;
        transform: translate(-50%, -50%);
      }
      #crosshair::before {
        width: 2px;
        height: 14px;
      }
      #crosshair::after {
        width: 14px;
        height: 2px;
      }
    </style>

    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "three": "https://esm.sh/three@0.164.1",
          "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.16.1?external=react,react-dom,three",
          "@react-three/drei": "https://esm.sh/@react-three/drei@9.105.4?external=react,react-dom,three,@react-three/fiber",
          "uuid": "https://esm.sh/uuid@9.0.1"
        }
      }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <div id="crosshair"></div>

    <div id="boot">
      <div class="glass px-5 py-4 text-center max-w-[92vw]">
        <div class="text-lg font-bold">Biome</div>
        <div class="text-xs text-white/70 mt-1">
          Loading (ImportMap + Babel)â€¦
        </div>
        <div class="text-[11px] text-white/50 mt-3">
          If this hangs, your environment may block ESM/CDN modules.
        </div>
      </div>
    </div>
    <div id="errorOverlay"></div>

    <script>
      const bootEl = document.getElementById("boot");
      const errorEl = document.getElementById("errorOverlay");

      function showError(err) {
        const msg = err && err.stack ? err.stack : String(err);
        errorEl.style.display = "block";
        errorEl.textContent = "Biome failed to start:\n\n" + msg;
        bootEl.style.display = "none";
      }

      window.addEventListener(
        "error",
        (e) => {
          if (e?.error) showError(e.error);
          else if (
            e?.target &&
            (e.target.tagName === "SCRIPT" || e.target.tagName === "LINK")
          ) {
            showError(
              "Resource failed to load: " +
                (e.target.src || e.target.href || "(unknown)")
            );
          }
        },
        true
      );

      window.addEventListener("unhandledrejection", (e) =>
        showError(e.reason || e)
      );

      function hasWebGL() {
        try {
          const c = document.createElement("canvas");
          return !!(
            c.getContext("webgl") || c.getContext("experimental-webgl")
          );
        } catch {
          return false;
        }
      }

      if (!hasWebGL()) {
        showError("WebGL is not available in this browser/context.");
      }
    </script>

    <script type="text/babel" data-type="module" data-presets="react">
      import React, {
        useCallback,
        useEffect,
        useMemo,
        useRef,
        useState,
      } from "react";
      import { createRoot } from "react-dom/client";
      import * as THREE from "three";
      import { Canvas, useFrame, useThree } from "@react-three/fiber";
      import {
        KeyboardControls,
        PointerLockControls,
        Sky,
        Stars,
        Sparkles,
        useKeyboardControls,
        Html,
      } from "@react-three/drei";
      import { v4 as uuidv4 } from "uuid";

      const MU = THREE.MathUtils;
      const crosshairEl = document.getElementById("crosshair");
      const bootEl2 = document.getElementById("boot");

      // -----------------------------
      // Config
      // -----------------------------

      const WORLD = {
        radius: 14.5,
      };

      const AI = {
        IDLE: "IDLE",
        ROAM: "ROAM",
        FLEE: "FLEE",
        SOCIAL: "SOCIAL",
        SLEEP: "SLEEP",
        HELD: "HELD",
      };

      const SPECIES_CONFIG = {
        cat: {
          key: "cat",
          label: "Cat",
          icon: "ðŸ±",
          scale: 0.95,
          baseY: 0.36,
          body: { w: 0.85, h: 0.5, l: 1.15 },
          head: { r: 0.34, z: 0.68, y: 0.28 },
          ears: { type: "pointy", size: 0.16 },
          tail: { type: "long", len: 0.85 },
          gait: {
            speed: 1.25,
            stepFreq: 7.0,
            amp: 0.55,
            bob: 0.05,
            lean: 0.12,
            bank: 0.1,
          },
          traits: {
            aloof: true,
            climbsRugs: true,
            slowBlink: true,
            timid: true,
          },
        },
        rabbit: {
          key: "rabbit",
          label: "Rabbit",
          icon: "ðŸ°",
          scale: 0.88,
          baseY: 0.32,
          body: { w: 0.75, h: 0.55, l: 0.95 },
          head: { r: 0.32, z: 0.58, y: 0.24 },
          ears: { type: "long", size: 0.35 },
          tail: { type: "pom", len: 0.22 },
          gait: {
            speed: 1.55,
            stepFreq: 9.5,
            amp: 0.75,
            bob: 0.075,
            lean: 0.14,
            bank: 0.12,
          },
          traits: { burstHop: true, timid: true },
        },
      };

      const SPECIES_KEYS = ["cat", "rabbit"];

      // -----------------------------
      // Helpers
      // -----------------------------

      function pick(arr) {
        return arr[(Math.random() * arr.length) | 0];
      }

      function randRange(a, b) {
        return MU.lerp(a, b, Math.random());
      }

      function clamp01(v) {
        return MU.clamp(v, 0, 1);
      }

      function smoothstep01(t) {
        t = MU.clamp(t, 0, 1);
        return t * t * (3 - 2 * t);
      }

      function dampAngle(a, b, t) {
        let d = ((b - a + Math.PI) % (Math.PI * 2)) - Math.PI;
        return a + d * t;
      }

      // -----------------------------
      // Toon ramp texture
      // -----------------------------

      function useToonRampTexture() {
        return useMemo(() => {
          const c = document.createElement("canvas");
          c.width = 4;
          c.height = 1;
          const ctx = c.getContext("2d");
          const img = ctx.createImageData(4, 1);
          const vals = [40, 120, 200, 255];
          for (let i = 0; i < 4; i++) {
            const v = vals[i];
            img.data[i * 4 + 0] = v;
            img.data[i * 4 + 1] = v;
            img.data[i * 4 + 2] = v;
            img.data[i * 4 + 3] = 255;
          }
          ctx.putImageData(img, 0, 0);
          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.NearestFilter;
          tex.magFilter = THREE.NearestFilter;
          tex.generateMipmaps = false;
          tex.needsUpdate = true;
          return tex;
        }, []);
      }

      // -----------------------------
      // Environment (Floor + Rugs)
      // -----------------------------

      function useRugs() {
        return useMemo(
          () => [
            { id: "rug_a", x: -4.8, z: -3.8, w: 3.2, d: 2.0, h: 0.07 },
            { id: "rug_b", x: 5.2, z: 3.6, w: 3.4, d: 2.1, h: 0.07 },
            { id: "rug_c", x: 0.2, z: 0.6, w: 2.6, d: 1.7, h: 0.06 },
          ],
          []
        );
      }

      function Ground({ rampTex, groundObjectsRef }) {
        const ref = useRef();
        const mat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color("#151a2d"),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [rampTex]);

        useEffect(() => {
          if (ref.current && groundObjectsRef?.current)
            groundObjectsRef.current.push(ref.current);
          return () => {
            if (!ref.current || !groundObjectsRef?.current) return;
            const i = groundObjectsRef.current.indexOf(ref.current);
            if (i >= 0) groundObjectsRef.current.splice(i, 1);
          };
        }, [groundObjectsRef]);

        return (
          <mesh
            ref={ref}
            rotation={[-Math.PI / 2, 0, 0]}
            position={[0, 0, 0]}
            material={mat}
          >
            <planeGeometry args={[120, 120, 1, 1]} />
          </mesh>
        );
      }

      function Rugs({ rugs, rampTex, groundObjectsRef }) {
        const mat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color("#2a2146"),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [rampTex]);

        return (
          <group>
            {rugs.map((r) => (
              <mesh
                key={r.id}
                position={[r.x, r.h * 0.5, r.z]}
                material={mat}
                ref={(el) => {
                  if (!el || !groundObjectsRef?.current) return;
                  if (!groundObjectsRef.current.includes(el))
                    groundObjectsRef.current.push(el);
                }}
              >
                <boxGeometry args={[r.w, r.h, r.d]} />
              </mesh>
            ))}
          </group>
        );
      }

      function groundHeightAt(x, z, rugs) {
        let h = 0;
        for (let i = 0; i < rugs.length; i++) {
          const r = rugs[i];
          const dx = Math.abs(x - r.x);
          const dz = Math.abs(z - r.z);
          if (dx <= r.w * 0.5 && dz <= r.d * 0.5) h = Math.max(h, r.h);
        }
        return h;
      }

      // -----------------------------
      // Particles: Hearts (Sprites)
      // -----------------------------

      function useHeartTexture() {
        return useMemo(() => {
          const size = 64;
          const c = document.createElement("canvas");
          c.width = size;
          c.height = size;
          const ctx = c.getContext("2d");

          ctx.clearRect(0, 0, size, size);
          ctx.translate(size / 2, size / 2);

          ctx.fillStyle = "#ff6aa8";
          ctx.beginPath();
          const s = size * 0.01;
          for (let t = 0; t <= Math.PI * 2 + 0.01; t += 0.04) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y =
              13 * Math.cos(t) -
              5 * Math.cos(2 * t) -
              2 * Math.cos(3 * t) -
              Math.cos(4 * t);
            const px = x * s;
            const py = -y * s;
            if (t === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.shadowColor = "rgba(255,106,168,0.55)";
          ctx.shadowBlur = 10;
          ctx.fill();

          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          tex.needsUpdate = true;
          return tex;
        }, []);
      }

      function HeartPool({ apiRef }) {
        const tex = useHeartTexture();
        const groupRef = useRef();

        const MAX = 42;
        const sprites = useRef([]);
        const items = useRef([]);

        const mat = useMemo(() => {
          return new THREE.SpriteMaterial({
            map: tex,
            transparent: true,
            opacity: 0,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
          });
        }, [tex]);

        useEffect(() => {
          items.current = new Array(MAX).fill(0).map(() => ({
            active: false,
            pos: new THREE.Vector3(0, -999, 0),
            vel: new THREE.Vector3(),
            life: 0,
            maxLife: 1,
            scale: 1,
          }));
        }, []);

        const emit = useCallback((worldPos, n = 2) => {
          const arr = items.current;
          for (let k = 0; k < n; k++) {
            const i = arr.findIndex((h) => !h.active);
            if (i < 0) break;
            const h = arr[i];
            h.active = true;
            h.life = 0;
            h.maxLife = randRange(0.7, 1.15);
            h.pos.copy(worldPos);
            h.pos.y += randRange(0.35, 0.7);
            h.vel.set(
              randRange(-0.012, 0.012),
              randRange(0.02, 0.035),
              randRange(-0.012, 0.012)
            );
            h.scale = randRange(0.22, 0.32);
          }
        }, []);

        useEffect(() => {
          apiRef.current = { emit };
        }, [apiRef, emit]);

        useEffect(() => {
          if (!groupRef.current) return;
          sprites.current = new Array(MAX).fill(0).map(() => {
            const s = new THREE.Sprite(mat);
            s.position.set(0, -999, 0);
            s.scale.set(0.001, 0.001, 0.001);
            s.material.opacity = 0;
            groupRef.current.add(s);
            return s;
          });
          return () => {
            for (const s of sprites.current) groupRef.current?.remove(s);
            sprites.current = [];
          };
        }, [mat]);

        useFrame((_, dt) => {
          const arr = items.current;
          const spr = sprites.current;
          for (let i = 0; i < arr.length; i++) {
            const h = arr[i];
            const s = spr[i];
            if (!s) continue;

            if (!h.active) {
              s.position.set(0, -999, 0);
              s.material.opacity = 0;
              s.scale.set(0.001, 0.001, 0.001);
              continue;
            }

            h.life += dt;
            const t = h.life / h.maxLife;
            if (t >= 1) {
              h.active = false;
              continue;
            }

            h.vel.y -= 0.0032 * dt * 60;
            h.pos.addScaledVector(h.vel, dt * 60);

            const fade = 1.0 - smoothstep01((t - 0.55) / 0.45);
            s.position.copy(h.pos);
            s.material.opacity = 0.9 * fade;
            const sc = h.scale * (0.9 + t * 0.5);
            s.scale.set(sc, sc, sc);
          }
        });

        return <group ref={groupRef} />;
      }

      // -----------------------------
      // Particles: Dragon Breath (Points)
      // -----------------------------

      function BreathPool({ apiRef }) {
        const MAX = 160;
        const geo = useMemo(() => {
          const g = new THREE.BufferGeometry();
          const pos = new Float32Array(MAX * 3);
          const col = new Float32Array(MAX * 3);
          g.setAttribute("position", new THREE.BufferAttribute(pos, 3));
          g.setAttribute("color", new THREE.BufferAttribute(col, 3));
          return g;
        }, []);

        const mat = useMemo(
          () =>
            new THREE.PointsMaterial({
              size: 0.11,
              vertexColors: true,
              transparent: true,
              opacity: 0.9,
              depthWrite: false,
              blending: THREE.AdditiveBlending,
            }),
          []
        );

        const particles = useRef(
          new Array(MAX).fill(0).map(() => ({
            active: false,
            pos: new THREE.Vector3(0, -999, 0),
            vel: new THREE.Vector3(),
            life: 0,
            maxLife: 1,
          }))
        );

        const emit = useCallback((origin, dir, n = 24) => {
          const arr = particles.current;
          for (let k = 0; k < n; k++) {
            const i = arr.findIndex((p) => !p.active);
            if (i < 0) break;
            const p = arr[i];
            p.active = true;
            p.life = 0;
            p.maxLife = randRange(0.45, 0.85);
            p.pos.copy(origin);
            p.pos.addScaledVector(dir, 0.25);
            const spread = 0.12;
            const jitter = new THREE.Vector3(
              randRange(-spread, spread),
              randRange(-spread * 0.4, spread * 0.4),
              randRange(-spread, spread)
            );
            p.vel.copy(dir).multiplyScalar(randRange(0.18, 0.34)).add(jitter);
          }
        }, []);

        useEffect(() => {
          apiRef.current = { emit };
        }, [apiRef, emit]);

        useFrame((_, dt) => {
          const posAttr = geo.getAttribute("position");
          const colAttr = geo.getAttribute("color");
          const arr = particles.current;
          for (let i = 0; i < arr.length; i++) {
            const p = arr[i];
            if (!p.active) {
              posAttr.setXYZ(i, 0, -999, 0);
              colAttr.setXYZ(i, 0, 0, 0);
              continue;
            }

            p.life += dt;
            const t = p.life / p.maxLife;
            if (t >= 1) {
              p.active = false;
              posAttr.setXYZ(i, 0, -999, 0);
              colAttr.setXYZ(i, 0, 0, 0);
              continue;
            }

            p.vel.multiplyScalar(Math.pow(0.9, dt * 60));
            p.vel.y += 0.001 * dt * 60;
            p.pos.addScaledVector(p.vel, dt * 60);
            posAttr.setXYZ(i, p.pos.x, p.pos.y, p.pos.z);

            const fade = 1.0 - smoothstep01((t - 0.35) / 0.65);
            const hot = new THREE.Color().setHSL(0.05 + t * 0.03, 1.0, 0.58);
            colAttr.setXYZ(i, hot.r * fade, hot.g * fade, hot.b * fade);
          }
          posAttr.needsUpdate = true;
          colAttr.needsUpdate = true;
        });

        return <points geometry={geo} material={mat} frustumCulled={false} />;
      }

      // -----------------------------
      // Leg (procedural)
      // -----------------------------

      const Leg = React.forwardRef(function Leg(
        { material, len = 0.44, radius = 0.07 },
        ref
      ) {
        return (
          <group ref={ref}>
            <mesh position={[0, -len * 0.5, 0]} material={material}>
              <capsuleGeometry args={[radius, len, 6, 10]} />
            </mesh>
          </group>
        );
      });

      // -----------------------------
      // Species Model (ONLY primitives)
      // -----------------------------

      function SpeciesModel({
        speciesKey,
        rampTex,
        colorHex,
        seed,
        wingPhaseRef,
        bowRef,
        blinkRef,
      }) {
        const sp = SPECIES_CONFIG[speciesKey];
        const S = sp.scale;

        const bodyMat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color(colorHex),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [colorHex, rampTex]);

        const accentMat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color("#f5f1ea"),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [rampTex]);

        const darkMat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color("#141423"),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [rampTex]);

        const eyeMat = useMemo(
          () =>
            new THREE.MeshBasicMaterial({ color: new THREE.Color("#0b0b12") }),
          []
        );

        const bodyW = sp.body.w * S;
        const bodyH = sp.body.h * S;
        const bodyL = sp.body.l * S;
        const headR = sp.head.r * S;

        const leftEyeRef = useRef();
        const rightEyeRef = useRef();

        const mane = useMemo(() => {
          if (!sp.traits?.mane) return null;
          const rng = (() => {
            let s = ((seed ?? 1) * 1000000) % 2147483647;
            if (s <= 0) s += 2147483646;
            return () => (s = (s * 16807) % 2147483647) / 2147483647;
          })();
          const n = 16;
          return new Array(n).fill(0).map((_, i) => {
            const a = (i / n) * Math.PI * 2;
            return {
              i,
              a,
              r: 0.52 + rng() * 0.06,
              y: 0.1 + rng() * 0.08,
              s: 0.1 + rng() * 0.06,
              h: 0.18 + rng() * 0.12,
            };
          });
        }, [seed, sp.traits?.mane]);

        const maneMat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color("#6a3b1c"),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [rampTex]);

        useFrame((state) => {
          const t = state.clock.getElapsedTime();
          const blink = MU.clamp(blinkRef?.current ?? 0, 0, 1);
          const sY = MU.lerp(1, 0.08, blink);
          if (leftEyeRef.current) leftEyeRef.current.scale.y = sY;
          if (rightEyeRef.current) rightEyeRef.current.scale.y = sY;

          const drift = Math.sin(t * 0.7 + (seed ?? 0)) * 0.012;
          if (leftEyeRef.current)
            leftEyeRef.current.position.x = -0.18 * S + drift;
          if (rightEyeRef.current)
            rightEyeRef.current.position.x = 0.18 * S + drift;
        });

        const bow = bowRef?.current ?? 0;
        const flap = wingPhaseRef?.current ?? 0;

        return (
          <group>
            {/* Body */}
            <group>
              <mesh material={bodyMat} position={[0, 0.12 * S, 0]}>
                <boxGeometry args={[bodyW, bodyH, bodyL]} />
              </mesh>

              {/* Lion heavy chest */}
              {sp.traits?.heavyShoulders && (
                <mesh material={bodyMat} position={[0, 0.18 * S, bodyL * 0.22]}>
                  <boxGeometry
                    args={[bodyW * 1.06, bodyH * 1.02, bodyL * 0.7]}
                  />
                </mesh>
              )}

              {/* Belly patch */}
              <mesh material={accentMat} position={[0, 0.02 * S, bodyL * 0.14]}>
                <boxGeometry
                  args={[bodyW * 0.55, bodyH * 0.28, bodyL * 0.32]}
                />
              </mesh>
            </group>

            {/* Head */}
            <group position={[0, 0.2 * S, sp.head.z * S]}>
              <mesh material={bodyMat} position={[0, sp.head.y * S, 0]}>
                <sphereGeometry args={[headR, 12, 10]} />
              </mesh>

              {/* Snout */}
              <mesh
                material={accentMat}
                position={[0, sp.head.y * S - 0.08 * S, headR * 0.85]}
              >
                <sphereGeometry args={[headR * 0.52, 10, 9]} />
              </mesh>

              {/* Nose */}
              <mesh
                material={darkMat}
                position={[0, sp.head.y * S - 0.08 * S, headR * 1.35]}
              >
                <sphereGeometry args={[headR * 0.14, 9, 8]} />
              </mesh>

              {/* Eyes */}
              <mesh
                ref={leftEyeRef}
                material={eyeMat}
                position={[-0.18 * S, sp.head.y * S + 0.1 * S, headR * 0.8]}
              >
                <sphereGeometry args={[headR * 0.12, 9, 8]} />
              </mesh>
              <mesh
                ref={rightEyeRef}
                material={eyeMat}
                position={[0.18 * S, sp.head.y * S + 0.1 * S, headR * 0.8]}
              >
                <sphereGeometry args={[headR * 0.12, 9, 8]} />
              </mesh>

              {/* Ears */}
              {sp.ears.type === "pointy" && (
                <>
                  <mesh
                    material={bodyMat}
                    position={[-0.22 * S, sp.head.y * S + 0.32 * S, 0]}
                    rotation={[0.08, 0, 0.5]}
                  >
                    <coneGeometry
                      args={[sp.ears.size * S, sp.ears.size * 1.8 * S, 8, 1]}
                    />
                  </mesh>
                  <mesh
                    material={bodyMat}
                    position={[0.22 * S, sp.head.y * S + 0.32 * S, 0]}
                    rotation={[0.08, 0, -0.5]}
                  >
                    <coneGeometry
                      args={[sp.ears.size * S, sp.ears.size * 1.8 * S, 8, 1]}
                    />
                  </mesh>
                </>
              )}

              {sp.ears.type === "flop" && (
                <>
                  <mesh
                    material={bodyMat}
                    position={[-0.27 * S, sp.head.y * S + 0.18 * S, 0.06 * S]}
                    rotation={[0.25, 0.0, 0.9]}
                  >
                    <sphereGeometry args={[sp.ears.size * S, 10, 9]} />
                  </mesh>
                  <mesh
                    material={bodyMat}
                    position={[0.27 * S, sp.head.y * S + 0.18 * S, 0.06 * S]}
                    rotation={[0.25, 0.0, -0.9]}
                  >
                    <sphereGeometry args={[sp.ears.size * S, 10, 9]} />
                  </mesh>
                </>
              )}

              {sp.ears.type === "long" && (
                <>
                  <mesh
                    material={bodyMat}
                    position={[-0.16 * S, sp.head.y * S + 0.55 * S, -0.05 * S]}
                    rotation={[-0.15, 0, 0.2]}
                  >
                    <capsuleGeometry
                      args={[0.06 * S, sp.ears.size * 1.6 * S, 6, 10]}
                    />
                  </mesh>
                  <mesh
                    material={bodyMat}
                    position={[0.16 * S, sp.head.y * S + 0.55 * S, -0.05 * S]}
                    rotation={[-0.15, 0, -0.2]}
                  >
                    <capsuleGeometry
                      args={[0.06 * S, sp.ears.size * 1.6 * S, 6, 10]}
                    />
                  </mesh>
                </>
              )}

              {sp.ears.type === "horn" && (
                <>
                  <mesh
                    material={accentMat}
                    position={[-0.18 * S, sp.head.y * S + 0.45 * S, 0.04 * S]}
                    rotation={[-0.2, 0.0, 0.18]}
                  >
                    <coneGeometry
                      args={[
                        sp.ears.size * 0.55 * S,
                        sp.ears.size * 1.8 * S,
                        7,
                        1,
                      ]}
                    />
                  </mesh>
                  <mesh
                    material={accentMat}
                    position={[0.18 * S, sp.head.y * S + 0.45 * S, 0.04 * S]}
                    rotation={[-0.2, 0.0, -0.18]}
                  >
                    <coneGeometry
                      args={[
                        sp.ears.size * 0.55 * S,
                        sp.ears.size * 1.8 * S,
                        7,
                        1,
                      ]}
                    />
                  </mesh>
                </>
              )}

              {sp.ears.type === "small" && (
                <>
                  <mesh
                    material={bodyMat}
                    position={[-0.16 * S, sp.head.y * S + 0.22 * S, 0]}
                    rotation={[0.2, 0, 0]}
                  >
                    <sphereGeometry args={[sp.ears.size * 0.7 * S, 9, 8]} />
                  </mesh>
                  <mesh
                    material={bodyMat}
                    position={[0.16 * S, sp.head.y * S + 0.22 * S, 0]}
                    rotation={[0.2, 0, 0]}
                  >
                    <sphereGeometry args={[sp.ears.size * 0.7 * S, 9, 8]} />
                  </mesh>
                </>
              )}

              {/* Mane */}
              {mane && (
                <group position={[0, sp.head.y * S - 0.04 * S, -0.08 * S]}>
                  {mane.map((m) => (
                    <mesh
                      key={"m" + m.i}
                      material={maneMat}
                      position={[
                        Math.cos(m.a) * m.r * S,
                        m.y * S,
                        Math.sin(m.a) * m.r * S,
                      ]}
                      rotation={[0.0, m.a, 0.0]}
                    >
                      <coneGeometry args={[m.s * S, m.h * S, 7, 1]} />
                    </mesh>
                  ))}
                </group>
              )}
            </group>

            {/* Tail */}
            <group position={[0, 0.12 * S, -bodyL * 0.58]}>
              {sp.tail.type === "pom" ? (
                <mesh material={accentMat} position={[0, 0.08 * S, -0.12 * S]}>
                  <sphereGeometry args={[0.13 * S, 10, 9]} />
                </mesh>
              ) : (
                <mesh
                  material={bodyMat}
                  position={[0, 0.18 * S, -0.38 * S]}
                  rotation={[0.9, 0, 0]}
                >
                  <capsuleGeometry args={[0.07 * S, sp.tail.len * S, 6, 10]} />
                </mesh>
              )}
            </group>

            {/* Dragon wings */}
            {sp.traits?.wings && (
              <group position={[0, 0.36 * S, -0.1 * S]}>
                <mesh
                  material={bodyMat}
                  position={[-0.78 * S, 0.1 * S, 0]}
                  rotation={[0, 0, 0.35 + flap * 0.95]}
                >
                  <boxGeometry args={[1.45 * S, 0.1 * S, 0.85 * S]} />
                </mesh>
                <mesh
                  material={bodyMat}
                  position={[0.78 * S, 0.1 * S, 0]}
                  rotation={[0, 0, -0.35 - flap * 0.95]}
                >
                  <boxGeometry args={[1.45 * S, 0.1 * S, 0.85 * S]} />
                </mesh>
              </group>
            )}

            {/* Dog play-bow chest */}
            {sp.key === "dog" && (
              <group
                position={[0, 0.12 * S, bodyL * 0.25]}
                rotation={[bow * 0.35, 0, 0]}
              >
                <mesh material={bodyMat}>
                  <boxGeometry
                    args={[bodyW * 1.02, bodyH * 0.88, bodyL * 0.42]}
                  />
                </mesh>
              </group>
            )}
          </group>
        );
      }

      // -----------------------------
      // Pet (AI + locomotion)
      // -----------------------------

      function Pet({
        pet,
        rampTex,
        rugs,
        registerHit,
        unregisterHit,
        registerAPI,
        unregisterAPI,
        playerRef,
        heldRef,
        heartAPIRef,
        breathAPIRef,
        allPosMapRef,
      }) {
        const sp = SPECIES_CONFIG[pet.speciesKey];
        const groupRef = useRef();
        const hitRef = useRef();

        const wingPhaseRef = useRef(0);
        const bowRef = useRef(0);
        const blinkRef = useRef(0);

        const pos = useRef(
          new THREE.Vector3(pet.position[0], 0, pet.position[1])
        );
        const vel = useRef(new THREE.Vector3());
        const yaw = useRef(pet.yaw ?? Math.random() * Math.PI * 2);
        const lastYaw = useRef(yaw.current);

        const brain = useRef({
          mode: AI.ROAM,
          t: randRange(0.6, 1.4),
          seed: pet.seed ?? Math.random() * 10,
          target: new THREE.Vector3(pet.position[0], 0, pet.position[1]),
          restSpot: new THREE.Vector3(),
          lastInteractAt: performance.now() * 0.001,
          socialUntil: 0,
          socialPartner: null,
          hop: { phase: 0, t: 0 },
          bowT: 0,
          breathT: randRange(5, 10),
        });

        const legFL = useRef();
        const legFR = useRef();
        const legBL = useRef();
        const legBR = useRef();

        const legMat = useMemo(() => {
          const m = new THREE.MeshToonMaterial({
            color: new THREE.Color(pet.color).multiplyScalar(0.95),
            gradientMap: rampTex,
          });
          m.dithering = true;
          return m;
        }, [pet.color, rampTex]);

        useEffect(() => {
          if (hitRef.current) registerHit(hitRef.current, pet.id);
          return () => {
            if (hitRef.current) unregisterHit(hitRef.current);
          };
        }, [pet.id, registerHit, unregisterHit]);

        useEffect(() => {
          registerAPI(pet.id, {
            getPose: () => ({
              x: pos.current.x,
              y: pos.current.y,
              z: pos.current.z,
              yaw: yaw.current,
              mode: brain.current.mode,
              speciesKey: pet.speciesKey,
            }),
            pet: () => {
              brain.current.lastInteractAt = performance.now() * 0.001;
              heartAPIRef.current?.emit?.(
                pos.current.clone(),
                sp.key === "lion" ? 3 : sp.key === "dragon" ? 4 : 2
              );
              vel.current.y += 0.012;
            },
            setSocial: ({ partnerId, until, partnerPos }) => {
              brain.current.mode = AI.SOCIAL;
              brain.current.socialPartner = partnerId;
              brain.current.socialUntil = until;
              if (partnerPos)
                brain.current.target.set(partnerPos.x, 0, partnerPos.z);
            },
            forceFlee: (secs = 1.0) => {
              brain.current.mode = AI.FLEE;
              brain.current.t = secs;
            },
          });
          return () => unregisterAPI(pet.id);
        }, [pet.id, pet.speciesKey, registerAPI, unregisterAPI, heartAPIRef]);

        function pickRoamTarget() {
          const B = brain.current;
          const r = WORLD.radius * 0.75;

          if (sp.traits?.climbsRugs && Math.random() < 0.45) {
            const rug = pick(rugs);
            B.target.set(
              rug.x + randRange(-rug.w * 0.25, rug.w * 0.25),
              0,
              rug.z + randRange(-rug.d * 0.25, rug.d * 0.25)
            );
            B.t = randRange(1.2, 2.4);
            return;
          }

          B.target.set(randRange(-r, r), 0, randRange(-r, r));
          B.t = randRange(1.2, 2.9);
        }

        useFrame((state, dt) => {
          const t = state.clock.getElapsedTime();
          const B = brain.current;
          const player = playerRef.current;

          allPosMapRef.current.set(pet.id, {
            x: pos.current.x,
            y: pos.current.y,
            z: pos.current.z,
            speciesKey: pet.speciesKey,
          });

          const held = heldRef.current.id === pet.id;

          // blink
          {
            const rate = sp.key === "cat" ? 0.17 : 0.28;
            const wave = 0.5 + 0.5 * Math.sin(t * rate + B.seed);
            const pulse = smoothstep01(
              (wave - (sp.key === "cat" ? 0.965 : 0.985)) /
                (1.0 - (sp.key === "cat" ? 0.965 : 0.985))
            );
            const target = held
              ? 0
              : MU.clamp(pulse * (sp.traits?.slowBlink ? 1.0 : 0.85), 0, 1);
            blinkRef.current = MU.lerp(blinkRef.current, target, 0.18);
          }

          // wings
          if (sp.traits?.wings)
            wingPhaseRef.current = Math.sin(t * 3.2 + B.seed) * 0.55;
          else wingPhaseRef.current = MU.lerp(wingPhaseRef.current, 0, 0.08);

          // dog bow
          if (sp.traits?.playBow && !held) {
            const dx = player.pos.x - pos.current.x;
            const dz = player.pos.z - pos.current.z;
            const d2 = dx * dx + dz * dz;
            if (d2 < 4.6 * 4.6 && Math.random() < 0.01)
              B.bowT = 0.65 + Math.random() * 0.35;
            if (B.bowT > 0) {
              B.bowT -= dt;
              bowRef.current = MU.lerp(bowRef.current, 1.0, 0.18);
            } else {
              bowRef.current = MU.lerp(bowRef.current, 0.0, 0.1);
            }
          } else {
            bowRef.current = MU.lerp(bowRef.current, 0.0, 0.08);
          }

          // dragon breath
          if (sp.traits?.breath && !held) {
            B.breathT -= dt;
            if (B.breathT <= 0) {
              B.breathT = randRange(6.5, 12.0);
              const forward = new THREE.Vector3(
                Math.sin(yaw.current),
                0,
                Math.cos(yaw.current)
              ).normalize();
              const mouth = pos.current.clone();
              const gY = groundHeightAt(pos.current.x, pos.current.z, rugs);
              const hoverY = gY + sp.hoverY + Math.sin(t * 1.1 + B.seed) * 0.12;
              mouth.y = hoverY + 0.95;
              mouth.addScaledVector(forward, sp.body.l * sp.scale * 0.55);
              breathAPIRef.current?.emit?.(
                mouth,
                forward,
                22 + ((Math.random() * 10) | 0)
              );
            }
          }

          // held
          if (held) {
            B.mode = AI.HELD;
            const tgt = heldRef.current.target;
            const k = 1 - Math.pow(1 - 0.16, dt * 60);
            pos.current.x = MU.lerp(pos.current.x, tgt.x, k);
            pos.current.z = MU.lerp(pos.current.z, tgt.z, k);
            pos.current.y = MU.lerp(pos.current.y, tgt.y, k);

            // face camera
            const camDir = new THREE.Vector3();
            state.camera.getWorldDirection(camDir);
            const targetYaw = Math.atan2(camDir.x, camDir.z) + Math.PI;
            yaw.current = dampAngle(yaw.current, targetYaw, 0.18);

            const w = Math.sin(t * 10.5 + B.seed) * 0.65;
            if (legFL.current) legFL.current.rotation.x = w;
            if (legFR.current) legFR.current.rotation.x = -w;
            if (legBL.current) legBL.current.rotation.x = -w;
            if (legBR.current) legBR.current.rotation.x = w;

            if (groupRef.current) {
              groupRef.current.position.set(
                pos.current.x,
                pos.current.y,
                pos.current.z
              );
              groupRef.current.rotation.set(
                Math.sin(t * 5.2 + B.seed) * 0.1,
                yaw.current,
                Math.cos(t * 4.7 + B.seed) * 0.05
              );
              groupRef.current.scale.set(1, 1, 1);
            }
            return;
          }

          // release transition
          if (B.mode === AI.HELD) {
            B.mode = AI.ROAM;
            B.t = randRange(0.8, 1.4);
          }

          // social expiry
          if (B.mode === AI.SOCIAL && t > B.socialUntil) {
            B.mode = AI.ROAM;
            B.socialPartner = null;
            B.t = randRange(0.6, 1.4);
          }

          // sleep
          const sinceInteract =
            performance.now() * 0.001 - (B.lastInteractAt || 0);
          if (B.mode !== AI.SLEEP && B.mode !== AI.SOCIAL) {
            const baseChance =
              sp.key === "cat"
                ? 0.03
                : sp.key === "lion"
                ? 0.02
                : sp.key === "rabbit"
                ? 0.015
                : 0.01;
            if (sinceInteract > 18 && Math.random() < baseChance * dt) {
              B.mode = AI.SLEEP;
              B.t = randRange(4.0, 8.0);
              if (sp.traits?.climbsRugs) {
                const rug = pick(rugs);
                B.restSpot.set(rug.x, 0, rug.z);
              } else {
                B.restSpot.set(randRange(-6, 6), 0, randRange(-6, 6));
              }
            }
          }

          // player triggers
          const dxp = player.pos.x - pos.current.x;
          const dzp = player.pos.z - pos.current.z;
          const dPlayer = Math.hypot(dxp, dzp);
          const playerRunning = player.isSprinting && player.speed > 0.6;

          if (
            playerRunning &&
            dPlayer < 5.0 &&
            (sp.traits?.timid || sp.key === "cat")
          ) {
            B.mode = AI.FLEE;
            B.t = 0.85;
          }

          if (
            sp.traits?.chasesPlayer &&
            dPlayer < 10 &&
            B.mode !== AI.SLEEP &&
            B.mode !== AI.SOCIAL
          ) {
            B.mode = AI.ROAM;
            B.target.set(player.pos.x, 0, player.pos.z);
          }

          // rabbit burst hop
          if (
            sp.traits?.burstHop &&
            (B.mode === AI.ROAM || B.mode === AI.FLEE)
          ) {
            B.hop.t -= dt;
            if (B.hop.t <= 0) {
              B.hop.phase = (B.hop.phase + 1) % 2;
              B.hop.t =
                B.hop.phase === 0
                  ? randRange(0.22, 0.38)
                  : randRange(0.18, 0.35);
            }
          }

          // timers
          B.t -= dt;

          if (B.mode === AI.ROAM && B.t <= 0) {
            if (sp.traits?.aloof && Math.random() < 0.28) {
              B.mode = AI.IDLE;
              B.t = randRange(0.8, 1.8);
            } else {
              pickRoamTarget();
            }
          }

          if (B.mode === AI.IDLE && B.t <= 0) {
            B.mode = AI.ROAM;
            pickRoamTarget();
          }

          if (B.mode === AI.FLEE && B.t <= 0) {
            B.mode = AI.ROAM;
            pickRoamTarget();
          }

          if (B.mode === AI.SLEEP) {
            const to = new THREE.Vector3(
              B.restSpot.x - pos.current.x,
              0,
              B.restSpot.z - pos.current.z
            );
            const d = to.length();
            if (d > 0.35) {
              to.multiplyScalar(1 / (d || 1));
              vel.current.x += to.x * dt * 0.9;
              vel.current.z += to.z * dt * 0.9;
              const targetYaw = Math.atan2(vel.current.x, vel.current.z);
              if (isFinite(targetYaw))
                yaw.current = dampAngle(yaw.current, targetYaw, 0.08);
            } else {
              vel.current.multiplyScalar(Math.pow(0.72, dt * 60));
              if (B.t <= 0) {
                B.mode = AI.ROAM;
                pickRoamTarget();
                B.lastInteractAt = performance.now() * 0.001;
              }
            }
          }

          // separation
          const sep = new THREE.Vector3();
          for (const [id, p2] of allPosMapRef.current) {
            if (id === pet.id) continue;
            const ox = pos.current.x - p2.x;
            const oz = pos.current.z - p2.z;
            const d2 = ox * ox + oz * oz;
            const minD = sp.key === "lion" ? 1.8 : 1.25;
            if (d2 > 0.0001 && d2 < minD * minD) {
              const d = Math.sqrt(d2);
              const push = (1.0 - d / minD) * 0.018;
              sep.x += (ox / d) * push;
              sep.z += (oz / d) * push;
            }
          }
          if (dPlayer < 1.3) {
            const inv = 1 / Math.max(0.001, dPlayer);
            sep.x += -dxp * inv * 0.022;
            sep.z += -dzp * inv * 0.022;
          }

          // desired
          let desiredDir = new THREE.Vector3(0, 0, 0);
          let desiredSpeed = 0;

          if (
            B.mode === AI.IDLE ||
            B.mode === AI.SOCIAL ||
            B.mode === AI.SLEEP
          ) {
            desiredSpeed = 0;
          } else if (B.mode === AI.FLEE) {
            desiredDir.set(-dxp, 0, -dzp).normalize();
            desiredSpeed = sp.gait.speed * 1.25;
          } else {
            desiredDir.set(
              B.target.x - pos.current.x,
              0,
              B.target.z - pos.current.z
            );
            const dl = desiredDir.length();
            if (dl > 0.2) desiredDir.multiplyScalar(1 / dl);
            else desiredDir.set(0, 0, 0);
            desiredSpeed = sp.gait.speed;
            if (sp.traits?.burstHop && B.hop.phase === 1) desiredSpeed = 0;
          }

          desiredDir.addScaledVector(sep, 1.35);
          const dirL = desiredDir.length();
          if (dirL > 0.001) desiredDir.multiplyScalar(1 / dirL);

          const accel = 0.03 * desiredSpeed;
          vel.current.x += desiredDir.x * accel * dt * 60;
          vel.current.z += desiredDir.z * accel * dt * 60;

          const damp =
            B.mode === AI.IDLE || B.mode === AI.SOCIAL || B.mode === AI.SLEEP
              ? 0.8
              : 0.88;
          vel.current.x *= Math.pow(damp, dt * 60);
          vel.current.z *= Math.pow(damp, dt * 60);

          const vLen = Math.hypot(vel.current.x, vel.current.z);
          const maxV = desiredSpeed * 0.085;
          if (vLen > maxV) {
            const s = maxV / (vLen || 1);
            vel.current.x *= s;
            vel.current.z *= s;
          }

          pos.current.x += vel.current.x * dt * 60;
          pos.current.z += vel.current.z * dt * 60;

          // bounds
          const r = Math.hypot(pos.current.x, pos.current.z);
          if (r > WORLD.radius) {
            const s = WORLD.radius / (r || 1);
            pos.current.x *= s;
            pos.current.z *= s;
            vel.current.x *= 0.65;
            vel.current.z *= 0.65;
          }

          // face
          if (vLen > 0.004) {
            const targetYaw = Math.atan2(vel.current.x, vel.current.z);
            yaw.current = dampAngle(yaw.current, targetYaw, 0.1);
          }

          if (B.mode === AI.SOCIAL) {
            const fx = B.target.x - pos.current.x;
            const fz = B.target.z - pos.current.z;
            const targetYaw = Math.atan2(fx, fz);
            if (isFinite(targetYaw))
              yaw.current = dampAngle(yaw.current, targetYaw, 0.14);
          }

          // vertical
          const gY = groundHeightAt(pos.current.x, pos.current.z, rugs);
          const desiredBaseY = gY + sp.baseY;
          const hoverY = sp.traits?.hover
            ? gY + sp.hoverY + Math.sin(t * 1.1 + B.seed) * 0.12
            : desiredBaseY;
          pos.current.y = sp.traits?.hover
            ? hoverY
            : MU.lerp(pos.current.y, desiredBaseY, 1 - Math.pow(0.82, dt * 60));

          // gait legs
          const speedNorm = MU.clamp(vLen / (maxV || 0.0001), 0, 1);
          const phase = t * sp.gait.stepFreq * (0.85 + speedNorm * 0.55);
          const hopBoost = sp.traits?.burstHop
            ? B.hop.phase === 0
              ? 1.35
              : 0.35
            : 1.0;
          const swingA = Math.sin(phase) * sp.gait.amp * speedNorm * hopBoost;
          const swingB =
            Math.sin(phase + Math.PI) * sp.gait.amp * speedNorm * hopBoost;
          if (legFL.current) legFL.current.rotation.x = swingA;
          if (legBR.current) legBR.current.rotation.x = swingA;
          if (legFR.current) legFR.current.rotation.x = swingB;
          if (legBL.current) legBL.current.rotation.x = swingB;

          // body bob/lean/bank
          const bob =
            Math.sin(phase * 0.95 + B.seed) *
            sp.gait.bob *
            speedNorm *
            hopBoost;
          const lean = -sp.gait.lean * speedNorm;
          const yawDelta = yaw.current - lastYaw.current;
          lastYaw.current = yaw.current;
          const bank = MU.clamp(yawDelta * 8.0, -1, 1) * sp.gait.bank;

          const sleepPose = B.mode === AI.SLEEP ? 1 : 0;
          const sleepSquash = MU.lerp(1, 0.78, sleepPose);

          if (groupRef.current) {
            groupRef.current.position.set(
              pos.current.x,
              pos.current.y + bob,
              pos.current.z
            );
            groupRef.current.rotation.set(
              MU.lerp(lean, 0, sleepPose) +
                (sp.key === "dragon" ? Math.sin(t * 0.6 + B.seed) * 0.05 : 0),
              yaw.current,
              bank
            );
            groupRef.current.scale.set(1.0, sleepSquash, 1.0);
          }
        });

        const hitMat = useMemo(
          () =>
            new THREE.MeshBasicMaterial({
              transparent: true,
              opacity: 0.0,
              depthWrite: false,
            }),
          []
        );
        const S = sp.scale;
        const hitSize =
          sp.key === "lion" ? 2.6 * S : sp.key === "dragon" ? 2.9 * S : 2.2 * S;

        return (
          <group ref={groupRef}>
            <group>
              <SpeciesModel
                speciesKey={pet.speciesKey}
                rampTex={rampTex}
                colorHex={pet.color}
                seed={pet.seed}
                wingPhaseRef={wingPhaseRef}
                bowRef={bowRef}
                blinkRef={blinkRef}
              />

              {/* Legs */}
              <group position={[0, 0.16 * sp.scale, 0]}>
                <group position={[-0.35 * sp.scale, 0.0, 0.45 * sp.scale]}>
                  <Leg
                    ref={legFL}
                    material={legMat}
                    len={0.46 * sp.scale}
                    radius={0.075 * sp.scale}
                  />
                </group>
                <group position={[0.35 * sp.scale, 0.0, 0.45 * sp.scale]}>
                  <Leg
                    ref={legFR}
                    material={legMat}
                    len={0.46 * sp.scale}
                    radius={0.075 * sp.scale}
                  />
                </group>
                <group position={[-0.35 * sp.scale, 0.0, -0.45 * sp.scale]}>
                  <Leg
                    ref={legBL}
                    material={legMat}
                    len={0.46 * sp.scale}
                    radius={0.075 * sp.scale}
                  />
                </group>
                <group position={[0.35 * sp.scale, 0.0, -0.45 * sp.scale]}>
                  <Leg
                    ref={legBR}
                    material={legMat}
                    len={0.46 * sp.scale}
                    radius={0.075 * sp.scale}
                  />
                </group>
              </group>
            </group>

            {/* Hitbox for center-ray interaction */}
            <mesh ref={hitRef} material={hitMat}>
              <boxGeometry args={[hitSize, hitSize * 0.72, hitSize]} />
            </mesh>
          </group>
        );
      }

      // -----------------------------
      // Pet System (HUD + registry + interaction)
      // -----------------------------

      function PetSystem({ rampTex, rugs, groundObjectsRef }) {
        const MAX = 18;

        const heartAPIRef = useRef(null);
        const breathAPIRef = useRef(null);

        const playerRef = useRef({
          pos: new THREE.Vector3(0, 1.7, 6.5),
          isSprinting: false,
          speed: 0,
        });
        const heldRef = useRef({
          id: null,
          target: new THREE.Vector3(0, 1.6, 0),
        });

        const hitObjectsRef = useRef([]);
        const hitToIdRef = useRef(new Map());
        const petAPIMapRef = useRef(new Map());
        const allPosMapRef = useRef(new Map());

        const [hudVisible, setHudVisible] = useState(false);

        // Toggle HUD with H key and manage pointer lock
        useEffect(() => {
          const onKey = (e) => {
            if (e.key === "h" || e.key === "H") {
              setHudVisible((v) => {
                const newVal = !v;
                if (newVal) {
                  // Opening menu - exit pointer lock
                  if (document.pointerLockElement) {
                    document.exitPointerLock();
                  }
                } else {
                  // Closing menu - request pointer lock
                  const canvas = document.querySelector("canvas");
                  if (canvas) {
                    canvas.requestPointerLock();
                  }
                }
                return newVal;
              });
            }
          };
          window.addEventListener("keydown", onKey);
          return () => window.removeEventListener("keydown", onKey);
        }, []);

        const [pets, setPets] = useState(() => {
          const cozy = {
            cat: [0xcdb4db, 0xbde0fe, 0xa2d2ff, 0xffc8dd],
            rabbit: [0xd0f4de, 0xa9def9, 0xe4c1f9, 0xfcf6bd],
          };

          const mk = (speciesKey, x, z) => ({
            id: uuidv4(),
            speciesKey,
            name:
              (SPECIES_CONFIG[speciesKey]?.label ?? "Animal") +
              " " +
              ((Math.random() * 100) | 0),
            color: pick(cozy[speciesKey] || cozy.cat),
            position: [x, z],
            yaw: Math.random() * Math.PI * 2,
            seed: Math.random() * 10,
          });

          return [
            mk("cat", -2.5, 0.5),
            mk("rabbit", 2.3, -1.0),
            mk("cat", 0.8, 2.6),
            mk("rabbit", -3.5, -2.2),
          ];
        });

        const counts = useMemo(() => {
          const c = {};
          for (const k of SPECIES_KEYS) c[k] = 0;
          for (const p of pets) c[p.speciesKey] = (c[p.speciesKey] || 0) + 1;
          return c;
        }, [pets]);

        const addPet = useCallback((speciesKey) => {
          setPets((prev) => {
            if (prev.length >= MAX) return prev;
            const r = WORLD.radius * 0.55;
            const x = randRange(-r, r);
            const z = randRange(-r, r);
            const palettes = {
              cat: [0xcdb4db, 0xbde0fe, 0xa2d2ff, 0xffc8dd],
              dog: [0xffd6a5, 0xfec89a, 0xfde4cf, 0xcdeac0],
              lion: [0xf2b772, 0xe09f3e, 0xf6d365],
              rabbit: [0xd0f4de, 0xa9def9, 0xe4c1f9, 0xfcf6bd],
              dragon: [0x6ee7b7, 0x60a5fa, 0xa7f3d0, 0x93c5fd],
            };
            return prev.concat({
              id: uuidv4(),
              speciesKey,
              name:
                (SPECIES_CONFIG[speciesKey]?.label ?? "Animal") +
                " " +
                ((Math.random() * 100) | 0),
              color: pick(palettes[speciesKey] || palettes.cat),
              position: [x, z],
              yaw: Math.random() * Math.PI * 2,
              seed: Math.random() * 10,
            });
          });
        }, []);

        const registerHit = useCallback((obj, id) => {
          if (!obj) return;
          if (!hitObjectsRef.current.includes(obj))
            hitObjectsRef.current.push(obj);
          hitToIdRef.current.set(obj.uuid, id);
        }, []);

        const unregisterHit = useCallback((obj) => {
          if (!obj) return;
          const i = hitObjectsRef.current.indexOf(obj);
          if (i >= 0) hitObjectsRef.current.splice(i, 1);
          hitToIdRef.current.delete(obj.uuid);
        }, []);

        const registerAPI = useCallback((id, api) => {
          petAPIMapRef.current.set(id, api);
        }, []);

        const unregisterAPI = useCallback((id) => {
          petAPIMapRef.current.delete(id);
        }, []);

        // Social manager
        const pairCooldownRef = useRef(new Map());
        const SOCIAL_DISTANCE = 1.3;
        const SOCIAL_COOLDOWN_S = 9;
        const SOCIAL_DURATION = 1.2;

        useFrame((state) => {
          const t = state.clock.getElapsedTime();
          const ids = Array.from(petAPIMapRef.current.keys());

          for (let i = 0; i < ids.length; i++) {
            for (let j = i + 1; j < ids.length; j++) {
              const a = ids[i];
              const b = ids[j];
              if (heldRef.current.id === a || heldRef.current.id === b)
                continue;

              const pa = allPosMapRef.current.get(a);
              const pb = allPosMapRef.current.get(b);
              if (!pa || !pb) continue;

              const dx = pa.x - pb.x;
              const dz = pa.z - pb.z;
              const d2 = dx * dx + dz * dz;
              if (d2 > SOCIAL_DISTANCE * SOCIAL_DISTANCE) continue;

              const key = a < b ? a + "|" + b : b + "|" + a;
              const until = pairCooldownRef.current.get(key) || 0;
              if (t < until) continue;
              pairCooldownRef.current.set(key, t + SOCIAL_COOLDOWN_S);

              const apiA = petAPIMapRef.current.get(a);
              const apiB = petAPIMapRef.current.get(b);
              if (!apiA || !apiB) continue;

              const untilT = t + SOCIAL_DURATION;
              apiA.setSocial?.({
                partnerId: b,
                until: untilT,
                partnerPos: new THREE.Vector3(pb.x, 0, pb.z),
              });
              apiB.setSocial?.({
                partnerId: a,
                until: untilT,
                partnerPos: new THREE.Vector3(pa.x, 0, pa.z),
              });

              heartAPIRef.current?.emit?.(
                new THREE.Vector3(
                  (pa.x + pb.x) * 0.5,
                  0.6,
                  (pa.z + pb.z) * 0.5
                ),
                2
              );
            }
          }
        });

        function HUD() {
          return (
            <Html fullscreen style={{ pointerEvents: "none" }}>
              <div
                className="fixed top-3 left-3 z-[1200] pointer-events-auto"
                style={{
                  display: hudVisible ? "block" : "none",
                  maxWidth: "min(560px,92vw)",
                }}
              >
                <div className="glass px-4 py-3">
                  <div className="flex items-start justify-between gap-3">
                    <div>
                      <div className="text-lg font-bold leading-tight">
                        Biome
                      </div>
                      <div className="text-xs text-white/70">
                        No-build R3F â€¢ True-walk locomotion â€¢ Center-ray
                        interact
                      </div>
                      <div className="mt-1 text-[11px] text-white/55">
                        H: toggle HUD â€¢ Click canvas: lock pointer â€¢ WASD move â€¢
                        Shift sprint
                      </div>
                    </div>
                    <div className="text-[11px] rounded-full px-2 py-1 border border-white/10 bg-white/10 text-white/80">
                      {pets.length}/{MAX}
                    </div>
                  </div>

                  <div className="mt-3 grid grid-cols-5 gap-2 text-[11px]">
                    {SPECIES_KEYS.map((k) => (
                      <div
                        key={k}
                        className="rounded-xl border border-white/10 bg-white/5 px-2 py-2"
                      >
                        <div className="text-white/90 font-semibold flex items-center justify-between">
                          <span>
                            {SPECIES_CONFIG[k].icon} {SPECIES_CONFIG[k].label}
                          </span>
                          <span className="text-white/70">
                            {counts[k] || 0}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>

                  <div className="mt-3 flex items-center justify-between gap-3">
                    <div className="text-[11px] text-white/60">Spawn</div>
                    <div className="grid grid-cols-5 gap-2">
                      {SPECIES_KEYS.map((k) => (
                        <button
                          key={k}
                          className="px-2 py-2 rounded-xl bg-white/10 hover:bg-white/15 border border-white/15 text-base"
                          onClick={() => addPet(k)}
                          title={`Add ${SPECIES_CONFIG[k].label}`}
                        >
                          {SPECIES_CONFIG[k].icon}
                        </button>
                      ))}
                    </div>
                  </div>

                  <div className="mt-2 text-[11px] text-white/55 space-y-1">
                    <div>
                      <strong>Click</strong> on a pet (crosshair) = hearts
                    </div>
                    <div>
                      <strong>Hold click</strong> (0.2s) = pick up (dangle) â€¢
                      release to drop
                    </div>
                    <div>
                      <strong>Social</strong>: nose-boop greetings
                    </div>
                  </div>
                </div>
              </div>
            </Html>
          );
        }

        // -----------------------------
        // True-Walk FPS Controller
        // -----------------------------

        function PlayerController() {
          const { camera, gl } = useThree();
          const [, getKeys] = useKeyboardControls();

          const raycaster = useMemo(() => new THREE.Raycaster(), []);
          const downRayOrigin = useMemo(() => new THREE.Vector3(), []);
          const downDir = useMemo(() => new THREE.Vector3(0, -1, 0), []);

          const tmpForward = useMemo(() => new THREE.Vector3(), []);
          const tmpRight = useMemo(() => new THREE.Vector3(), []);
          const tmpMove = useMemo(() => new THREE.Vector3(), []);

          const interactionRef = useRef({ down: false, t: 0, targetId: null });

          const raycastCenterPet = useCallback(() => {
            if (!hitObjectsRef.current.length) return null;
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const hits = raycaster.intersectObjects(
              hitObjectsRef.current,
              false
            );
            if (!hits.length) return null;
            const obj = hits[0].object;
            return hitToIdRef.current.get(obj.uuid) || null;
          }, [camera, raycaster]);

          const raycastGroundY = useCallback(() => {
            const arr = groundObjectsRef?.current || [];
            if (!arr.length) return 0;
            downRayOrigin.set(
              camera.position.x,
              camera.position.y + 5.0,
              camera.position.z
            );
            raycaster.ray.origin.copy(downRayOrigin);
            raycaster.ray.direction.copy(downDir);
            raycaster.far = 50;
            const hits = raycaster.intersectObjects(arr, false);
            if (hits.length) return hits[0].point.y;
            return 0;
          }, [camera, downDir, downRayOrigin, groundObjectsRef, raycaster]);

          useEffect(() => {
            const el = gl.domElement;
            const onLockChange = () => {
              const locked = document.pointerLockElement === el;
              crosshairEl.classList.toggle("show", locked);
            };
            document.addEventListener("pointerlockchange", onLockChange);
            onLockChange();
            return () =>
              document.removeEventListener("pointerlockchange", onLockChange);
          }, [gl.domElement]);

          useEffect(() => {
            const el = gl.domElement;

            const onDown = (e) => {
              if (e.button !== 0) return;
              if (document.pointerLockElement !== el) return;
              interactionRef.current.down = true;
              interactionRef.current.t = 0;
              interactionRef.current.targetId = raycastCenterPet();
            };

            const onUp = (e) => {
              if (e.button !== 0) return;
              if (document.pointerLockElement !== el) return;

              const wasHolding = !!heldRef.current.id;
              const id = interactionRef.current.targetId;
              const pressT = interactionRef.current.t;

              if (wasHolding) {
                heldRef.current.id = null;
              } else {
                if (id && pressT < 0.18) {
                  petAPIMapRef.current.get(id)?.pet?.();
                }
              }

              interactionRef.current.down = false;
              interactionRef.current.t = 0;
              interactionRef.current.targetId = null;
            };

            window.addEventListener("mousedown", onDown);
            window.addEventListener("mouseup", onUp);
            return () => {
              window.removeEventListener("mousedown", onDown);
              window.removeEventListener("mouseup", onUp);
            };
          }, [gl.domElement, raycastCenterPet]);

          useFrame((state, dt) => {
            const k = getKeys();
            const sprint = !!k.sprint;

            let mx = (k.right ? 1 : 0) - (k.left ? 1 : 0);
            let mz = (k.backward ? 1 : 0) - (k.forward ? 1 : 0);

            const moving = Math.abs(mx) + Math.abs(mz) > 0.01;
            const len = Math.hypot(mx, mz) || 1;
            mx /= len;
            mz /= len;

            const baseSpeed = 3.6;
            const speed = sprint ? baseSpeed * 1.65 : baseSpeed;

            camera.getWorldDirection(tmpForward);
            tmpForward.y = 0;
            tmpForward.normalize();
            tmpRight.set(tmpForward.z, 0, -tmpForward.x);

            tmpMove.set(0, 0, 0);
            tmpMove.addScaledVector(tmpRight, mx);
            tmpMove.addScaledVector(tmpForward, mz);
            const dl = tmpMove.length();
            if (dl > 0.001) tmpMove.multiplyScalar(1 / dl);

            camera.position.x += tmpMove.x * speed * dt;
            camera.position.z += tmpMove.z * speed * dt;

            // keep within world
            const rr = Math.hypot(camera.position.x, camera.position.z);
            if (rr > WORLD.radius) {
              const s = WORLD.radius / (rr || 1);
              camera.position.x *= s;
              camera.position.z *= s;
            }

            // ground snap via downward raycast
            const groundY = raycastGroundY();
            const targetY = groundY + 1.7;
            const headBob = moving
              ? Math.sin(state.clock.getElapsedTime() * (sprint ? 10.5 : 8.0)) *
                (sprint ? 0.06 : 0.045)
              : 0;
            const finalY = targetY + headBob;
            const kY = 1 - Math.pow(0.7, dt * 60);
            camera.position.y = MU.lerp(camera.position.y, finalY, kY);

            playerRef.current.pos.copy(camera.position);
            playerRef.current.isSprinting = sprint;
            playerRef.current.speed = moving ? speed : 0;

            // Hold-to-pickup under crosshair
            if (document.pointerLockElement === state.gl.domElement) {
              if (interactionRef.current.down) {
                interactionRef.current.t += dt;
                if (!heldRef.current.id && interactionRef.current.t > 0.2) {
                  const id = interactionRef.current.targetId;
                  if (id) heldRef.current.id = id;
                }
              }

              if (heldRef.current.id) {
                camera.getWorldDirection(tmpForward);
                tmpForward.y = 0;
                tmpForward.normalize();
                heldRef.current.target
                  .copy(camera.position)
                  .addScaledVector(tmpForward, 2.25);
                const gy = groundHeightAt(
                  heldRef.current.target.x,
                  heldRef.current.target.z,
                  rugs
                );
                heldRef.current.target.y = gy + 1.55;
              }
            }
          });

          return null;
        }

        return (
          <>
            <HUD />

            <HeartPool apiRef={heartAPIRef} />
            <BreathPool apiRef={breathAPIRef} />

            <PlayerController />

            {pets.map((p) => (
              <Pet
                key={p.id}
                pet={p}
                rampTex={rampTex}
                rugs={rugs}
                registerHit={registerHit}
                unregisterHit={unregisterHit}
                registerAPI={registerAPI}
                unregisterAPI={unregisterAPI}
                playerRef={playerRef}
                heldRef={heldRef}
                heartAPIRef={heartAPIRef}
                breathAPIRef={breathAPIRef}
                allPosMapRef={allPosMapRef}
              />
            ))}
          </>
        );
      }

      // -----------------------------
      // Main Scene
      // -----------------------------

      function Scene() {
        const rampTex = useToonRampTexture();
        const rugs = useRugs();
        const groundObjectsRef = useRef([]);

        return (
          <div className="w-screen h-screen overflow-hidden">
            <KeyboardControls
              map={[
                { name: "forward", keys: ["KeyW", "ArrowUp"] },
                { name: "backward", keys: ["KeyS", "ArrowDown"] },
                { name: "left", keys: ["KeyA", "ArrowLeft"] },
                { name: "right", keys: ["KeyD", "ArrowRight"] },
                { name: "sprint", keys: ["ShiftLeft", "ShiftRight"] },
              ]}
            >
              <Canvas
                dpr={Math.min(window.devicePixelRatio || 1, 2)}
                gl={{
                  antialias: true,
                  powerPreference: "high-performance",
                  alpha: false,
                }}
                camera={{
                  position: [0, 1.7, 6.5],
                  fov: 60,
                  near: 0.1,
                  far: 140,
                }}
                onCreated={({ gl }) => {
                  gl.domElement.addEventListener("click", () => {
                    if (!document.pointerLockElement)
                      gl.domElement.requestPointerLock?.();
                  });
                }}
              >
                <color attach="background" args={["#050610"]} />
                <fog attach="fog" args={["#050610", 10, 56]} />

                <ambientLight intensity={0.85} color={"#90a6ff"} />
                <directionalLight
                  intensity={1.25}
                  position={[7, 12, 5]}
                  color={"#ffffff"}
                />
                <directionalLight
                  intensity={0.35}
                  position={[-6, 7, -8]}
                  color={"#7b8dff"}
                />

                <Sky
                  distance={450000}
                  sunPosition={[0.5, 0.2, 0.8]}
                  turbidity={8}
                  rayleigh={2.6}
                  mieCoefficient={0.01}
                  mieDirectionalG={0.8}
                />
                <Stars
                  radius={75}
                  depth={35}
                  count={1100}
                  factor={2.2}
                  saturation={0}
                  fade
                  speed={0.35}
                />
                <Sparkles
                  count={90}
                  speed={0.22}
                  opacity={0.25}
                  scale={[38, 10, 38]}
                  size={1.2}
                  color={"#cbd7ff"}
                />

                <Ground rampTex={rampTex} groundObjectsRef={groundObjectsRef} />
                <Rugs
                  rugs={rugs}
                  rampTex={rampTex}
                  groundObjectsRef={groundObjectsRef}
                />

                <PointerLockControls makeDefault />

                <PetSystem
                  rampTex={rampTex}
                  rugs={rugs}
                  groundObjectsRef={groundObjectsRef}
                />
              </Canvas>
            </KeyboardControls>
          </div>
        );
      }

      // Mount
      try {
        const root = createRoot(document.getElementById("root"));
        root.render(<Scene />);
        bootEl2.style.display = "none";
      } catch (err) {
        const errorEl = document.getElementById("errorOverlay");
        errorEl.style.display = "block";
        errorEl.textContent =
          "Biome failed to start:\n\n" +
          (err && err.stack ? err.stack : String(err));
        bootEl2.style.display = "none";
      }
    </script>
  </body>
</html>
